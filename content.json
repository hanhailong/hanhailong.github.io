{"meta":{"title":"韩海龙的博客","subtitle":"学习总结 思考感悟 知识管理 代码分享","description":"学习总结 思考感悟 知识管理 代码分享","author":"韩海龙","url":"http://hanhailong.com"},"pages":[{"title":"","date":"2015-10-08T12:54:56.000Z","updated":"2015-10-08T12:54:56.000Z","comments":true,"path":"404.html","permalink":"http://hanhailong.com/404.html","excerpt":"","text":"404"},{"title":"标签","date":"2016-03-12T16:02:13.000Z","updated":"2016-04-01T09:00:47.000Z","comments":true,"path":"tags/index.html","permalink":"http://hanhailong.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2016-03-12T16:03:00.000Z","updated":"2016-04-01T09:00:47.000Z","comments":true,"path":"categories/index.html","permalink":"http://hanhailong.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2015-10-08T09:47:43.000Z","updated":"2016-04-24T04:25:45.000Z","comments":true,"path":"aboutme/index.html","permalink":"http://hanhailong.com/aboutme/index.html","excerpt":"","text":"我是一个程序猿，实打实的悲催80后，毕业之后就开始从事移动开发领域（之前是Java Web开发），从事Android、IOS手机应用App研发工作，对手机App开发有着无比浓郁的兴趣，15年加入极客学院，开始涉足在线IT教育这一领域（我非常看好并向往的…），但我不是里面的讲师，而是实打实的码农… 16年4月离开极客，加入了58同城 我平时喜欢看别人写的博客、开源项目，在github上star、fork了很多别人的优秀开源项目，几百个肯定是有的，自己也非常想写，但是自己太懒又没时间，所以就没有什么拿得出手的开源项目和博客… 不过我现在在慢慢转变，开源项目没有，博客在慢慢写，慢慢积累沉淀。。。 我喜欢开发工作，喜欢被大牛指着鼻子骂：“这个地方写的什么玩意，懂面向对象六大原则吗？应该这么写。。。”！！！不懂不会的地方就应该俯下身子向前辈们好好地学习，比你多的牛人多了去了，就应该好好地学习、沉淀、厚积薄发才对！！ 联系方式： 手机号：15810857061 QQ：826605224 邮箱：hanhailong.cool@163.com Github：韩海龙的Github CSDN：韩海龙的CSDN"}],"posts":[{"title":"Synchronized与Lock锁的区别","slug":"Synchronized与Lock锁的区别","date":"2016-12-10T02:38:36.000Z","updated":"2017-09-30T15:50:34.000Z","comments":true,"path":"2016/12/10/Synchronized与Lock锁的区别/","link":"","permalink":"http://hanhailong.com/2016/12/10/Synchronized与Lock锁的区别/","excerpt":"楔子最近一直都比较忙，没有时间写博客了。今天项目终于灰度了，可以有时间写写博客，看看文章了！！！╮(╯▽╰)╭ 今天要写的主题是Java的基础知识，Synchronized和Lock锁的区别！！！ 区别1、ReentrantLock拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候等特性。","text":"楔子最近一直都比较忙，没有时间写博客了。今天项目终于灰度了，可以有时间写写博客，看看文章了！！！╮(╯▽╰)╭ 今天要写的主题是Java的基础知识，Synchronized和Lock锁的区别！！！ 区别1、ReentrantLock拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候等特性。 线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定 如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断 如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情 ReentrantLock获取锁定与三种方式： lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁 tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false； tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false； lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断 2、synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中 3、在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态； 5.0的多线程任务包对于同步的性能方面有了很大的改进，在原有synchronized关键字的基础上，又增加了ReentrantLock，以及各种Atomic类。了解其性能的优劣程度，有助与我们在特定的情形下做出正确的选择。 简单的总结 synchronized：在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好，不管用没用过5.0多线程包的程序员都能理解。 ReentrantLock:ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。在资源竞争不激烈的情形下，性能稍微比synchronized差点点。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。 Atomic:和上面的类似，不激烈情况下，性能比synchronized略逊，而激烈的时候，也能维持常态。激烈的时候，Atomic的性能会优于ReentrantLock一倍左右。但是其有一个缺点，就是只能同步一个值，一段代码中只能出现一个Atomic的变量，多于一个同步无效。因为他不能在多个Atomic之间同步。 所以，我们写同步的时候，优先考虑synchronized，如果有特殊需要，再进一步优化。ReentrantLock和Atomic如果用的不好，不仅不能提高性能，还可能带来灾难。 测试结果先贴测试结果：再贴代码（Atomic测试代码不准确，一个同步中只能有1个Actomic，这里用了2个，但是这里的测试只看速度） round:100000 thread:5Sync = 35301694Lock = 56255753Atom = 43467535 round:200000 thread:10Sync = 110514604Lock = 204235455Atom = 170535361 round:300000 thread:15Sync = 253123791Lock = 448577123Atom = 362797227 round:400000 thread:20Sync = 16562148262Lock = 846454786Atom = 667947183 round:500000 thread:25Sync = 26932301731Lock = 1273354016Atom = 982564544 Java代码package test.thread; import static java.lang.System.out; import java.util.Random; import java.util.concurrent.BrokenBarrierException; import java.util.concurrent.CyclicBarrier; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicLong; import java.util.concurrent.locks.ReentrantLock; public class TestSyncMethods { public static void test(int round,int threadNum,CyclicBarrier cyclicBarrier){ new SyncTest(\"Sync\",round,threadNum,cyclicBarrier).testTime(); new LockTest(\"Lock\",round,threadNum,cyclicBarrier).testTime(); new AtomicTest(\"Atom\",round,threadNum,cyclicBarrier).testTime(); } public static void main(String args[]){ for(int i=0;i&lt;5;i++){ int round=100000*(i+1); int threadNum=5*(i+1); CyclicBarrier cb=new CyclicBarrier(threadNum*2+1); out.println(\"==========================\"); out.println(\"round:\"+round+\" thread:\"+threadNum); test(round,threadNum,cb); } } } class SyncTest extends TestTemplate{ public SyncTest(String _id,int _round,int _threadNum,CyclicBarrier _cb){ super( _id, _round, _threadNum, _cb); } @Override /** * synchronized关键字不在方法签名里面，所以不涉及重载问题 */ synchronized long getValue() { return super.countValue; } @Override synchronized void sumValue() { super.countValue+=preInit[index++%round]; } } class LockTest extends TestTemplate{ ReentrantLock lock=new ReentrantLock(); public LockTest(String _id,int _round,int _threadNum,CyclicBarrier _cb){ super( _id, _round, _threadNum, _cb); } /** * synchronized关键字不在方法签名里面，所以不涉及重载问题 */ @Override long getValue() { try{ lock.lock(); return super.countValue; }finally{ lock.unlock(); } } @Override void sumValue() { try{ lock.lock(); super.countValue+=preInit[index++%round]; }finally{ lock.unlock(); } } } class AtomicTest extends TestTemplate{ public AtomicTest(String _id,int _round,int _threadNum,CyclicBarrier _cb){ super( _id, _round, _threadNum, _cb); } @Override /** * synchronized关键字不在方法签名里面，所以不涉及重载问题 */ long getValue() { return super.countValueAtmoic.get(); } @Override void sumValue() { super.countValueAtmoic.addAndGet(super.preInit[indexAtomic.get()%round]); } } abstract class TestTemplate{ private String id; protected int round; private int threadNum; protected long countValue; protected AtomicLong countValueAtmoic=new AtomicLong(0); protected int[] preInit; protected int index; protected AtomicInteger indexAtomic=new AtomicInteger(0); Random r=new Random(47); //任务栅栏，同批任务，先到达wait的任务挂起，一直等到全部任务到达制定的wait地点后，才能全部唤醒，继续执行 private CyclicBarrier cb; public TestTemplate(String _id,int _round,int _threadNum,CyclicBarrier _cb){ this.id=_id; this.round=_round; this.threadNum=_threadNum; cb=_cb; preInit=new int[round]; for(int i=0;i&lt;preInit.length;i++){ preInit[i]=r.nextInt(100); } } abstract void sumValue(); /* * 对long的操作是非原子的，原子操作只针对32位 * long是64位，底层操作的时候分2个32位读写，因此不是线程安全 */ abstract long getValue(); public void testTime(){ ExecutorService se=Executors.newCachedThreadPool(); long start=System.nanoTime(); //同时开启2*ThreadNum个数的读写线程 for(int i=0;i&lt;threadNum;i++){ se.execute(new Runnable(){ public void run() { for(int i=0;i&lt;round;i++){ sumValue(); } //每个线程执行完同步方法后就等待 try { cb.await(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (BrokenBarrierException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }); se.execute(new Runnable(){ public void run() { getValue(); try { //每个线程执行完同步方法后就等待 cb.await(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (BrokenBarrierException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }); } try { //当前统计线程也wait,所以CyclicBarrier的初始值是threadNum*2+1 cb.await(); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (BrokenBarrierException e) { // TODO Auto-generated catch block e.printStackTrace(); } //所有线程执行完成之后，才会跑到这一步 long duration=System.nanoTime()-start; out.println(id+\" = \"+duration); } } 补充知识CyclicBarrier和CountDownLatch一样，都是关于线程的计数器。 CyclicBarrier初始化时规定一个数目，然后计算调用了CyclicBarrier.await()进入等待的线程数。当线程数达到了这个数目时，所有进入等待状态的线程被唤醒并继续。 CyclicBarrier就象它名字的意思一样，可看成是个障碍， 所有的线程必须到齐后才能一起通过这个障碍。 CyclicBarrier初始时还可带一个Runnable的参数， 此Runnable任务在CyclicBarrier的数目达到后，所有其它线程被唤醒前被执行。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://hanhailong.com/tags/Java/"}]},{"title":"Android构建神器之Gradle","slug":"Android构建神器之Gradle","date":"2016-08-31T07:26:19.000Z","updated":"2016-08-31T08:17:29.000Z","comments":true,"path":"2016/08/31/Android构建神器之Gradle/","link":"","permalink":"http://hanhailong.com/2016/08/31/Android构建神器之Gradle/","excerpt":"","text":"什么是GradleGradle构建生命周期构建阶段初始化阶段配置阶段执行阶段Groovy小demoGradle实战Android Gradle实战","categories":[],"tags":[{"name":"-- Android -- Gradle","slug":"Android-Gradle","permalink":"http://hanhailong.com/tags/Android-Gradle/"}]},{"title":"Android-分析并优化首页启动时间","slug":"Android-分析并优化首页启动时间","date":"2016-07-31T09:21:07.000Z","updated":"2016-08-01T02:28:23.000Z","comments":true,"path":"2016/07/31/Android-分析并优化首页启动时间/","link":"","permalink":"http://hanhailong.com/2016/07/31/Android-分析并优化首页启动时间/","excerpt":"","text":"前言随着app项目越来越大，功能业务越来越多，需要我们初始化的模块也越来越多，application中onCreate和attachBaseContext方法越来越臃肿，最直接导致的是我们app启动时间大大增加 性能分析首页HomeActivity执行命令 am start -W com.wuba/com.wuba.home.activity.HomeActivity 输出结果： Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.wuba/.home.activity.HomeActivity } Status: ok Activity: com.wuba/.home.activity.HomeActivity ThisTime: 1858 TotalTime: 1858 WaitTime: 1925 Complete 启动页面LaunchActivity执行命令 adb shell start -W com.wuba/com.wuba.activity.launch.LaunchActivity 输出结果 Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.wuba/.activity.launch.LaunchActivity } Status: ok Activity: com.wuba/.activity.launch.LaunchActivity ThisTime: 1134 TotalTime: 1134 WaitTime: 1147 Complete 启动场景冷启动也就是我们常说的冷启动,这时候你的应用程序的进程是没有创建的. 这也是大部分应用的使用场景.用户在桌面上点击你应用的 icon 之后,首先要创建进程,然后才启动 MainActivity.这时候adb shell am start -w packagename/xxxActivity 返回的结果,就是标准的应用程序的启动时间（注意 Android 5.0 之前的手机是没有 WaitTime 这个值的）: Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.wuba/.home.activity.HomeActivity } Status: ok Activity: com.wuba/.home.activity.HomeActivity ThisTime: 1858 TotalTime: 1858 WaitTime: 1925 Complete 热启动就是应用不是第一次启动，如果是你按Back键，并没有将应用进程杀掉的话，那么执行上述命令就会快一些，因为不用创建进程了，只需要启动一个Activity即可。这也就是我们说的应用热启动。 参考资料http://www.open-open.com/lib/view/open1451570355573.html 知乎·计算apk的启动时间","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"ReactNative开发Android端遇到的一些坑总结","slug":"ReactNative开发Android端遇到的一些坑总结","date":"2016-07-16T03:13:24.000Z","updated":"2016-07-18T15:38:51.000Z","comments":true,"path":"2016/07/16/ReactNative开发Android端遇到的一些坑总结/","link":"","permalink":"http://hanhailong.com/2016/07/16/ReactNative开发Android端遇到的一些坑总结/","excerpt":"","text":"","categories":[],"tags":[{"name":"-- Android -- ReactNative","slug":"Android-ReactNative","permalink":"http://hanhailong.com/tags/Android-ReactNative/"}]},{"title":"优化查询加载大数量的本地相册图片","slug":"优化查询加载大数量的本地相册图片","date":"2016-06-27T08:20:09.000Z","updated":"2016-12-10T03:56:21.000Z","comments":true,"path":"2016/06/27/优化查询加载大数量的本地相册图片/","link":"","permalink":"http://hanhailong.com/2016/06/27/优化查询加载大数量的本地相册图片/","excerpt":"优化查询加载大数量的本地相册图片一、概述讲解优化查询相册图片之前，我们先来看下PM提出的需求，PM的需求很简单，就是要做一个类似微信的本地相册图片查询控件，主要包含两个两部分： 进入图片选择页面就要显示出手机中所有的照片，包括系统相册图片和其他目录下的所有图片，并按照时间倒叙排列 切换相册功能，切换相册页面列出手机中所有的图片目录列表，并且显示出每个目录下所有的图片个数以及封面图片 这两个需求看似简单，实则隐藏着一系列的性能优化问题。在做优化之前，我们调研了一些其他比较出名的app在加载大数量图片的性能表现（gif录制的不够清晰，但展示问题已经够了）： 微信 微信的图片查询速度还是非常快的，基本上进入图片选择页面，相册数据就已经查出来了，包括各个图片目录下图片的个数和封面图片的url，这个体验还是比较好的 新浪微博 相比较微信来说，新浪微博做的体验就比较差了，进入图片选择页面后，先是黑屏然后是白屏，连个进度条都没有，让用户以为app死掉了，等过一段时间才显示出来，这个体验较差 QQ QQ一上来是加载的最近100张照片，这个速度非常快，但是进入Camera相册（有5000多张）后，有一个进度条等待，我体验了下，等待的时间还是比较长的，这个体验比新浪微博稍微好点，比微信差 闲鱼 闲鱼是做的最烂的一个，一上来是卡死四五秒，然后是黑屏两三秒，最后才显示出来","text":"优化查询加载大数量的本地相册图片一、概述讲解优化查询相册图片之前，我们先来看下PM提出的需求，PM的需求很简单，就是要做一个类似微信的本地相册图片查询控件，主要包含两个两部分： 进入图片选择页面就要显示出手机中所有的照片，包括系统相册图片和其他目录下的所有图片，并按照时间倒叙排列 切换相册功能，切换相册页面列出手机中所有的图片目录列表，并且显示出每个目录下所有的图片个数以及封面图片 这两个需求看似简单，实则隐藏着一系列的性能优化问题。在做优化之前，我们调研了一些其他比较出名的app在加载大数量图片的性能表现（gif录制的不够清晰，但展示问题已经够了）： 微信 微信的图片查询速度还是非常快的，基本上进入图片选择页面，相册数据就已经查出来了，包括各个图片目录下图片的个数和封面图片的url，这个体验还是比较好的 新浪微博 相比较微信来说，新浪微博做的体验就比较差了，进入图片选择页面后，先是黑屏然后是白屏，连个进度条都没有，让用户以为app死掉了，等过一段时间才显示出来，这个体验较差 QQ QQ一上来是加载的最近100张照片，这个速度非常快，但是进入Camera相册（有5000多张）后，有一个进度条等待，我体验了下，等待的时间还是比较长的，这个体验比新浪微博稍微好点，比微信差 闲鱼 闲鱼是做的最烂的一个，一上来是卡死四五秒，然后是黑屏两三秒，最后才显示出来 二、综合对比经过综合对比后，就微信做的还比较好，基本上进入相册页面就能展示出所有照片，相册目录也非常快的展示出来！！！ 经过我们的调研，发现微信是采用循环分页加载策略，我们优化的思路也是采用这种策略，先看优化后的效果图： 进入图片选择页面，图片能够非常快的显示出来，进入更换相册页面，图片目录也能非常快的显示出来，这里没有像微信一样做图片目录的缓存：一是因为查询速度非常快，基本上不到2秒就加载出来了，二是能够实时刷新出相册的最新数据 频繁的切换各个相册目录，图片都能非常快速的查询出来，体验还是不错的！！！ 三、优化实现优化查询相册目录因为要列举出所有的相册目录列表，这里没有其他好的办法，直接请求ContentResolver的query方法来查询，这里为了加速查询，去掉了while循环中一些耗时的判断，将一些检测图片是否判断的逻辑移到外面去，具体用的时候再去判断 查询图片的URI MediaStore.Images.Media.EXTERNAL_CONTENT_URI 因为我们只查询图片url和图片所在的目录 String[] projection = {MediaStore.Images.ImageColumns.DATA, MediaStore.Images.ImageColumns.BUCKET_DISPLAY_NAME}; PM要求相册按照图片的时间倒叙排列，图片的创建、修改会影响其所在目录的排序，排序按时间倒叙排列 String sortOrder = MediaStore.Images.Media.DATE_TAKEN + \" DESC \"; 根据这些查询条件，经过query之后得到一个Cursor，这个cursor里面就包含我们所需要的所有图片的信息，然后我们while循环遍历这个cursor,在while循环中一定不能有耗时操作 //一个辅助集合，防止同一目录被扫描多次 HashSet&lt;String&gt; dirPaths = new HashSet&lt;String&gt;(); while (cursor.moveToNext()) { // 获取图片的路径 String path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA)); String bucketName = cursor.getString(cursor.getColumnIndex(MediaStore.Images.ImageColumns.BUCKET_DISPLAY_NAME)); if (TextUtils.isEmpty(allFolderItem.coverImagePath)) { allFolderItem.coverImagePath = path; } File parentFile = new File(path).getParentFile(); if (parentFile == null) continue; String dirPath = parentFile.getAbsolutePath(); PicFolderItem folderItem = null; // 利用一个HashSet防止多次扫描同一个文件夹（不加这个判断，图片多起来还是相当恐怖的~~） if (dirPaths.contains(dirPath)) { continue; } else { dirPaths.add(dirPath); boolean isNew = true; //判断一下是否dirPath不同，但是bucketName相同 for (PicFolderItem item : picList) { if (item.name.equals(bucketName)) { folderItem = item; item.addParentPath(dirPath); isNew = false; break; } } if (isNew) { folderItem = new PicFolderItem(); folderItem.coverImagePath = path; folderItem.name = bucketName; folderItem.addParentPath(dirPath); } } String[] array = parentFile.list(new FilenameFilter() { @Override public boolean accept(File dir, String filename) { if (filename.endsWith(\".jpg\") || filename.endsWith(\".png\") || filename.endsWith(\".jpeg\")) return true; return false; } }); int arrayCount = array == null ? 0 : array.length; folderItem.count += arrayCount; if (!picList.contains(folderItem) &amp;&amp; arrayCount &gt; 0) { picList.add(folderItem); } } 这样就能非常快速的查询出手机中所有的图片目录、目录的图片张数以及封面图url。这里主要优化了三点： while循环中去除耗时判断 之前的代码中存在判断文件图片是否存在的代码： public static boolean isFileExist(String path) { File file = new File(path); if (file == null || !file.exists()) { return false; } return true; } 这段代码放到while循环中是很恐怖的，我测试了下，5000多张图片都要检测的话总时间会增加三四秒。这个判断可以放到外面去，具体操作哪一个图片的时候再做具体的业务判断！ 防止一个图片文件夹被扫描多次 这里添加了一个变量来存储已经扫描过的图片目录，已经扫描的就不在处理了： //一个辅助集合，防止统一目录查询多次 HashSet&lt;String&gt; dirPaths = new HashSet&lt;String&gt;(); 这块优化了之后效果还是很明显的，相同的目录不会扫描多次！ 获取图片目录下图片个数 String[] array = parentFile.list(new FilenameFilter() { @Override public boolean accept(File dir, String filename) { if (filename.endsWith(\".jpg\") || filename.endsWith(\".png\") || filename.endsWith(\".jpeg\")) return true; return false; } }); 这个file.list()方法内部是一个native方法，查询效率非常快！！！ 当然获取某个目录下的图片有多少张也可以通过cursor查询的方式来获取！！! 查询某个相册目录下的所有照片在介绍查询目录下的照片之前，我们先介绍下我们查询图片的两种策略，一种是针对目录下图片比较多的，动不动就上千上万张的那种；另一种是那种目录下图片比较少的，就几百张图片 一次加载策略 当目录下图片数量小于1000张时采用file.list这个native方法来一次加载所有图片，这个native查询效率非常快，上千张图片都是秒级查询出来 循环分页加载策略 当图片数量大于等于1000张时采用循环分页加载策略，这种策略专门针对图片数量特别多的情况，通过分页的方式先把第一页的图片加载出来，让用户能第一眼看到最新的图片，然后后台异步循环的查询下一页图片，直到所有图片都查询完成，这也是微信的查询相册策略。 一次加载策略实现我们这里看下一次加载完策略实现代码，首先通过File的list方法将后缀为图片格式的文件过滤出来，返回一个图片路径数组 File dirFile = new File(dir); String[] list = dirFile.list(new FilenameFilter() { @Override public boolean accept(File dir, String filename) { if (filename.endsWith(\".jpg\") || filename.endsWith(\".png\") || filename.endsWith(\".jpeg\")) return true; return false; } }); 因为我们要的是按时间倒叙进行排列的数组，所以要对上面查询出来的数组进行排序，这里用到了File文件lastModified方法 Collections.sort(strings, new Comparator&lt;String&gt;() { @Override public int compare(String lhs, String rhs) { Long time1 = new File(lhs).lastModified(); Long time2 = new File(rhs).lastModified(); return time2.compareTo(time1); } }); 循环分页加载策略实现这个策略借鉴了微信，通过分页的方式来一页一页的加载图片，直到所有的图片都加载完成。 这里的核心就是查询条件，将你要查询的某个目录添加到查询参数中 String selection = MediaStore.Images.ImageColumns.BUCKET_DISPLAY_NAME + \" = '\" + 目录名称 + \"' \"; 这个selection一定不能写错，不然查询不出来 因为要分页，sortOrder不是简单的按照时间倒叙来排了 String sortOrder = MediaStore.Images.Media.DATE_TAKEN + \" DESC limit \" + PAGE_SIZE + \" offset \" + pageIndex * PAGE_SIZE; 最后对Cursor进行循环遍历拿到我们要的图片路径 PAGE_SIZE是个常量，表示我们要一次查询多少条，我们这里定的是200，一次查询200条数据，pageIndex是查询第几页，从0开始 一开始的时候查询第一页的数据，当查询的数据列表大小大于等于我们要查询的PageSize大小时，我们就认为有下一页，pageIndex加1循环查询下一页，直到查询的列表大小小于PageSize。 经过上面几步优化后，加载本地相册图片基本上就没有什么问题了。我们经过真机测试，图片5549张，都能够非常快速的查询出来，堪比微信和图库。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"},{"name":"本地相册图片","slug":"本地相册图片","permalink":"http://hanhailong.com/tags/本地相册图片/"}]},{"title":"React-Native-Android热更新","slug":"React-Native-Android热更新","date":"2016-04-23T11:20:42.000Z","updated":"2016-04-24T14:18:57.000Z","comments":true,"path":"2016/04/23/React-Native-Android热更新/","link":"","permalink":"http://hanhailong.com/2016/04/23/React-Native-Android热更新/","excerpt":"","text":"简介为什么要有热更新，热更新的好处是什么？ 推荐JS开发工具 Sublime WebStorm 其他 native增量更新方案参考SmartAppUpdates","categories":[],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://hanhailong.com/tags/React-Native/"}]},{"title":"React-Native移植-Android","slug":"React-Native移植-Android","date":"2016-04-23T11:20:17.000Z","updated":"2016-04-24T14:14:14.000Z","comments":true,"path":"2016/04/23/React-Native移植-Android/","link":"","permalink":"http://hanhailong.com/2016/04/23/React-Native移植-Android/","excerpt":"简介参考链接：Integrating with Existing Apps 由于公司业务需要，部分模块需要将native代码转移到react-native，并且由于是已有项目，所以我这里单独把react-native移植到项目来，移植的过程中遇到了一些问题，这里也记录了下。 网上的一些教程资料都不是很全，而且一些关键的步骤说的都不是很详细，这里我们从零开始。 还有就是环境配置这里不讲了，都是很基础的东西！ 新建一个Android项目这里我们新建一个ReactNativeProject，初始化目录结构如下： 引入React-Native在你的app目录下的build.gradle加入react-native依赖，我加入的是最新版本的0.20.1 compile 'com.facebook.react:react-native:0.20.1' 然后在AndroidManifest.xml加入访问网络权限，当然一般已经项目都有这个权限，如果有这一步可以忽略 &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; 为了让项目支持调试RN，需要在AndroidManifest.xml里面加入RN的DevSettingsActivity，如下： &lt;activity android:name=\"com.facebook.react.devsupport.DevSettingsActivity\" /&gt; 这样真机晃动手机或者点击Menu菜单就会打开相关的调试页面，如图下所示： 这里部署完后，还有一个坑，就是React-Native对编译版本和最小编译版本都有要求，它需要app的build.gradle文件的compileSdkVersion为23，minSdkVersion为16，因为我们项目要求最低版本为15甚至更低，这里需要在app的AndroidManifest.xml加入 &lt;uses-sdk tools:overrideLibrary=\"com.facebook.react\" /&gt;","text":"简介参考链接：Integrating with Existing Apps 由于公司业务需要，部分模块需要将native代码转移到react-native，并且由于是已有项目，所以我这里单独把react-native移植到项目来，移植的过程中遇到了一些问题，这里也记录了下。 网上的一些教程资料都不是很全，而且一些关键的步骤说的都不是很详细，这里我们从零开始。 还有就是环境配置这里不讲了，都是很基础的东西！ 新建一个Android项目这里我们新建一个ReactNativeProject，初始化目录结构如下： 引入React-Native在你的app目录下的build.gradle加入react-native依赖，我加入的是最新版本的0.20.1 compile 'com.facebook.react:react-native:0.20.1' 然后在AndroidManifest.xml加入访问网络权限，当然一般已经项目都有这个权限，如果有这一步可以忽略 &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; 为了让项目支持调试RN，需要在AndroidManifest.xml里面加入RN的DevSettingsActivity，如下： &lt;activity android:name=\"com.facebook.react.devsupport.DevSettingsActivity\" /&gt; 这样真机晃动手机或者点击Menu菜单就会打开相关的调试页面，如图下所示： 这里部署完后，还有一个坑，就是React-Native对编译版本和最小编译版本都有要求，它需要app的build.gradle文件的compileSdkVersion为23，minSdkVersion为16，因为我们项目要求最低版本为15甚至更低，这里需要在app的AndroidManifest.xml加入 &lt;uses-sdk tools:overrideLibrary=\"com.facebook.react\" /&gt; 加入基础的Android原生代码和JS代码我们新建一个MyReactActivity，完整代码贴下 public class MyReactActivity extends AppCompatActivity implements DefaultHardwareBackBtnHandler { private ReactRootView mReactRootView; private ReactInstanceManager mReactInstanceManager; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_my_react); mReactRootView = (ReactRootView) findViewById(R.id.react_root); mReactInstanceManager = ReactInstanceManager.builder() .setApplication(getApplication()) .setBundleAssetName(\"index.android.bundle\") .setJSMainModuleName(\"index.android\") .addPackage(new MainReactPackage()) .setUseDeveloperSupport(BuildConfig.DEBUG) .setInitialLifecycleState(LifecycleState.RESUMED) .build(); mReactRootView.startReactApplication(mReactInstanceManager, \"ReactNativeProject\", null); } @Override public void invokeDefaultOnBackPressed() { super.onBackPressed(); } @Override protected void onPause() { super.onPause(); if (mReactInstanceManager != null) { mReactInstanceManager.onPause(); } } @Override protected void onResume() { super.onResume(); if (mReactInstanceManager != null) { mReactInstanceManager.onResume(this, this); } } @Override public void onBackPressed() { if (mReactInstanceManager != null) { mReactInstanceManager.onBackPressed(); } else { super.onBackPressed(); } } @Override public boolean onKeyUp(int keyCode, KeyEvent event) { if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; mReactInstanceManager != null) { mReactInstanceManager.showDevOptionsDialog(); return true; } return super.onKeyUp(keyCode, event); } } 因为ReactRootView本身就是一个FrameLayout，我没有按官网来直接new一个，而是直接把它放到布局activity_my_react.xml里面了，代码如下： &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.hhl.reactnativeproject.MyReactActivity\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:gravity=\"center\" android:text=\"我是本地控件TextView\" android:textSize=\"20sp\" /&gt; &lt;com.facebook.react.ReactRootView android:id=\"@+id/react_root\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;/LinearLayout&gt; 这里需要强调一下下，Activity里面有两个方法，setBundleAssetName和setJSMainModuleName，其中setBundleAssetName间接调用了setJSBundleFile，而setJSBundleFile就是我们以后要讲的热修复的关键；而setJSMainModuleName设置的就是index.android.js的名字，这个可以更改目录位置。 Android代码加完了，开始加入JS代码，这里我们在项目根目录下，也就是我们的ReactNativeProject目录下加入index.android.js文件和package.json文件，index.android.js文件简单代码如下： 'use strict'; import React, { Text, View } from 'react-native'; class ReactNativeProject extends React.Component { render() { return ( &lt;View style={styles.container}&gt; &lt;Text style={styles.hello}&gt;Hello, World&lt;/Text&gt; &lt;Text&gt;测试ReactNative&lt;/Text&gt; &lt;/View&gt; ) } } var styles = React.StyleSheet.create({ container: { flex: 1, justifyContent: 'center', }, hello: { fontSize: 20, textAlign: 'center', margin: 10, }, }); React.AppRegistry.registerComponent('ReactNativeProject', () =&gt; ReactNativeProject); package.json代码如下： { \"name\": \"ReactNativeProject\", \"version\": \"1.0.0\", \"description\": \"demo\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"node node_modules/react-native/local-cli/cli.js start\" }, \"author\": \"hanhailong\", \"license\": \"ISC\", \"dependencies\": { \"react\": \"^0.14.8\", \"react-native\": \"^0.24.1\" } } 项目配置运行调试在ReactNativeProject目录下执行如下命令 $ npm init $ npm install --save react-native $ curl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig npm init命令可以不用执行，它如要用来生成package.json文件，前面我们已经创建过了，npm install –save react-native执行后会在目录下面生成node_modules文件夹并添加react-native的npm依赖 首先启动RN的npm本地服务： $ npm start 启动后如下： 在MainActivity里面我们加入跳转到MyReactActivity的代码， Intent intent = new Intent(MainActivity.this, MyReactActivity.class); startActivity(intent); 项目结构图 项目运行效果最后我们运行项目，运行效果图如下： 编译可能遇到的问题Caused by: java.lang.IllegalAccessError: tried to access method android.support.v4.net.ConnectivityManagerCompat.:(Lcom/facebook/react/bridge/ReactApplicationContext;)V from class com.facebook.react.modules.netinfo.NetInfoModule我的项目的appcompat的版本是23.2.1，改成23.0.1就好了 compile 'com.android.support:appcompat-v7:23.0.1' 下一节讲解RN热更新下一节我们将讲解RN的热更新，敬请期待！！！","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"},{"name":"React-Native","slug":"React-Native","permalink":"http://hanhailong.com/tags/React-Native/"}]},{"title":"apk打包流程梳理","slug":"apk打包流程梳理","date":"2016-04-02T05:42:26.000Z","updated":"2016-07-26T06:02:27.000Z","comments":true,"path":"2016/04/02/apk打包流程梳理/","link":"","permalink":"http://hanhailong.com/2016/04/02/apk打包流程梳理/","excerpt":"","text":"简介一些初学Android的开发者可能只知道写完项目，然后点击AndroidStudio中的run按钮就可以把项目运行到手机或者模拟器上，而一个apk是怎么从编译打包到最后签名安装到手机上的原理不知道，这里就带领大家理解一下内部的原理 简单build流程首先，我们看下官网介绍Building and Running Overview,官网给了我们一张非常简单的编译、打包、apk生成内容以及签名的图片，因为官网必须得用vpn才能访问，这里我就直接下载下来了，简单build图片如下： 图片大体介绍了从Project到运行到设备或者模拟器的一个大体流程，我们也从中看到一个完整的apk包含如下内容：一个或多个dex文件、resources.arsc、未编译的资源文件以及AndroidManifest.xml文件等等 详细打包流程官网给了我们一张非常清晰的打包流程图： 下面这幅图就是整个Android应用（不包含NDK部分）的构建编译框架详细流程说明（来源于官方）： 打包步骤总体打包步骤我们可以概括以下七步： 通过aapt打包资源文件，生成R.java和resources.arsc 处理aidl文件，生成对应的java接口文件 编译项目工程源代码，生成.class文件 Dex命令处理，将第三步生成的.class文件和第三方的库一起生成classes.dex文件 通过apkbuilder工具将aapt生成的resources.arsc、classes.dex（可能多个）、其他的资源一块打包生成apk文件 通过Jarsigner对第五步生成的apk进行debug或者release签名，只有签名完的apk才能进行安装 通过aipalign对签名后的apk进行对其处理，使apk中所有资源文件距离文件起始偏移为4字节的整数倍，从而在通过内存映射访问apk文件时会更快 其实还应该有最后一步，那就是通过adb install命令将生成的apk安装到设备或者模拟器上","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"接口和抽象类区别","slug":"接口和抽象类区别","date":"2016-04-01T07:03:02.000Z","updated":"2016-04-01T10:25:23.000Z","comments":true,"path":"2016/04/01/接口和抽象类区别/","link":"","permalink":"http://hanhailong.com/2016/04/01/接口和抽象类区别/","excerpt":"接口和抽象类有什么区别？ 你选择使用接口和抽象类的依据是什么？ 理解抽象abstract class和interface是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。 abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于 abstract class和interface的选择显得比较随意。 其实，两者之间还是有很大的区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。本文将对它们之间的区别进行一番剖析，试图给开发者提供一个在二者之间进行选择的依据。 语法定义理解 抽象类 abstract class Demo ｛ abstract void method1(); abstract void method2(); … ｝ 接口 interface Demo { void method1(); void method2(); … } 在abstract class方式中，Demo可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface方式的实现中，Demo只能够有静态的 不能被修改的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊 形式的abstract class。","text":"接口和抽象类有什么区别？ 你选择使用接口和抽象类的依据是什么？ 理解抽象abstract class和interface是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。 abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于 abstract class和interface的选择显得比较随意。 其实，两者之间还是有很大的区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。本文将对它们之间的区别进行一番剖析，试图给开发者提供一个在二者之间进行选择的依据。 语法定义理解 抽象类 abstract class Demo ｛ abstract void method1(); abstract void method2(); … ｝ 接口 interface Demo { void method1(); void method2(); … } 在abstract class方式中，Demo可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface方式的实现中，Demo只能够有静态的 不能被修改的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊 形式的abstract class。 编程角度理解首先，abstract class在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。也许，这是Java语言的设计者在考虑Java对于多重继承的支持方面的一种折中考虑吧。 其次，在abstract class的定义中，我们可以赋予方法的默认行为。但是在interface的定义中，方法却不能拥有默认行为，为了绕过这个限制，必须使用委托，但是这会 增加一些复杂性，有时会造成很大的麻烦。 一般性理解接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。 总结 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 抽象类要被子类继承，接口要被类实现。 接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。 抽象类里可以没有抽象方法 如果一个类里有抽象方法，那么这个类只能是抽象类 抽象方法要被实现，所以不能是静态的，也不能是私有的。 接口可继承接口，并可多继承接口，但类只能单根继承。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://hanhailong.com/tags/Java/"}]},{"title":"Java反转单链表实战","slug":"Java反转单链表实战","date":"2016-02-25T15:49:07.000Z","updated":"2016-03-02T13:58:13.000Z","comments":true,"path":"2016/02/25/Java反转单链表实战/","link":"","permalink":"http://hanhailong.com/2016/02/25/Java反转单链表实战/","excerpt":"算法是程序代码的灵魂！！！Java反转单链表这种算法一般会在面试中遇到，尤其是一些大公司！！！这里就来通过Java代码实战来讲解下实现反转的两种方法。 递归 普通遍历 这里介绍的两种方法都很常见，递归在算法里面非常常见！！ 首先，我们要定义一个Node节点类： public class Node{ int value; Node nextNode; public Node(int value, Node nextNode) { super(); this.value = value; this.nextNode = nextNode; } } 因为是单链表，这里只有nextNode和当前节点的值。","text":"算法是程序代码的灵魂！！！Java反转单链表这种算法一般会在面试中遇到，尤其是一些大公司！！！这里就来通过Java代码实战来讲解下实现反转的两种方法。 递归 普通遍历 这里介绍的两种方法都很常见，递归在算法里面非常常见！！ 首先，我们要定义一个Node节点类： public class Node{ int value; Node nextNode; public Node(int value, Node nextNode) { super(); this.value = value; this.nextNode = nextNode; } } 因为是单链表，这里只有nextNode和当前节点的值。 我们这里初始化n个节点的链表，我们写一个初始化Node的方法： /** * 初始化单链表 * @param num 数量 * @return */ public static Node init(int num) { Node node = new Node(0, null); Node cur = null; Node temp = null; for(int i = 1 ; i &lt; num;i++){ temp = new Node(i, null); if (i == 1) { node.nextNode = temp; }else{ cur.nextNode = temp; } cur = temp; } return node; } 然后，再把这个链表循环打印一下，先写一个out输出打印方法： /** * 打印节点值 * @param head */ private static void out(Node head) { Node tempNode = head; while(tempNode != null){ System.err.println(tempNode.value); tempNode = tempNode.nextNode; } } 我们在main方法里面打印一下结果： Node head = init(10); out(head); 最后输出的结果值为： 0 1 2 3 4 5 6 7 8 9 普通遍历 /** * 反转单链表 * @param head * @return */ private static Node reverseHead(Node head) { if (head == null) { return head; } Node pre = head; Node cur = head.nextNode; Node next = null; while(cur != null){ next = cur.nextNode; cur.nextNode = pre; pre = cur; cur = next; } head.nextNode = null; head = pre; return head; } 我们在main函数里调用下这个方法： Node reverseHead = reverseHead(head); out(reverseHead); 我们看下输出的结果值： 9 8 7 6 5 4 3 2 1 0 递归 /** * 递归反转 * @param head * @return */ private static Node reverseByRecur(Node current) { if (current == null || current.nextNode == null) return current; Node nextNode = current.nextNode; current.nextNode = null; Node reverseRest = reverseByRecur(nextNode); nextNode.nextNode = current; return reverseRest; } 我们在main函数里调用： out(reverseByRecur(head)); 我们看下输出的结果值： 9 8 7 6 5 4 3 2 1 0 两种方法都可以实现单链表反转，普通循环遍历容易理解一点，递归需要很强的逻辑性和思维性！！！","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://hanhailong.com/tags/Java/"},{"name":"算法","slug":"算法","permalink":"http://hanhailong.com/tags/算法/"}]},{"title":"Rebound-Android的弹簧动画库","slug":"Rebound-Android的弹簧动画库","date":"2016-02-16T15:55:13.000Z","updated":"2016-02-18T09:14:09.000Z","comments":true,"path":"2016/02/16/Rebound-Android的弹簧动画库/","link":"","permalink":"http://hanhailong.com/2016/02/16/Rebound-Android的弹簧动画库/","excerpt":"简介 官方网站 github Rebound是facebook出品的一个弹簧动画库，与之对应的IOS版本有一个pop动画库，也是非常的强大给力。Facebook真是互联网企业中的楷模，开源了很多的实用开源库，大赞一个！！！ 讲解Rebound之前，先看看我们根据Rebound高仿的新浪微博弹出菜单，看效果图：","text":"简介 官方网站 github Rebound是facebook出品的一个弹簧动画库，与之对应的IOS版本有一个pop动画库，也是非常的强大给力。Facebook真是互联网企业中的楷模，开源了很多的实用开源库，大赞一个！！！ 讲解Rebound之前，先看看我们根据Rebound高仿的新浪微博弹出菜单，看效果图： 话说回来，facebook为啥推出这个库呢？主要就是现有的动画离真实物理世界差别比较明显，为了让动画看起来真实自然，带有力量的效果，Rebound应运而生。两个比较重要的参数，一个是拉力Tension，一个是摩擦力Friction，拉力越大，弹簧效果越明显；摩擦力越大，弹框效果阻力越大、越不明显。如果这个摩擦力的值设置为0，就像真实世界中处于真空状态，一点摩擦力都没有，这个弹簧效果会一直无限制重复下去，根本停不下来，不信看效果图： 我们把摩擦力的值改成1试试： 初级用法 Rebound提供了非常简洁的api方法来供我们调用，我们只需要配置一些简单的参数就可以使用了，下面看看官网给出的例子： // Create a system to run the physics loop for a set of springs. SpringSystem springSystem = SpringSystem.create(); // Add a spring to the system. Spring spring = springSystem.createSpring(); // Add a listener to observe the motion of the spring. spring.addListener(new SimpleSpringListener() { @Override public void onSpringUpdate(Spring spring) { // You can observe the updates in the spring // state by asking its current value in onSpringUpdate. float value = (float) spring.getCurrentValue(); float scale = 1f - (value * 0.5f); myView.setScaleX(scale); myView.setScaleY(scale); } }); // Set the spring in motion; moving from 0 to 1 spring.setEndValue(1); 我们看下对应的效果图： 你们发现，好像弹簧效果不明显，Rebound默认的拉力和摩擦力参数分别是40和7，我们看下Rebound里面有个defaultConfig public static SpringConfig defaultConfig = SpringConfig.fromOrigamiTensionAndFriction(40, 7); 为了让弹簧效果更明显，我们修改下SpringConfig的值，代码如下： spring.setSpringConfig(SpringConfig.fromOrigamiTensionAndFriction(100,1)); 我们将拉力值改成100，摩擦力值改成1，效果图如下： 效果很赞了吧！ 高级用法：多个view连锁动画 如果想要做很多view的连锁动画怎么办？Rebound也提供了SpringChain这个接口。直接看代码吧： SpringChain springChain = SpringChain.create(40,6,50,7); int childCount = viewGroup.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View view = viewGroup.getChildAt(i); springChain.addSpring(new SimpleSpringListener() { @Override public void onSpringUpdate(Spring spring) { view.setTranslationY((float) spring.getCurrentValue()); } }); } List&lt;Spring&gt; springs = springChain.getAllSprings(); for (int i = 0; i &lt; springs.size(); i++) { springs.get(i).setCurrentValue(400); } springChain.setControlSpringIndex(2).getControlSpring().setEndValue(0); 效果图如下： 我们来看看SpringChain这个类，创建它有两个create方法： 默认无参数create() 有参数的create(int mainTension,int mainFriction,int attachmentTension,int attachmentFriction) 其中带参数的第一个参数表示起主导作用Spring的拉力系数，第二个参数表示起主导作用Spring的摩擦力系数，第三个和第四个表示附属的拉力和摩擦力系数 SpringChain需要设置一个起主导控制作用的Spring，通过setControlSpringIndex方法来设置 高仿新浪弹出菜单 先看下高仿后的效果图： 这里给出示例代码： PopMenu popMenu = new PopMenu.Builder().attachToActivity(MainActivity.this) .addMenuItem(new PopMenuItem(\"文字\", getResources().getDrawable(R.drawable.tabbar_compose_idea))) .addMenuItem(new PopMenuItem(\"照片/视频\", getResources().getDrawable(R.drawable.tabbar_compose_photo))) .addMenuItem(new PopMenuItem(\"头条文章\", getResources().getDrawable(R.drawable.tabbar_compose_headlines))) .addMenuItem(new PopMenuItem(\"签到\", getResources().getDrawable(R.drawable.tabbar_compose_lbs))) .addMenuItem(new PopMenuItem(\"点评\", getResources().getDrawable(R.drawable.tabbar_compose_review))) .addMenuItem(new PopMenuItem(\"更多\", getResources().getDrawable(R.drawable.tabbar_compose_more))) .setOnItemClickListener(new PopMenuItemListener() { @Override public void onItemClick(PopMenu popMenu, int position) { Toast.makeText(MainActivity.this, \"你点击了第\" + position + \"个位置\", Toast.LENGTH_SHORT).show(); } }) .build(); popMenu.show(); 这里由于篇幅原因，就暂时先不讲解实现原理了，如需要看源码去我的github上下载，下载地址为：高仿新浪弹出菜单","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"OC、Swift代码注释#pragma mark","slug":"OC、Swift代码注释-pragma-mark","date":"2016-02-16T08:10:49.000Z","updated":"2016-02-18T09:25:26.000Z","comments":true,"path":"2016/02/16/OC、Swift代码注释-pragma-mark/","link":"","permalink":"http://hanhailong.com/2016/02/16/OC、Swift代码注释-pragma-mark/","excerpt":"","text":"以前在我们写OC代码的时候，经常通过下面语法来为代码添加注释： #pragma mark – Initialization code here... #pragma mark – Table Managementmore code here... 但是，如果是Swift代码，这种写法就不好使了，下面给出Swift代码注释，Swift代码注释有三种: MARK // MARK: - Initialization code here... // MARK: - View Managementmore code here... TODO // TODO: - XXXXXXXX code here... FIXME // FIXME: - XXXXXXXX code here...","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://hanhailong.com/tags/IOS/"},{"name":"OC","slug":"OC","permalink":"http://hanhailong.com/tags/OC/"},{"name":"Swift","slug":"Swift","permalink":"http://hanhailong.com/tags/Swift/"}]},{"title":"Swift-？和！的区别","slug":"Swift-？和！的区别","date":"2016-01-28T02:43:42.000Z","updated":"2016-01-29T07:30:24.000Z","comments":true,"path":"2016/01/28/Swift-？和！的区别/","link":"","permalink":"http://hanhailong.com/2016/01/28/Swift-？和！的区别/","excerpt":"Swift 是一种新的编程语言，用于编写iOS，OS X 和 watchOS应用程序。Swift 结合了 C 和 Objective-C 的优点并且不受 C 兼容性的限制。Swift 采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift 是基于成熟而且倍受喜爱的 Cocoa 和 Cocoa Touch 框架，它的降临将重新定义软件开发。 今天我们的主角是可选类型？和！ Swift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值，也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化。如果在使用变量之前不进行初始化就会报错： var value : String //error: variable 'stringValue' used before being initialized let hash = value.hashValue","text":"Swift 是一种新的编程语言，用于编写iOS，OS X 和 watchOS应用程序。Swift 结合了 C 和 Objective-C 的优点并且不受 C 兼容性的限制。Swift 采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift 是基于成熟而且倍受喜爱的 Cocoa 和 Cocoa Touch 框架，它的降临将重新定义软件开发。 今天我们的主角是可选类型？和！ Swift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值，也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化。如果在使用变量之前不进行初始化就会报错： var value : String //error: variable 'stringValue' used before being initialized let hash = value.hashValue Optional简介 讲到这里，我们的主角就要正式登场了——Optional，Optional其实是一个enum枚举值，它有两个值：None和Some。Optional.None其实就是nil，Optional.Some就是非nil，它会通过Some(T)来进行Wrap包装原始值，这也是为啥使用Optional类型的时候要进行拆包unWrap（从enum中读取原始值）了。下面是Optional的定义： enum Optional&lt;T&gt; : LogicValue, Reflectable { case None case Some(T) init() init(_ some: T) /// Allow use in a Boolean context. func getLogicValue() -&gt; Bool /// Haskell's fmap, which was mis-named func map&lt;U&gt;(f: (T) -&gt; U) -&gt; U? func getMirror() -&gt; Mirror } 声明为Optional只需要在类型后面紧跟一个?或者！即可，如: var strValue: String? //?相当于下面这种写法的语法糖 var strValue: Optional&lt;String&gt; 上面的？这个Optional可选项类型声明，意思是我声明了一个Optional类型，而不是声明了一个String类型，它可能包含一个String值，也可能不包含，不包含默认值就为nil。我们可以通过if判断来区分是否为nil： if strValue { //do something with strValue } 那么我们怎么使用Optional可选类型的值呢？直接在后面加上一个？号即可。如果是nil值，也就是Optional.None，会跳过后面的操作不执行，如果有值，也就是Optional.Some，就会进行unWrap拆包操作，比如： //正确 let hashValue = strValue?.hashValue //错误 let hashValue = strValue.hashValue 有一种特殊情况，假如我们非常肯定strValue一定是非nil的，我们也可以采用强制拆包处理：使用！ let hashValue = strValue!.hashValue !就代表强制拆包，假如strValue是nil，你强制拆包也会报错 Optional可选类型？的使用场景 声明Optional变量 var strValue : String? 用在对Optional值操作中，用来判断是否能响应后面的操作 let hashValue = strValue?.hashValue 用于安全调用protocol的optional方法 @objc protocol Downloadable { @optional func download(toPath: String) -&gt; Bool; } @objc class Content: Downloadable { //download method not be implemented } var delegate: Downloadable = Downloadable() delegate.download?(\"some path\") 使用 as? 向下转型 if let dataSource = object as? UITableViewDataSource { let rowsInFirstSection = dataSource.tableView(tableView, numberOfRowsInSection: 0) } Optional可选类型！的使用场景 强制对可选类型Optional进行拆包 let hashValue = strValue!.hashValue 声明隐式拆包，一般用于类中的属性 var strValue : String!","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://hanhailong.com/tags/IOS/"},{"name":"Swift","slug":"Swift","permalink":"http://hanhailong.com/tags/Swift/"}]},{"title":"Android小知识总结","slug":"Android小知识总结","date":"2016-01-14T15:00:27.000Z","updated":"2016-10-25T05:44:24.000Z","comments":true,"path":"2016/01/14/Android小知识总结/","link":"","permalink":"http://hanhailong.com/2016/01/14/Android小知识总结/","excerpt":"onCreate中计算View的高度可以借助getViewTreeObserver().addOnGlobalLayoutListener()来获得宽度或者高度，示例代码如下： mWebView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { mWebView.getWidth(); mWebView.getHeight(); //防止调用多次 mWebView.getViewTreeObserver().removeOnGlobalLayoutListener(this); } }); PopupWindow计算高度PopupWindow在初始化创建好后，我想知道它的高度和宽度，可以这样计算： popupWindow.getContentView().measure(0, 0); popupWindow.getContentView().getMeasuredWidth(); popupWindow.getContentView().getMeasuredHeight();","text":"onCreate中计算View的高度可以借助getViewTreeObserver().addOnGlobalLayoutListener()来获得宽度或者高度，示例代码如下： mWebView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { mWebView.getWidth(); mWebView.getHeight(); //防止调用多次 mWebView.getViewTreeObserver().removeOnGlobalLayoutListener(this); } }); PopupWindow计算高度PopupWindow在初始化创建好后，我想知道它的高度和宽度，可以这样计算： popupWindow.getContentView().measure(0, 0); popupWindow.getContentView().getMeasuredWidth(); popupWindow.getContentView().getMeasuredHeight(); Theme.NoDisplay在Android中想进行一些无界面的处理又不适合使用service时，此时可以在项目的AndroidManifest.xml文件中相应的Activity标签中添加这样一行： android:theme=”@android:style/Theme.NoDisplay activity父级activity的重建当我们从其他App跳转到我们应用内部时，可能我们跳转到的不是应用的第一层级页面而是深层次的页面，这时候我们需要在关闭应用内部页面时，对高层的页面进行重建。 为activity指定父级activity &lt;application&gt; &lt;!-- 首层activity --&gt; &lt;activity android:name=\"com.example.Mainactivity\"/&gt; &lt;!-- 第二层级activity --&gt; &lt;activity android:name=\"com.example.SecondeActivity\" android:parentActivityName=\"com.example.Mainactivity\" &gt; &lt;!-- 父activity的meta-data，用来支持4.0以下版本 --&gt; &lt;meta-data android:name=\"android.support.PARENT_ACTIVITY\" android:value=\"com.example.Mainactivity\" /&gt; &lt;/activity&gt; &lt;/application&gt; 二级页面返回时，重建任务栈 @Override public void onBackPressed() { // 获得指向父级activity的intent，NavUtils在support v4 包中 Intent upIntent = NavUtils.getParentActivityIntent(this); // 判断是否需要重建任务栈 if (NavUtils.shouldUpRecreateTask(this, upIntent)) { // 这个activity不是这个app任务的一部分, 所以当向上导航时创建 // 用合成后退栈(synthesized back stack)创建一个新任务。 TaskStackBuilder.create(this) // 添加这个activity的所有父activity到后退栈中 .addNextIntentWithParentStack(upIntent) // 向上导航到最近的一个父activity .startActivities(); } else { // 这个activity是这个app任务的一部分, 所以 // 向上导航至逻辑父activity. NavUtils.navigateUpTo(this, upIntent); } super.onBackPressed(); } 兼容低版本修改图片的tintColordrawable.setColorFilter(Color.RED,PorterDuff.Mode.SRC_IN); 使用dumpsys命令查看系统信息dumpsys命令很强大，可以查看当前系统的信息，用的还比较多，dumpsys常用命令如下： dumpsys [options] meminfo 显示内存信息 cpuinfo 显示cpu信息 account 显示accounts信息 activity 显示所有的activities信息 window 显示键盘、窗口信息 wifi 显示wifi信息 例如：查看某个程序内部内存信息 adb shell dumpsys meminfo 包名 or pid 再或者查看当前打开app的页面信息，这个很有用 adb shell dumpsys window windows | grep -E 'mCurrentFocus' 结果类似如下： mCurrentFocus=Window{43469d60 u0 com.jikexueyuan.geekacademy.debug/com.jikexueyuan.geekacademy.ui.activity.ActivityHomeV3} Recyleview的LayoutManager设置成StaggeredGridLayoutManager后获取某个字view的spanIndex（也就是在第几列）private static class MyItemDecoration extends RecyclerView.ItemDecoration { @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) { super.getItemOffsets(outRect, view, parent, state); int index = ((StaggeredGridLayoutManager.LayoutParams) view.getLayoutParams()).getSpanIndex(); } } 如果获取当前手机为每个app分配的堆大小，也就是内存大小ActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE); int heapSize = manager.getMemoryClass(); 注意：这里获得heapSize是M为单位返回的 duplicate entry: android/support/annotation/ColorRes.class解决方案，只需要在app下的build.gradle加入以下配置就好了： configurations { all*.exclude group: 'com.android.support', module: 'support-v4' } 方便快捷实现Activity变暗，并带有动画/** * 调整窗口的透明度 * @param from&gt;=0&amp;&amp;from&lt;=1.0f * @param to&gt;=0&amp;&amp;to&lt;=1.0f * * */ private void dimBackground(final float from, final float to) { final Window window = getWindow(); ValueAnimator valueAnimator = ValueAnimator.ofFloat(from, to); valueAnimator.setDuration(500); valueAnimator.addUpdateListener(new AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { WindowManager.LayoutParams params = window.getAttributes(); params.alpha = (Float) animation.getAnimatedValue(); window.setAttributes(params); } }); valueAnimator.start(); } 然后这样调用 /** 窗口背景变暗*/ dimBackground(1.0f,0.5f); /** 窗口背景变亮*/ dimBackground(0.5f,1.0f); Release模式下借助Proguard清除掉Log类日志在Proguard配置文件中，确保没有添加 –dontoptimize选项，添加如下代码： -assumenosideeffects class android.util.Log { public static *** d(...); public static *** e(...); public static *** i(...); public static *** v(...); public static *** println(...); public static *** w(...); public static *** wtf(...); } 待续…","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"IOS开发小技巧","slug":"IOS开发小技巧","date":"2016-01-12T08:05:17.000Z","updated":"2016-01-24T15:05:44.000Z","comments":true,"path":"2016/01/12/IOS开发小技巧/","link":"","permalink":"http://hanhailong.com/2016/01/12/IOS开发小技巧/","excerpt":"","text":"IOS配置某个圆角大小 iOS开发中各种圆角也随处可见,最简单给控件添加圆角的方式就是给视图的layer设置corner属性了: self.view.layer.cornerRadius = 5.f; self.view.layer.masksToBounds = YES; 这种方式无法配置圆角数量(只能添加view的四个角全为圆角),无法配置某个圆角大小. 这个问题我们可以用UIBezierPath来完美解决，示例代码如下： UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.view.bounds byRoundingCorners:UIRectCornerTopLeft | UIRectCornerBottomLeft cornerRadii:CGSizeMake(20, 0)]; CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init]; maskLayer.frame = self.view.bounds; maskLayer.path = maskPath.CGPath; self.view.layer.mask = maskLayer; self.view.layer.cornerRadius = 5.f; self.view.layer.masksToBounds = YES; 想要配置某个角为圆角的话,只需要指定对应的UIRectCorner即可，UIRectCorner有五个值： UIRectCornerAllCorners 全角 UIRectCornerTopLeft 左上角 UIRectCornerTopRight 右上角 UIRectCornerBottomLeft 左下角 UIRectCornerBottomRight 右下角 UITableView分割线顶到头 我们在使用tableview时会发现分割线的左边会短一些，通常可以使用setSeparatorInset:UIEdgeInsetsZero 来解决。但是升级到XCode6之后，在iOS8里发现没有效果。下面给出解决办法： 第一步 if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) { [self.tableView setSeparatorInset:UIEdgeInsetsZero]; } if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) { [self.tableView setLayoutMargins:UIEdgeInsetsZero]; } 第二步 - (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath{ if ([cell respondsToSelector:@selector(setSeparatorInset:)]) { [cell setSeparatorInset:UIEdgeInsetsZero]; } if ([cell respondsToSelector:@selector(setLayoutMargins:)]) { [cell setLayoutMargins:UIEdgeInsetsZero]; } } 持续更新中…","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://hanhailong.com/tags/IOS/"}]},{"title":"Java小知识总结","slug":"Java小知识总结","date":"2016-01-11T09:41:10.000Z","updated":"2016-01-11T10:07:01.000Z","comments":true,"path":"2016/01/11/Java小知识总结/","link":"","permalink":"http://hanhailong.com/2016/01/11/Java小知识总结/","excerpt":"","text":"编译时、运行时 编译时顾名思义就是正在编译的时候.那啥叫编译呢?就是编译器帮你把源代码翻译成机器能识别的代码。例如：Java编译器把写的java文件编译成jvm能识别的class字节码文件。 而在编译的时候会涉及到一些比如常量折叠等技术，这个以后细讲！ 运行时就是代码跑起来了.被装载到内存中去了.(你的代码保存在磁盘上没装入内存之前是个死家伙.只有跑到内存中才变成活的).而运行时类型检查就与前面讲的编译时类型检查(或者静态类型检查)不一样.不是简单的扫描代码.而是在内存中做些操作,做些判断. 下面的代码片段中，行A和行B所标识的代码有什么区别呢？ public class ConstantFolding { static final int number1 = 5; static final int number2 = 6; static int number3 = 5; static int number4= 6; public static void main(String[ ] args) { int product1 = number1 * number2; //line A int product2 = number3 * number4; //line B } } 在行A的代码中，product的值是在编译期计算的，行B则是在运行时计算的。如果你使用Java反编译器（例如，jd-gui）来反编译ConstantFolding.class文件的话，那么你就会从下面的结果里得到答案。 public class ConstantFolding { static final int number1 = 5; static final int number2 = 6; static int number3 = 5; static int number4 = 6; public static void main(String[ ] args) { int product1 = 30; int product2 = number3 * number4; } } 常量折叠是一种Java编译器使用的优化技术。由于final变量的值不会改变，因此就可以对它们优化。Java反编译器和javap命令都是查看编译后的代码（例如，字节码）的利器。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://hanhailong.com/tags/Java/"}]},{"title":"Android进阶之ProGuard代码混淆","slug":"Android进阶之ProGuard代码混淆","date":"2015-12-28T13:35:41.000Z","updated":"2016-01-29T03:47:30.000Z","comments":true,"path":"2015/12/28/Android进阶之ProGuard代码混淆/","link":"","permalink":"http://hanhailong.com/2015/12/28/Android进阶之ProGuard代码混淆/","excerpt":"简介 Proguard工具通过移除无用的代码以及使用语义隐晦的名称来重命名类、字段和方法，从而达到压缩、优化和混淆代码的目的。最终您将获得一个较小的 .apk 文件，此文件更难于进行反向工程。由于 ProGuard 会使应用更难于进行反向工程，因此当应用使用对安全性要求极高的功能时（例如，当您向应用授予许可时），您必须使用此工具。 ProGuard 已集成到 Android 构建系统，所以您无需手动调用此工具。只有当您在发布模式下构建应用时，ProGuard 才会运行，因此当您在调试模式下构建应用时，就无需处理混淆后的代码。是否运行 ProGuard 完全由您决定，但我们强烈建议您运行该工具。 本文介绍如何启用和配置 ProGuard，以及如何使用 retrace 工具解码混淆后的堆栈跟踪信息。 除了基本的Proguard混淆外，还有一些其他的混淆方式和工具。例如：混淆资源 美团资源混淆 微信资源混淆","text":"简介 Proguard工具通过移除无用的代码以及使用语义隐晦的名称来重命名类、字段和方法，从而达到压缩、优化和混淆代码的目的。最终您将获得一个较小的 .apk 文件，此文件更难于进行反向工程。由于 ProGuard 会使应用更难于进行反向工程，因此当应用使用对安全性要求极高的功能时（例如，当您向应用授予许可时），您必须使用此工具。 ProGuard 已集成到 Android 构建系统，所以您无需手动调用此工具。只有当您在发布模式下构建应用时，ProGuard 才会运行，因此当您在调试模式下构建应用时，就无需处理混淆后的代码。是否运行 ProGuard 完全由您决定，但我们强烈建议您运行该工具。 本文介绍如何启用和配置 ProGuard，以及如何使用 retrace 工具解码混淆后的堆栈跟踪信息。 除了基本的Proguard混淆外，还有一些其他的混淆方式和工具。例如：混淆资源 美团资源混淆 微信资源混淆 开启Proguard Ant、Eclipse构建 &lt;project_root&gt;/project.properties 文件中设置 proguard.config 属性。该路径可以是绝对路径，也可以是项目根目录的相对路径。 proguard.config=proguard.cfg AndroidStudio-Gradle构建 android { buildTypes { release { minifyEnabled true proguardFile getDefaultProguardFile('proguard-android.txt') } } productFlavors { flavor1 { } flavor2 { proguardFile 'some-other-rules.txt' } } } 提示: getDefaultProguardFile()可以返回这两个文件的绝对路径。proguardFile 可以配置多个混淆文件 配置Proguard 在某些情况下，proguard.cfg或proguard-android.txt 文件中的默认配置足以满足您的需求。不过，在很多情况下，ProGuard 很难做出正确分析，因此可能会移除它认为无用而实际上您的应用却需要的代码。部分示例如下： 一个只在 AndroidManifest.xml 文件中引用的类 一个通过 JNI 调用的方法 动态引用的字段和方法 默认的 proguard.cfg或proguard-android.txt 文件旨在涵盖一般的使用情形，但您可能会遇到异常情况，例如 ClassNotFoundException（此异常情况会在 ProGuard 删除您的应用调用的整个类时发生）。 您可以通过在 proguard.cfg或proguard-android.txt 文件中添加一个 -keep 行，来修复因 ProGuard 在删除代码而造成的错误。例如： -keep public class &lt;MyClass&gt; 在使用 -keep 选项时，您既有许多选择也有不少需要注意的方面，因此我们强烈建议您阅读 ProGuard 手册，详细了解如何自定义您的配置文件。该手册中的“Keep 选项概述”和“示例”部分尤其有用；问题排查部分则概述了在 ProGuard 删除代码后您可能会遇到的其他常见问题。 下面给出一个常用的默认配置命令： -include {fileame} 从给定的文件中读取配置参数 -libraryjars libs/xxxx.jar 指定库jar包 -keep public class * extends android.app.Activity 保留类不被删除 -keep class className$InnerName{ 保留内部类的属性和方法 public &lt;fields&gt;; public &lt;methods&gt;; } -keepclassmembers class * implements java.io.Serializable { 保留类的成员 static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); } -dontshrink 不压缩输入的类文件 -dontoptimize 不优化输入的类文件 -keepattributes *Annotation* 保留Annotation -dontwarn xxx.xxx.** 不检查引用 Proguard产生的文件 当混淆后的代码输出堆栈跟踪信息时，方法名称会被混淆，即便仍能进行调试，难度也会很大。幸运的是，ProGuard 在每次运行时都会输出以下文件： dump.txt 描述 .apk 文件中所有类文件的内部结构 mapping.txt 列出原始与混淆后的类、方法和字段名称之间的对应关系。 Windows 上的 retrace.bat 脚本以及 Linux 或 Mac OS X 上的 retrace.sh 脚本可以将混淆后的堆栈跟踪信息转换成可读文件，此文件位于 /tools/proguard/ 目录中。执行 retrace 工具的语法如下： retrace.bat|retrace.sh [-verbose] mapping.txt [&lt;stacktrace_file&gt;] 例如： retrace.bat -verbose mapping.txt obfuscated_trace.txt 建议发布时应保留mapping.txt文件。 seeds.txt 列出未混淆的类和成员 usage.txt 列出从 .apk 删除的代码 @Keep注解来防止混淆 写到这，你是不是发现了一个问题：非常的麻烦、一点都不灵活，而且通过-keep的方式防止混淆那种有共同特征的类、属性或方式非常有用，但是没有共同特征的呢？ 这里介绍一种比较新颖、轻快的方法，通过@Keep注解来灵活的防止混淆，用起来非常的灵活、快捷、方便，怎样用呢？像普通的注解一样，如下： //防止混淆类 @Keep public class Person {} //防止混淆变量 @Keep public String name; //防止混淆方法 @Keep public int getAge(){} 但是当你加上上面的注解后，发现@Keep并没有起作用，该混淆的还是混淆了，这是为什么呢？ 原因目前Gradle还不支持@Keep混淆，Google只是定义好了一个这种注解，并没有实现它，也就是说@Keep目前只是一个空壳。这里我们来手动开启它，让它支持防止混淆，在你的proguard.cfg或proguard-android.txt配置文件里面加入以下代码： #手动启用support keep注解 -dontskipnonpubliclibraryclassmembers -printconfiguration -keep,allowobfuscation @interface android.support.annotation.Keep -keep @android.support.annotation.Keep class * -keepclassmembers class * { @android.support.annotation.Keep *; } Proguard相关语法 后面的文件名，类名，或者包名等可以使用占位符代替“?”表示一个字符 可以匹配多个字符，但是如果是一个类，不会匹配其前面的包名“*”可以匹配多个字符，会匹配前面的包名。 输入输出选项 -include filename从给定的文件中读取配置参数 -injars class_path输入(即使用的) jar文件路径 -outjars class_path输出 jar 路径 -libraryjars class_path指定的jar将不被混淆 -skipnonpubliclibraryclasses跳过(不混淆) jars中的 非public classes -dontskipnonpubliclibraryclasses不跳过(混淆) jars中的 非public classes 默认选项 -dontskipnonpubliclibraryclassmembers不跳过 jars中的非public classes的members -keepdirectories [directory_filter]指定目录 keep 在 out jars中 保持不变的选项（混淆不进行处理的内容） -keep {Modifier} {class_specification}保护指定的类文件和类的成员 -keepclassmembers {modifier} {class_specification}保护指定类的成员，如果此类受到保护他们会保护的更好 -keepclasseswithmembers {class_specification}保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。 -keepnames {class_specification}保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除） -keepclassmembernames {class_specification}保护指定的类的成员的名称（如果他们不会压缩步骤中删除） -keepclasseswithmembernames {class_specification}保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后） -printseeds {filename}列出类和类的成员-keep选项的清单，标准输出到给定的文件 压缩选项 -dontshrink不启用 shrink。shrink操作默认启用，主要的作用是将一些无效代码给移除，即没有被显示调用的代码。 -printusage [filename]打印被移除的代码，在标准输出 -whyareyoukeeping class_specification打印 在shrink过程中 为什么有些代码被 keep 优化选项 -dontoptimize该选项表示 不启用。optimization，默认启用当不使用该选项时，下面的才有效 -optimizations optimization_filter根据optimization_filter指定要优化的文件 -optimizationpasses n优化数量 n -assumenosideeffects class_specification优化时允许访问并修改类和类的成员的 访问修饰符，可能作用域会变大。 -mergeinterfacesaggressively合并接口，即使它们的实现类未实现合并后接口的所有方法。 混淆选项 -dontobfuscate不混淆 -printmapping [filename]打印 映射旧名到新名 -applymapping filename打印相关 -obfuscationdictionary filename指定外部模糊字典 -classobfuscationdictionary filename指定class模糊字典 -packageobfuscationdictionary filename指定package模糊字典 -overloadaggressively过度加载，多个属性和方法使用相同的名字，只是参数和返回类型不同 可能各种异常 -useuniqueclassmembernames类和类成员都使用唯一的名字 -dontusemixedcaseclassnames不使用大小写混合类名 -keeppackagenames [package_filter]保持packagename 不混淆 -flattenpackagehierarchy [package_name]指定重新打包,所有包重命名,这个选项会进一步模糊包名 好东西将包里的类混淆成n个再重新打包到一个个的package中，注：混淆是有用，但是我用的时候安装会崩溃，不知道为什么？ -repackageclasses [package_name]将包里的类混淆成n个再重新打包到一个统一的package中 会覆盖flattenpackagehierarchy选项 -keepattributes [attribute_filter]混淆时可能被移除下面这些东西，如果想保留，需要用该选项。“Annotation、Exceptions, Signature, Deprecated, SourceFile, SourceDir, LineNumberTable” 预校验选项 -dontpreverify不预校验，默认选项 通用选项 -verbose打印日志 -dontnote [class_filter]不打印某些错误 -dontwarn [class_filter]不打印警告信息 -ignorewarnings忽略警告，继续执行 -printconfiguration [filename]打印配置文件 -dump [filename]指定打印类结构 demo示例 ##--- For:android默认 --- -optimizationpasses 5 # 指定代码的压缩级别 -allowaccessmodification #优化时允许访问并修改有修饰符的类和类的成员 -dontusemixedcaseclassnames # 是否使用大小写混合 -dontskipnonpubliclibraryclasses # 是否混淆第三方jar -dontpreverify # 混淆时是否做预校验 -verbose # 混淆时是否记录日志 -ignorewarnings # 忽略警告，避免打包时某些警告出现 -optimizations !code/simplification/arithmetic,!code/simplification/cast,!field/*,!class/merging/* # 混淆时所采用的算法 -keepattributes *Annotation* -keep public class com.google.vending.licensing.ILicensingService -keep public class com.android.vending.licensing.ILicensingService -keepclasseswithmembernames class * { # 保持 native 方法不被混淆 native &lt;methods&gt;; } -keepclassmembers public class * extends android.view.View { void set*(***); *** get*(); } -keepclassmembers class * extends android.app.Activity { public void *(android.view.View); } -keepclassmembers enum * { # 保持枚举 enum 类不被混淆 public static **[] values(); public static ** valueOf(java.lang.String); } -keep class * implements android.os.Parcelable { # 保持 Parcelable 不被混淆 public static final android.os.Parcelable$Creator *; } -keepclassmembers class **.R$* { #不混淆R文件 public static &lt;fields&gt;; } -dontwarn android.support.** ##--- End android默认 --- ##--- For:不能被混淆的 --- -keep public class * extends android.app.Activity -keep public class * extends android.app.Fragment -keep public class * extends android.app.Application -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider -keep public class * extends android.app.backup.BackupAgentHelper -keep public class * extends android.preference.Preference ##--- For:保持自定义控件类不被混淆 --- -keepclasseswithmembers class * { public &lt;init&gt;(android.content.Context, android.util.AttributeSet); } -keepclasseswithmembers class * { public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int); } ##--- For:android-support-v4 --- -dontwarn android.support.v4.** -keep class android.support.v4.** { *; } -keep interface android.support.v4.app.** { *; } -keep class * extends android.support.v4.** { *; } -keep public class * extends android.support.v4.** -keep public class * extends android.support.v4.widget -keep class * extends android.support.v4.app.** {*;} -keep class * extends android.support.v4.view.** {*;} ##--- For:Serializable --- -keep class * implements java.io.Serializable {*;} -keepnames class * implements java.io.Serializable -keepclassmembers class * implements java.io.Serializable {*;} ##--- For:Gson --- -keepattributes *Annotation* -keep class sun.misc.Unsafe { *; } -keep class com.idea.fifaalarmclock.entity.*** -keep class com.google.gson.stream.** { *; } ##--- For:Remove log --- -assumenosideeffects class android.util.Log { public static boolean isLoggable(java.lang.String, int); public static int v(...); public static int i(...); public static int w(...); public static int d(...); public static int e(...); } ##--- For:attributes(未启用) --- #-keepattributes SourceFile,LineNumberTable # 保持反编译工具能看到代码的行数，以及release包安装后出现异常信息可以知道在哪行代码出现异常，建议不启用 -keepattributes *Annotation* #使用注解 -keepattributes Signature #过滤泛型 出现类型转换错误时，启用这个 #-keepattributes *Exceptions*,EnclosingMethod #没试过，未知效果","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"Android性能优化之如何避免Overdraw","slug":"Android性能优化之如何避免Overdraw","date":"2015-12-27T12:14:37.000Z","updated":"2015-12-27T13:04:19.000Z","comments":true,"path":"2015/12/27/Android性能优化之如何避免Overdraw/","link":"","permalink":"http://hanhailong.com/2015/12/27/Android性能优化之如何避免Overdraw/","excerpt":"什么是Overdraw？ Overdraw就是过度绘制，是指在一帧的时间内（16.67ms）像素被绘制了多次，理论上一个像素每次只绘制一次是最优的，但是由于重叠的布局导致一些像素会被多次绘制，而每次绘制都会对应到CPU的一组绘图命令和GPU的一些操作，当这个操作耗时超过16.67ms时，就会出现掉帧现象，也就是我们所说的卡顿，所以对重叠不可见元素的重复绘制会产生额外的开销，需要尽量减少Overdraw的发生。 Android提供了测量Overdraw的选项，在开发者选项－调试GPU过度绘制（Show GPU Overdraw），打开选项就可以看到当前页面Overdraw的状态，就可以观察屏幕的绘制状态。该工具会使用三种不同的颜色绘制屏幕，来指示overdraw发生在哪里以及程度如何，其中： 没有颜色： 意味着没有overdraw。像素只画了一次。 蓝色： 意味着overdraw 1倍。像素绘制了两次。大片的蓝色还是可以接受的（若整个窗口是蓝色的，可以摆脱一层）。 绿色： 意味着overdraw 2倍。像素绘制了三次。中等大小的绿色区域是可以接受的但你应该尝试优化、减少它们。 浅红： 意味着overdraw 3倍。像素绘制了四次，小范围可以接受。 暗红： 意味着overdraw 4倍。像素绘制了五次或者更多。这是错误的，要修复它们。 那么我们怎么来消灭overdraw呢？总的原则就是：尽量避免重叠不可见元素的绘制，基于这个原则，我们大概可以想出以下几招：","text":"什么是Overdraw？ Overdraw就是过度绘制，是指在一帧的时间内（16.67ms）像素被绘制了多次，理论上一个像素每次只绘制一次是最优的，但是由于重叠的布局导致一些像素会被多次绘制，而每次绘制都会对应到CPU的一组绘图命令和GPU的一些操作，当这个操作耗时超过16.67ms时，就会出现掉帧现象，也就是我们所说的卡顿，所以对重叠不可见元素的重复绘制会产生额外的开销，需要尽量减少Overdraw的发生。 Android提供了测量Overdraw的选项，在开发者选项－调试GPU过度绘制（Show GPU Overdraw），打开选项就可以看到当前页面Overdraw的状态，就可以观察屏幕的绘制状态。该工具会使用三种不同的颜色绘制屏幕，来指示overdraw发生在哪里以及程度如何，其中： 没有颜色： 意味着没有overdraw。像素只画了一次。 蓝色： 意味着overdraw 1倍。像素绘制了两次。大片的蓝色还是可以接受的（若整个窗口是蓝色的，可以摆脱一层）。 绿色： 意味着overdraw 2倍。像素绘制了三次。中等大小的绿色区域是可以接受的但你应该尝试优化、减少它们。 浅红： 意味着overdraw 3倍。像素绘制了四次，小范围可以接受。 暗红： 意味着overdraw 4倍。像素绘制了五次或者更多。这是错误的，要修复它们。 那么我们怎么来消灭overdraw呢？总的原则就是：尽量避免重叠不可见元素的绘制，基于这个原则，我们大概可以想出以下几招： 第一招：合理选择控件容器 既然overdraw是因为重复绘制了同一片区域的像素点，那我们首先想到的是解决布局问题。Android提供的Layout控件主要包括LinearLayout、TableLayout、FrameLayout、RelativeLayout。俗话说条条大路通罗马，同一个界面我们可以使用不同的容器控件来表达，但是各个容器控件描述界面的复杂度是不一样的。一般来说LinearLayout最易，RelativeLayout较复杂。但是尺有所短，寸有所长，LinearLayout只能用来描述一个方向上连续排列的控件，而RelativeLayout几乎可以用于描述任意复杂度的界面。但是我又要说但是了，表达能力越强的容器控件，性能往往略低一些，因为系统需要将更多的时间花在计算子控件的位置上。综上所述：LinearLayout易用，效率高，表达能力有限。RelativeLayout复杂，表达能力强，效率稍逊。 那么对于同一界面而言，作为开发者考虑是使用尽量少的、表达能力强的RelativeLayout作为容器，还是选择多个、表达能力稍弱的LinearLayout来展示。从减少overdraw的角度来看，LinearLayout会增加控件数的层级，自然是RelativeLayout更优，但是当某一界面在使用LinearLayout并不会比RelativeLayout带来更多的控件数和控件层级时，LinearLayout则是首选。所以在表达界面的时候，作为一个有前瞻性的开发者要根据实际情况来选择合适容器控件，在保证性能的同时，尽量避免overdraw。 第二招：去掉window的默认背景 当我们使用了Android自带的一些主题时，window会被默认添加一个纯色的背景，这个背景是被DecorView持有的。当我们的自定义布局时又添加了一张背景图或者设置背景色，那么DecorView的background此时对我们来说是无用的，但是它会产生一次Overdraw，带来绘制性能损耗。 去掉window的背景可以在onCreate()中setContentView()之后调用 getWindow().setBackgroundDrawable(null); 或者在theme中添加 android:windowbackground=\"null\"； 第三招：去掉其他不必要的背景 有时候为了方便会先给Layout设置一个整体的背景，再给子View设置背景，这里也会造成重叠，如果子View宽度mach_parent，可以看到完全覆盖了Layout的一部分，这里就可以通过分别设置背景来减少重绘。再比如如果采用的是selector的背景，将normal状态的color设置为“@android:color/transparent”,也同样可以解决问题。这里只简单举两个例子，我们在开发过程中的一些习惯性思维定式会带来不经意的Overdraw，所以开发过程中我们为某个View或者ViewGroup设置背景的时候，先思考下是否真的有必要，或者思考下这个背景能不能分段设置在子View上，而不是图方便直接设置在根View上。 第四招：ClipRect &amp; QuickReject 为了解决Overdraw的问题，Android系统会通过避免绘制那些完全不可见的组件来尽量减少消耗。但是不幸的是，对于那些过于复杂的自定义的View(通常重写了onDraw方法)，Android系统无法检测在onDraw里面具体会执行什么操作，系统无法监控并自动优化，也就无法避免Overdraw了。但是我们可以通过canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。除了clipRect方法之外，我们还可以使用canvas.quickreject()来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。 第五招：ViewStub ViewStub是个什么东西？一句话总结：高效占位符。我们经常会遇到这样的情况，运行时动态根据条件来决定显示哪个View或布局。常用的做法是把View都写在上面，先把它们的可见性都设为View.GONE，然后在代码中动态的更改它的可见性。这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点就是，耗费资源。虽然把View的初始可见View.GONE但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。推荐的做法是使用android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。 &lt;ViewStub android:id=\"@+id/stub_view\" android:inflatedId=\"@+id/panel_stub\" android:layout=\"@layout/progress_overlay\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom\" /&gt; 当你想加载布局时，可以使用下面其中一种方法： ((ViewStub) findViewById(R.id.stub_view)).setVisibility(View.VISIBLE); View importPanel = ((ViewStub) findViewById(R.id.stub_view)).inflate() 第六招：Merge Merge标签有什么用呢？简单粗暴点回答：干掉一个view层级。 Merge的作用很明显，但是也有一些使用条件的限制。有两种情况下我们可以使用Merge标签来做容器控件。第一种子视图不需要指定任何针对父视图的布局属性，就是说父容器仅仅是个容器，子视图只需要直接添加到父视图上用于显示就行。另外一种是假如需要在LinearLayout里面嵌入一个布局（或者视图），而恰恰这个布局（或者视图）的根节点也是LinearLayout，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度。而这个时候如果我们使用merge根标签就可以避免那样的问题。另外Merge只能作为XML布局的根标签使用，当Inflate以开头的布局文件时，必须指定一个父ViewGroup，并且必须设定attachToRoot为true。举个简单的例子吧： &lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"merge标签使用\" /&gt; &lt;/RelativeLayout&gt; 把上面这个XML加载到页面中，布局层级是RelativeLayout-TextView。但是采用下面的方式，把RelativeLayout提换成merge，RelativeLayout这一层级就被干掉了。 &lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"merge标签使用\" /&gt; &lt;/merge&gt; 第七招：善用draw9patch 给ImageView加一个边框，你肯定遇到过这种需求，通常在ImageView后面设置一张背景图，露出边框便完美解决问题，此时这个ImageView，设置了两层drawable，底下一层仅仅是为了作为图片的边框而已。但是两层drawable的重叠区域去绘制了两次，导致overdraw。优化方案： 将背景drawable制作成draw9patch，并且将和前景重叠的部分设置为透明。由于Android的2D渲染器会优化draw9patch中的透明区域，从而优化了这次overdraw。 但是背景图片必须制作成draw9patch才行，因为Android 2D渲染器只对draw9patch有这个优化，否则，一张普通的Png，就算你把中间的部分设置成透明，也不会减少这次overdraw。 第八招：慎用Alpha 假如对一个View做Alpha转化，需要先将View绘制出来，然后做Alpha转化，最后将转换后的效果绘制在界面上。通俗点说，做Alpha转化就需要对当前View绘制两遍，可想而知，绘制效率会大打折扣，耗时会翻倍，所以Alpha还是慎用。 如果一定做Alpha转化的话，可以采用缓存的方式。 view.setLayerType(LAYER_TYPE_HARDWARE); doSmoeThing(); view.setLayerType(LAYER_TYPE_NONE); 通过setLayerType方式可以将当前界面缓存在GPU中，这样不需要每次绘制原始界面，但是GPU内存是相当宝贵的，所以用完要马上释放掉。 第九招：避免“OverDesign” overdraw会给APP带来不好的体验，overdraw产生的原因无外乎：复杂的Layout层级，重叠的View，重叠的背景这几种。开发人员无节制的View堆砌，究其根本无非是产品无节制的需求设计。有道是“由俭入奢易，由奢入俭难”，很多APP披着过度设计的华丽外衣，却忘了简单易用才是王道的本质，纷繁复杂的设计并不会给用户带来好的体验，反而会让用户有压迫感，产品本身也有可能因此变得卡顿。当然，一切抛开业务谈优化都是空中楼阁，这就需要产品设计也要有一个权衡，在复杂的业务逻辑与简单易用的界面展现中做一个平衡，而不是一味的OverDesign。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"Android 性能优化之--使用线程池处理异步任务","slug":"Android-性能优化之-使用线程池处理异步任务","date":"2015-12-27T08:41:23.000Z","updated":"2015-12-27T12:10:00.000Z","comments":true,"path":"2015/12/27/Android-性能优化之-使用线程池处理异步任务/","link":"","permalink":"http://hanhailong.com/2015/12/27/Android-性能优化之-使用线程池处理异步任务/","excerpt":"说到线程，我想大家都不陌生，因为在开发时候或多或少都会用到线程，而通常创建线程有两种方式： 继承自Thread类 实现Runnable接口 虽说这两种方式都可以创建出一个线程，不过它们之间还是有一点区别的，主要区别在于在多线程访问同一资源的情况下，用Runnable接口创建的线程可以处理同一资源，而用Thread类创建的线程则各自独立处理，各自拥有自己的资源。 所以，在Java中大多数多线程程序都是通过实现Runnable来完成的，而对于Android来说也不例外，当涉及到需要开启线程去完成某件事时，我们都会这样写： new Thread(new Runnable() { @Override public void run() { //do sth . } }).start(); 这段代码创建了一个线程并执行，它在任务结束后GC会自动回收该线程，一切看起来如此美妙，是的，它在线程并发不多的程序中确实不错，而假如这个程序有很多地方需要开启大量线程来处理任务，那么如果还是用上述的方式去创建线程处理的话，那么将导致系统的性能表现的非常糟糕，更别说在内存有限的移动设备上，主要的影响如下： 线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失 大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM 大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿 而针对上述所描述的问题，解决的办法归根到底就是：重用已有的线程，从而减少线程的创建。所以这就涉及到线程池（ExecutorService）的概念了，线程池的基本作用就是进行线程的复用，下面将具体介绍线程池的使用","text":"说到线程，我想大家都不陌生，因为在开发时候或多或少都会用到线程，而通常创建线程有两种方式： 继承自Thread类 实现Runnable接口 虽说这两种方式都可以创建出一个线程，不过它们之间还是有一点区别的，主要区别在于在多线程访问同一资源的情况下，用Runnable接口创建的线程可以处理同一资源，而用Thread类创建的线程则各自独立处理，各自拥有自己的资源。 所以，在Java中大多数多线程程序都是通过实现Runnable来完成的，而对于Android来说也不例外，当涉及到需要开启线程去完成某件事时，我们都会这样写： new Thread(new Runnable() { @Override public void run() { //do sth . } }).start(); 这段代码创建了一个线程并执行，它在任务结束后GC会自动回收该线程，一切看起来如此美妙，是的，它在线程并发不多的程序中确实不错，而假如这个程序有很多地方需要开启大量线程来处理任务，那么如果还是用上述的方式去创建线程处理的话，那么将导致系统的性能表现的非常糟糕，更别说在内存有限的移动设备上，主要的影响如下： 线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失 大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM 大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿 而针对上述所描述的问题，解决的办法归根到底就是：重用已有的线程，从而减少线程的创建。所以这就涉及到线程池（ExecutorService）的概念了，线程池的基本作用就是进行线程的复用，下面将具体介绍线程池的使用 ExecutorService通过上述分析，我们知道了通过new Thread().start()方式创建线程去处理任务的弊端，而为了解决这些问题，Java为我们提供了ExecutorService线程池来优化和管理线程的使用使用线程池管理线程的优点1. 线程的创建和销毁由线程池维护，一个线程在完成任务后并不会立即销毁，而是由后续的任务复用这个线程，从而减少线程的创建和销毁，节约系统的开销2. 线程池旨在线程的复用，这就可以节约我们用以往的方式创建线程和销毁所消耗的时间，减少线程频繁调度的开销，从而节约系统资源，提高系统吞吐量3. 在执行大量异步任务时提高了性能4. Java内置的一套ExecutorService线程池相关的api，可以更方便的控制线程的最大并发数、线程的定时任务、单线程的顺序执行等ExecutorService简介通常来说我们说到线程池第一时间想到的就是它：ExecutorService，它是一个接口，其实如果要从真正意义上来说，它可以叫做线程池的服务，因为它提供了众多接口api来控制线程池中的线程，而真正意义上的线程池就是：ThreadPoolExecutor，它实现了ExecutorService接口，并封装了一系列的api使得它具有线程池的特性，其中包括工作队列、核心线程数、最大线程数等。线程池：ThreadPoolExecutor既然线程池就是ThreadPoolExecutor，所以我们要创建一个线程池只需要new ThreadPoolExecutor(…);就可以创建一个线程池，而如果这样创建线程池的话，我们需要配置一堆东西，非常麻烦，我们可以看一下它的构造方法就知道了： public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {…}所以，官方也不推荐使用这种方法来创建线程池，而是推荐使用Executors的工厂方法来创建线程池，Executors类是官方提供的一个工厂类，它里面封装好了众多功能不一样的线程池，从而使得我们创建线程池非常的简便，主要提供了如下五种功能不一样的线程池：1. newFixedThreadPool() ： 作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。 栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按FIFO方式处理任务队列中的任务。2. newCachedThreadPool() ： 作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。 栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。3. newSingleThreadExecutor() ： 作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。4. newScheduledThreadPool() ： 作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。5. newSingleThreadScheduledExecutor() ： 作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为1，而上面的可以指定线程池的大小。好了，写了一堆来介绍这五种线程池的作用，接下来就是获取这五种线程池，通过Executors的工厂方法来获取： ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5); ExecutorService singleThreadPool = Executors.newSingleThreadExecutor(); ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor();我们可以看到通过Executors的工厂方法来创建线程池极其简便，其实它的内部还是通过new ThreadPoolExecutor(…)的方式创建线程池的，我们看一下这些工厂方法的内部实现： public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()); } public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue())); } public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue()); }我们可以清楚的看到这些方法的内部实现都是通过创建一个ThreadPoolExecutor对象来创建的，正所谓万变不离其宗，所以我们要了解线程池还是得了解ThreadPoolExecutor这个线程池类，其中由于和定时任务相关的线程池比较特殊（newScheduledThreadPool()、newSingleThreadScheduledExecutor()），它们创建的线程池内部实现是由ScheduledThreadPoolExecutor这个类实现的，而ScheduledThreadPoolExecutor是继承于ThreadPoolExecutor扩展而成的，所以本质还是一样的，只不过多封装了一些定时任务相关的api，所以我们主要就是要了解ThreadPoolExecutor，从构造方法开始： public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {//…}我们可以看到它构造方法的参数比较多，有七个，下面一一来说明这些参数的作用： corePoolSize：线程池中的核心线程数量 maximumPoolSize: 线程池中的最大线程数量 keepAliveTime: 这个就是上面说到的“保持活动时间“，上面只是大概说明了一下它的作用，不过它起作用必须在一个前提下，就是当线程池中的线程数量超过了corePoolSize时，它表示多余的空闲线程的存活时间，即：多余的空闲线程在超过keepAliveTime时间内没有任务的话则被销毁。而这个主要应用在缓存线程池中 unit：它是一个枚举类型，表示keepAliveTime的单位，常用的如：TimeUnit.SECONDS（秒）、TimeUnit.MILLISECONDS（毫秒） workQueue: 任务队列，主要用来存储已经提交但未被执行的任务，不同的线程池采用的排队策略不一样，稍后再讲 threadFactory:线程工厂，用来创建线程池中的线程，通常用默认的即可 handler: 通常叫做拒绝策略，1、在线程池已经关闭的情况下 2、任务太多导致最大线程数和任务队列已经饱和，无法再接收新的任务 。在上面两种情况下，只要满足其中一种时，在使用execute()来提交新的任务时将会拒绝，而默认的拒绝策略是抛一个RejectedExecutionException异常上面的参数理解起来都比较简单，不过workQueue这个任务队列却要再次说明一下，它是一个BlockingQueue对象，而泛型则限定它是用来存放Runnable对象的，刚刚上面讲了，不同的线程池它的任务队列实现肯定是不一样的，所以，保证不同线程池有着不同的功能的核心就是这个workQueue的实现了，细心的会发现在刚刚的用来创建线程池的工厂方法中，针对不同的线程池传入的workQueue也不一样，下面我总结一下这五种线程池分别用的是什么 BlockingQueue*:1. newFixedThreadPool()—&gt;LinkedBlockingQueue2. newSingleThreadExecutor()—&gt;LinkedBlockingQueue3. newCachedThreadPool()—&gt;SynchronousQueue4. newScheduledThreadPool()—&gt;DelayedWorkQueue5. newSingleThreadScheduledExecutor()—&gt;DelayedWorkQueue这些队列分别表示： LinkedBlockingQueue：无界的队列 SynchronousQueue：直接提交的队列 DelayedWorkQueue：等待队列当然实现了BlockingQueue接口的队列还有：ArrayBlockingQueue（有界的队列）、PriorityBlockingQueue（优先级队列）。这些队列的详细作用就不多介绍了。线程池ThreadPoolExecutor的使用 使用线程池，其中涉及到一个极其重要的方法，即： execute(Runnable command) 该方法意为执行给定的任务，该任务处理可能在新的线程、已入池的线程或者正调用的线程，这由ThreadPoolExecutor的实现决定。 newFixedThreadPool 创建一个固定线程数量的线程池，示例为： ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); for (int i = 1; i 10; i++) { final int index = i; fixedThreadPool.execute(new Runnable() { @Override public void run() { String threadName = Thread.currentThread().getName(); Log.v(\"zxy\", \"线程：\"+threadName+\",正在执行第\" + index + \"个任务\"); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } }); } 上述代码，我们创建了一个线程数为3的固定线程数量的线程池，同理该线程池支持的线程最大并发数也是3，而我模拟了10个任务让它处理，执行的情况则是首先执行前三个任务，后面7个则依次进入任务队列进行等待，执行完前三个任务后，再通过FIFO的方式从任务队列中取任务执行，直到最后任务都执行完毕。 为了体现出线程的复用，我特地在Log中加上了当前线程的名称，效果为： newSingleThreadExecutor 创建一个只有一个线程的线程池，每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待线程处理完再依次处理任务队列中的任务，示例为： ExecutorService singleThreadPool = Executors.newSingleThreadExecutor(); for (int i = 1; i 10; i++) { final int index = i; singleThreadPool.execute(new Runnable() { @Override public void run() { String threadName = Thread.currentThread().getName(); Log.v(\"zxy\", \"线程：\"+threadName+\",正在执行第\" + index + \"个任务\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); } 代码还是差不多，只不过改了线程池的实现方式，效果我想大家都知道，即依次一个一个的处理任务，而且都是复用一个线程，效果为： 其实我们通过newSingleThreadExecutor()和newFixedThreadPool()的方法发现，创建一个singleThreadExecutorPool实际上就是创建一个核心线程数和最大线程数都为1的fixedThreadPool。 newCachedThreadPool 创建一个可以根据实际情况调整线程池中线程的数量的线程池，示例为： ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); for (int i = 1; i 10; i++) { final int index = i; try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } cachedThreadPool.execute(new Runnable() { @Override public void run() { String threadName = Thread.currentThread().getName(); Log.v(\"zxy\", \"线程：\" + threadName + \",正在执行第\" + index + \"个任务\"); try { long time = index * 500; Thread.sleep(time); } catch (InterruptedException e) { e.printStackTrace(); } } }); } 为了体现该线程池可以自动根据实现情况进行线程的重用，而不是一味的创建新的线程去处理任务，我设置了每隔1s去提交一个新任务，这个新任务执行的时间也是动态变化的，所以，效果为： newScheduledThreadPool创建一个可以定时或者周期性执行任务的线程池，示例为： ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3); //延迟2秒后执行该任务 scheduledThreadPool.schedule(new Runnable() { @Override public void run() { } }, 2, TimeUnit.SECONDS); //延迟1秒后，每隔2秒执行一次该任务 scheduledThreadPool.scheduleAtFixedRate(new Runnable() { @Override public void run() { } }, 1, 2, TimeUnit.SECONDS); newSingleThreadScheduledExecutor 创建一个可以定时或者周期性执行任务的线程池，该线程池的线程数为1，代码示例为： ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor(); //延迟1秒后，每隔2秒执行一次该任务 singleThreadScheduledPool.scheduleAtFixedRate(new Runnable() { @Override public void run() { String threadName = Thread.currentThread().getName(); Log.v(\"zxy\", \"线程：\" + threadName + \",正在执行\"); } },1,2,TimeUnit.SECONDS); 实际上这个和上面的没什么太大区别，只不过是线程池内线程数量的不同，效果为： 每隔2秒就会执行一次该任务 自定义线程池ThreadPoolExecutor Java内置只为我们提供了五种常用的线程池，一般来说这足够用了，不过有时候我们也可以根据需求来自定义我们自己的线程池，而要自定义不同功能的线程池，上面我们也说了线程池功能的不同归根到底还是内部的BlockingQueue实现不同，所以，我们要实现我们自己相要的线程池，就必须从BlockingQueue的实现上做手脚，而上面也说了BlockingQueue的实现类有多个，那么这次我们就选用PriorityBlockingQueue来实现一个功能是按任务的优先级来处理的线程池。 首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下： ExecutorService priorityThreadPool = new ThreadPoolExecutor(3,3,0L,TimeUnit.SECONDS,new PriorityBlockingQueue()); 然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下： public abstract class PriorityRunnable implements Runnable, Comparable { private int priority; public PriorityRunnable(int priority) { if (priority 0) throw new IllegalArgumentException(); this.priority = priority; } @Override public int compareTo(PriorityRunnable another) { int my = this.getPriority(); int other = another.getPriority(); return my 1 : my &gt; other ? -1 : 0; } @Override public void run() { doSth(); } public abstract void doSth(); public int getPriority() { return priority; } } 使用我们自己的PriorityRunnable提交任务，整体代码如下： ExecutorService priorityThreadPool = new ThreadPoolExecutor(3, 3, 0L, TimeUnit.SECONDS, new PriorityBlockingQueue()); for (int i = 1; i 10; i++) { final int priority = i; priorityThreadPool.execute(new PriorityRunnable(priority) { @Override public void doSth() { String threadName = Thread.currentThread().getName(); Log.v(\"zxy\", \"线程：\" + threadName + \",正在执行优先级为：\" + priority + \"的任务\"); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } }); } 测试效果 我们看下刚刚自定义的线程池是否达到了我们想要的功能，即根据任务的优先级进行优先处理任务，效果如下： 可以从执行结果中看出，由于核心线程数设置为3，刚开始时，系统有3个空闲线程，所以无须使用任务队列，而是直接运行前三个任务，而后面再提交任务时由于当前没有空闲线程所以加入任务队列中进行等待，此时，由于我们的任务队列实现是由PriorityBlockingQueue实现的，所以进行等待的任务会经过优先级判断，优先级高的放在队列前面先处理。从效果图中也可以看到后面的任务是先执行优先级高的任务，然后依次递减。 优先级线程池的优点 从上面我们可以得知，创建一个优先级线程池非常有用，它可以在线程池中线程数量不足或系统资源紧张时，优先处理我们想要先处理的任务，而优先级低的则放到后面再处理，这极大改善了系统默认线程池以FIFO方式处理任务的不灵活 扩展线程池ThreadPoolExecutor 除了内置的功能外，ThreadPoolExecutor也向外提供了三个接口供我们自己扩展满足我们需求的线程池，这三个接口分别是： beforeExecute() – 任务执行前执行的方法 afterExecute() -任务执行结束后执行的方法 terminated() -线程池关闭后执行的方法 这三个方法在ThreadPoolExecutor内部都没有实现 前面两个方法我们可以在ThreadPoolExecutor内部的runWorker()方法中找到，而runWorker()是ThreadPoolExecutor的内部类Worker实现的方法，Worker它实现了Runnable接口，也正是线程池内处理任务的工作线程，而Worker.runWorker()方法则是处理我们所提交的任务的方法，它会同时被多个线程访问，所以我们看runWorker()方法的实现，由于涉及到多个线程的异步调用，必然是需要使用锁来处理，而这里使用的是Lock来实现的，我们来看看runWorker()方法内主要实现： 可以看到在task.run()之前和之后分别调用了beforeExecute和afterExecute方法，并传入了我们的任务Runnable对象 而terminated()则是在关闭线程池的方法中调用，而关闭线程池有两个方法，我贴其中一个： 所以，我们要扩展线程池，只需要重写这三个方法，并实现我们自己的功能即可，这三个方法分别都会在任务执行前调用、任务执行完成后调用、线程池关闭后调用。这里我验证一下，继承自ThreadPoolExecutor 并实现那三个方法： public class MyThreadPoolExecutor extends ThreadPoolExecutor { public MyThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); } @Override protected void beforeExecute(Thread t, Runnable r) { super.beforeExecute(t, r); String threadName = t.getName(); Log.v(\"zxy\", \"线程：\" + threadName + \"准备执行任务！\"); } @Override protected void afterExecute(Runnable r, Throwable t) { super.afterExecute(r, t); String threadName = Thread.currentThread().getName(); Log.v(\"zxy\", \"线程：\" + threadName + \"任务执行结束！\"); } @Override protected void terminated() { super.terminated(); Log.v(\"zxy\", \"线程池结束！\"); } } 而运行后的结果则是，这正符合刚刚说的： 11-17 05:47:51.184 1602-1619/? V/zxy: 线程：pool-6-thread-1准备执行任务！ 11-17 05:47:51.184 1602-1619/? V/zxy: 线程：pool-6-thread-1正在执行任务！ 11-17 05:47:53.184 1602-1619/? V/zxy: 线程：pool-6-thread-1任务执行结束！ 11-17 05:47:58.896 1602-1619/? V/zxy: 线程池结束！ 所以，在上面我们的优先级线程池的代码上，我们再扩展一个具有暂停功能的优先级线程池，代码如下：具有暂时功能的线程池： public class PausableThreadPoolExecutor extends ThreadPoolExecutor { private boolean isPaused; private ReentrantLock pauseLock = new ReentrantLock(); private Condition unpaused = pauseLock.newCondition(); public PausableThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); } @Override protected void beforeExecute(Thread t, Runnable r) { super.beforeExecute(t, r); pauseLock.lock(); try { while (isPaused) unpaused.await(); } catch (InterruptedException ie) { t.interrupt(); } finally { pauseLock.unlock(); } } public void pause() { pauseLock.lock(); try { isPaused = true; } finally { pauseLock.unlock(); } } public void resume() { pauseLock.lock(); try { isPaused = false; unpaused.signalAll(); } finally { pauseLock.unlock(); } } } 然后结合上面的优先级线程池的实现，创建具有暂停功能的优先级线程池： PausableThreadPoolExecutor pausableThreadPoolExecutor = new PausableThreadPoolExecutor(1, 1, 0L, TimeUnit.SECONDS, new PriorityBlockingQueue()); for (int i = 1; i 100; i++) { final int priority = i; pausableThreadPoolExecutor.execute(new PriorityRunnable(priority) { @Override public void doSth() { runOnUiThread(new Runnable() { @Override public void run() { textView.setText(priority + \"\"); } }); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); } 这里我为了演示效果，把这个线程池设为只有一个线程，然后直接在TextView中显示当前执行的任务的优先级，然后设置个开关，控制线程池的暂停与开始： if (isPause) { pausableThreadPoolExecutor.resume(); isPause = false; } else { pausableThreadPoolExecutor.pause(); isPause = true; } 效果为： 从效果上来看，该线程池和优先级线程一样，而且还多了一个暂停与开始的功能 优化线程池ThreadPoolExecutor 虽说线程池极大改善了系统的性能，不过创建线程池也是需要资源的，所以线程池内线程数量的大小也会影响系统的性能，大了反而浪费资源，小了反而影响系统的吞吐量，所以我们创建线程池需要把握一个度才能合理的发挥它的优点，通常来说我们要考虑的因素有CPU的数量、内存的大小、并发请求的数量等因素，按需调整。 通常核心线程数可以设为CPU数量+1，而最大线程数可以设为CPU的数量\\2+1* 获取CPU数量的方法为： Runtime.getRuntime().availableProcessors(); shutdown()和shutdownNow()的区别 关于线程池的停止，ExecutorService为我们提供了两个方法：shutdown和shutdownNow，这两个方法各有不同，可以根据实际需求方便的运用，如下： shutdown()方法在终止前允许执行以前提交的任务。 shutdownNow()方法则是阻止正在任务队列中等待任务的启动并试图停止当前正在执行的任务。 关于AsyncTask的实现 大家都知道AsyncTask内部实现其实就是Thread+Handler。其中Handler是为了处理线程之间的通信，而这个Thread到底是指什么呢？通过AsyncTask源码可以得知，其实这个Thread是线程池，AsyncTask内部实现了两个线程池，分别是：串行线程池和固定线程数量的线程池。而这个固定线程数量则是通过CPU的数量决定的。 在默认情况下，我们大都通过AsyncTask::execute()来执行任务的，，而execute()内部则是调用executeOnExecutor(sDefaultExecutor, params)方法执行的，第一个参数就是指定处理该任务的线程池，而默认情况下AsyncTask是传入串行线程池（在这里不讲版本的变化），也就是任务只能单个的按顺序执行，而我们要是想让AsyncTask并行的处理任务，大家都知道调用AsyncTask::executeOnExecutor(sDefaultExecutor, params)方法传入这个参数即可：AsyncTask.THREAD_POOL_EXECUTOR。而这个参数的意义在于为任务指定了一个固定线程数量的线程池去处理，从而达到了并行处理的功能，我们可以在源码中看到AsyncTask.THREAD_POOL_EXECUTOR这个参数就是一个固定线程数量的线程池： public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"Android性能优化之常见的内存泄漏","slug":"Android性能优化之常见的内存泄漏","date":"2015-12-27T05:12:02.000Z","updated":"2015-12-27T05:41:37.000Z","comments":true,"path":"2015/12/27/Android性能优化之常见的内存泄漏/","link":"","permalink":"http://hanhailong.com/2015/12/27/Android性能优化之常见的内存泄漏/","excerpt":"前言 对于内存泄漏，我想大家在开发中肯定都遇到过，只不过内存泄漏对我们来说并不是可见的，因为它是在堆中活动，而要想检测程序中是否有内存泄漏的产生，通常我们可以借助LeakCanary、MAT等工具来检测应用程序是否存在内存泄漏，MAT是一款强大的内存分析工具，功能繁多而复杂，而LeakCanary则是由Square开源的一款轻量第三方内存泄漏检测工具，当它检测到程序中有内存泄漏的产生时，它将以最直观的方式告诉我们该内存泄漏是由谁产生的和该内存泄漏导致谁泄漏了而不能回收，供我们复查。 最近腾讯bugly也推出了三篇关于Android内存泄漏调优的文章： 内存泄露从入门到精通三部曲之基础知识篇 内存泄露从入门到精通三部曲之排查方法篇 内存泄露从入门到精通三部曲之常见原因与用户实践 Realm同样给出了性能优化文章： 10条提升Android性能的建议","text":"前言 对于内存泄漏，我想大家在开发中肯定都遇到过，只不过内存泄漏对我们来说并不是可见的，因为它是在堆中活动，而要想检测程序中是否有内存泄漏的产生，通常我们可以借助LeakCanary、MAT等工具来检测应用程序是否存在内存泄漏，MAT是一款强大的内存分析工具，功能繁多而复杂，而LeakCanary则是由Square开源的一款轻量第三方内存泄漏检测工具，当它检测到程序中有内存泄漏的产生时，它将以最直观的方式告诉我们该内存泄漏是由谁产生的和该内存泄漏导致谁泄漏了而不能回收，供我们复查。 最近腾讯bugly也推出了三篇关于Android内存泄漏调优的文章： 内存泄露从入门到精通三部曲之基础知识篇 内存泄露从入门到精通三部曲之排查方法篇 内存泄露从入门到精通三部曲之常见原因与用户实践 Realm同样给出了性能优化文章： 10条提升Android性能的建议 内存泄漏 为什么会产生内存泄漏？ 当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。 内存泄漏对程序的影响？ 内存泄漏是造成应用程序OOM的主要原因之一！我们知道Android系统为每个应用程序分配的内存有限，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就造成了内存溢出而导致应用Crash。 Android中常见的内存泄漏汇总 单例造成的内存泄漏 单例模式非常受开发者的喜爱，不过使用的不恰当的话也会造成内存泄漏，由于单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。 如下这个典例： public class AppManager { private static AppManager instance; private Context context; private AppManager(Context context) { this.context = context; } public static AppManager getInstance(Context context) { if (instance != null) { instance = new AppManager(context); } return instance; } } 这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要： 传入的是Application的Context：这将没有任何问题，因为单例的生命周期和Application的一样长 传入的是Activity的Context：当这个Context所对应的Activity退出时，由于该Context和Activity的生命周期一样长（Activity间接继承于Context），所以当前Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用。 所以正确的单例应该修改为下面这种方式： public class AppManager { private static AppManager instance; private Context context; private AppManager(Context context) { this.context = context.getApplicationContext(); } public static AppManager getInstance(Context context) { if (instance != null) { instance = new AppManager(context); } return instance; } } 这样不管传入什么Context最终将使用Application的Context，而单例的生命周期和应用的一样长，这样就防止了内存泄漏 非静态内部类创建静态实例造成的内存泄漏 有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法： public class MainActivity extends AppCompatActivity { private static TestResource mResource = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(mResource == null){ mResource = new TestResource(); } //... } class TestResource { //... } } 这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而又使用了该非静态内部类创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为：将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请使用ApplicationContext Handler造成的内存泄漏 Handler的使用造成的内存泄漏问题应该说最为常见了，平时在处理网络任务或者封装一些请求回调等api都应该会借助Handler来处理，对于Handler的使用代码编写一不规范即有可能造成内存泄漏，如下示例： public class MainActivity extends AppCompatActivity { private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { //... } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); loadData(); } private void loadData(){ //...request Message message = Message.obtain(); mHandler.sendMessage(message); } } 这种创建Handler的方式会造成内存泄漏，由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏，所以另外一种做法为： public class MainActivity extends AppCompatActivity { private MyHandler mHandler = new MyHandler(this); private TextView mTextView ; private static class MyHandler extends Handler { private WeakReference&lt;Context&gt; reference; public MyHandler(Context context) { reference = new WeakReference&lt;&gt;(context); } @Override public void handleMessage(Message msg) { MainActivity activity = (MainActivity) reference.get(); if(activity != null){ activity.mTextView.setText(\"\"); } } } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView)findViewById(R.id.textview); loadData(); } private void loadData() { //...request Message message = Message.obtain(); mHandler.sendMessage(message); } } 创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息，更准确的做法如下： public class MainActivity extends AppCompatActivity { private MyHandler mHandler = new MyHandler(this); private TextView mTextView ; private static class MyHandler extends Handler { private WeakReference&lt;Context&gt; reference; public MyHandler(Context context) { reference = new WeakReference&lt;&gt;(context); } @Override public void handleMessage(Message msg) { MainActivity activity = (MainActivity) reference.get(); if(activity != null){ activity.mTextView.setText(\"\"); } } } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView)findViewById(R.id.textview); loadData(); } private void loadData() { //...request Message message = Message.obtain(); mHandler.sendMessage(message); } @Override protected void onDestroy() { super.onDestroy(); mHandler.removeCallbacksAndMessages(null); } } 使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages();来移除指定的Runnable和Message。 线程造成的内存泄漏 对于线程造成的内存泄漏，也是平时比较常见的，异步任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成，那么将导致Activity的内存资源无法回收，造成内存泄漏。正确的做法还是使用静态内部类的方式，如下： static class MyAsyncTask extends AsyncTask&lt;Void, Void, Void&gt; { private WeakReference&lt;Context&gt; weakReference; public MyAsyncTask(Context context) { weakReference = new WeakReference&lt;&gt;(context); } @Override protected Void doInBackground(Void... params) { SystemClock.sleep(10000); return null; } @Override protected void onPostExecute(Void aVoid) { super.onPostExecute(aVoid); MainActivity activity = (MainActivity) weakReference.get(); if (activity != null) { //... } } } static class MyRunnable implements Runnable{ @Override public void run() { SystemClock.sleep(10000); } } //—————— new Thread(new MyRunnable()).start(); new MyAsyncTask(this).execute(); 这样就避免了Activity的内存资源泄漏，当然在Activity销毁时候也应该取消相应的任务AsyncTask::cancel()，避免任务在后台执行浪费资源。 资源未关闭造成的内存泄漏 对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。 一些建议 对于生命周期比Activity长的对象如果需要应该使用ApplicationContext 对于需要在静态内部类中使用非静态外部成员变量（如：Context、View )，可以在静态内部类中使用弱引用来引用外部类的变量来避免内存泄漏 对于不再需要使用的对象，显示的将其赋值为null，比如使用完Bitmap后先调用recycle()，再赋为null 保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期 对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏： 将内部类改为静态内部类 静态内部类中使用弱引用来引用外部类的成员变量 在涉及到Context时先考虑ApplicationContext，当然它并不是万能的，对于有些地方则必须使用Activity的Context，对于Application，Service，Activity三者的Context的应用场景如下： 其中：NO1表示Application和Service可以启动一个Activity，不过需要创建一个新的task任务队列。而对于Dialog而言，只有在Activity中才能创建","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"Sublime Text自动开启换行Word Wrap","slug":"Sublime-Text自动开启换行Word-Wrap","date":"2015-11-24T10:02:27.000Z","updated":"2015-11-24T10:22:38.000Z","comments":true,"path":"2015/11/24/Sublime-Text自动开启换行Word-Wrap/","link":"","permalink":"http://hanhailong.com/2015/11/24/Sublime-Text自动开启换行Word-Wrap/","excerpt":"","text":"Sublime Text，绝对是神器中的神器，之前在windows电脑上一直都是用nodepad++。mac上也没找到太好的编辑工具，之前曾用过破解版的UltraEdit，但是自从第一次用了Sublime Text后，就彻底的把它打入冷宫了！！ 下面讲讲如何开启Sublime Text的自动换行功能，默认情况下是不开启的。当然你也可以点击导航栏上View-&gt;Word Wrap开启，不过对我们程序猿来说，还是太麻烦了。这里从根本上解决自动换行的问题。 解决方案： 我这里用的是mac版本的，windows同理 Preferences-&gt;Setting - User 在打开的Preferences.sublime-settings文件里面，你将会看到类似下面的内容： { \"ignored_packages\": [ \"Markdown\", \"Vintage\" ] } 很明显，这是一个json格式的配置文件，在后面直接追加 { \"word_wrap\" : true } 修改之后的文件内容为： { \"ignored_packages\": [ \"Markdown\", \"Vintage\" ], \"word_wrap\":true } 重启Sublime Text后，你将会发现文字、代码超过一行后会自动换行！！！","categories":[],"tags":[{"name":"Sublime Text","slug":"Sublime-Text","permalink":"http://hanhailong.com/tags/Sublime-Text/"}]},{"title":"Android-小米桌面图标显示角标数","slug":"Android-小米桌面图标显示角标数","date":"2015-11-23T07:07:11.000Z","updated":"2015-11-23T10:02:09.000Z","comments":true,"path":"2015/11/23/Android-小米桌面图标显示角标数/","link":"","permalink":"http://hanhailong.com/2015/11/23/Android-小米桌面图标显示角标数/","excerpt":"基本介绍 最近有群里问：怎样在小米手机桌面的图标上显示角标数，我看了下我的红米note手机，果然有的第三方app图标上显示角标数，尤其是微信和QQ。这让我立马想到了：小米是不是对通知栏做了手脚。立马我查了相关文档并做了相关的测试，发现果然如我猜测的：MIUI系统对通知栏做了手脚。它目前有两种情况： 默认情况 当第三方app向通知栏发送一条通知（一般不带进度条并且用户可以删除的通知），那么此时app icon的角标数就会显示1。 这个时候app显示的角标数和通知栏里app发送的通知数是对应的，即向通知栏发多少条通知就会显示多少角标数。","text":"基本介绍 最近有群里问：怎样在小米手机桌面的图标上显示角标数，我看了下我的红米note手机，果然有的第三方app图标上显示角标数，尤其是微信和QQ。这让我立马想到了：小米是不是对通知栏做了手脚。立马我查了相关文档并做了相关的测试，发现果然如我猜测的：MIUI系统对通知栏做了手脚。它目前有两种情况： 默认情况 当第三方app向通知栏发送一条通知（一般不带进度条并且用户可以删除的通知），那么此时app icon的角标数就会显示1。 这个时候app显示的角标数和通知栏里app发送的通知数是对应的，即向通知栏发多少条通知就会显示多少角标数。 定义角标数量 如果想让app在通知栏里只显示一条通知，但角标数是多个怎么办呢？ 原理是通过反射拿到Notification的私有属性extraNotification，重点就是这个extraNotification,MIUI系统对这个重定义了，这个类在MIUI系统里是android.app.MiuiNotification这个类，这个类里面有个私有属性messageCount,我们只要改变这个messageCount值就能显示的改变app icon的角标数了。如下图所示： 这里给出代码示例： NotificationCompat.Builder builder = new NotificationCompat.Builder(this) .setSmallIcon(R.mipmap.ic_launcher) .setContentTitle(\"小米角标\") .setContentText(\"miui桌面角标消息\"); NotificationManagerCompat managerCompat = NotificationManagerCompat.from(this); Notification notification = builder.build(); try { Field field = notification.getClass().getDeclaredField(\"extraNotification\"); Object extraNotification = field.get(notification); Method method = extraNotification.getClass().getDeclaredMethod(\"setMessageCount\", int.class); method.invoke(extraNotification, 10); } catch (Exception e) { e.printStackTrace(); } managerCompat.notify(0, notification); 上面的数字10就是要显示的角标数，我们看下结果：","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"Android-部分作品鉴赏","slug":"Android-部分作品鉴赏","date":"2015-11-04T15:32:50.000Z","updated":"2015-11-04T15:56:09.000Z","comments":true,"path":"2015/11/04/Android-部分作品鉴赏/","link":"","permalink":"http://hanhailong.com/2015/11/04/Android-部分作品鉴赏/","excerpt":"时间过得真快，马上快毕业四年了，这里整理了下我做过的部分App，当然还有一些其他的App，不是外包就是没有纪念意义，这里就不列举了！","text":"时间过得真快，马上快毕业四年了，这里整理了下我做过的部分App，当然还有一些其他的App，不是外包就是没有纪念意义，这里就不列举了！ 51拉勾 51拉钩是我做过的第二个商业Android客户端App，承载了我很多记忆，现在还记得当初和小伙伴们加班到晚上11点、12点甚至凌晨两三点的情景（岁月不饶人啊~~~）！！！ 51听听 51听听是继51拉钩之后的又一个商业App，这个App比较有意思，里面包括大量童话、唐诗三百首等儿童教育方面的故事！！！ 发镖 发镖这是我加入北京博雅立方做过的唯一的一款App，包括IOS版本，这个App以前叫营销掌中宝，是国内首家最专业的营销推广平台，服务类目包括微信营销、百度营销、建站推广等多产品类目。 极客学院 极客学院，中国最大的IT职业在线教育平台！！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://hanhailong.com/tags/随笔/"}]},{"title":"Android版本-编译VLC","slug":"Android版本-编译VLC","date":"2015-10-27T13:54:31.000Z","updated":"2015-11-05T16:06:59.000Z","comments":true,"path":"2015/10/27/Android版本-编译VLC/","link":"","permalink":"http://hanhailong.com/2015/10/27/Android版本-编译VLC/","excerpt":"简述 最近公司项目极客学院在线播放器要加一个需求：支持播放倍数加速、支持字幕；之前用的是一个第三方的开源库ijkplayer，这个库也非常的给力，它对ffmpeg做了很好的封装，不过不支持加速减速播放，所以弃用改成VLC-Android，IOS的在这VLC-IOS.","text":"简述 最近公司项目极客学院在线播放器要加一个需求：支持播放倍数加速、支持字幕；之前用的是一个第三方的开源库ijkplayer，这个库也非常的给力，它对ffmpeg做了很好的封装，不过不支持加速减速播放，所以弃用改成VLC-Android，IOS的在这VLC-IOS. 这里记录下编译Android版本的过程和遇到的错误： 总体来说是比较顺利的，按照官方的wiki文档一步一步走下来，基本上没有遇到大问题，遇到唯一的问题是xz-5.0.3.tar.bz2和protobuf-2.6.1.tar.gz这两个库文件没有下载些来（因为被墙了），我单独下载安装的，这里我把这两个文件放到CSDN上了，有需要的自行下载！！ 编译过程 编译的第一步肯定是需要下载一些必要的工具，如果你的系统是Linux，你可以通过api-get来安装： sudo apt-get install automake ant autopoint cmake build-essential libtool \\ patch pkg-config protobuf-compiler ragel subversion unzip git 我这里用的是Mac Ox，所以采用HomeBrew来安装，首先需要执行命令： brew install automake ant autopoint cmake build-essential libtool \\ patch pkg-config protobuf-compiler ragel subversion unzip git 然后等待上面的工具安装完成，安装完成后开始执行下一步 这里假设你已经装好Android SDK和Android NDK 配置环境变量 1.cd命令到当前用户目录下，打开.bash_profile文件： cd ~ open .bash_profile 如果没有.bash_profile，请touch新建一个.bash_profile touch .bash_profile 打开.bash_profile文件后，在文件里面输入 export ANDROID_SDK=/Users/HanHailong/Library/Android/sdk export ANDROID_NDK=/Users/HanHailong/NDK/android-ndk-r10e export PATH=$PATH:$ANDROID_SDK/platform-tools:$ANDROID_SDK/tools ANDROID_SDK和ANDROID_NDK后面的换成你自己对应的路径。 克隆代码 git clone git://git.videolan.org/vlc-ports/android.git 编译工程将项目clone下来后就开始编译项目了，cd命令到你clone下来的工程里面，执行命令： ./compile.sh 然后VLC会自动执行一长系列的下载、编译工作，这里需要等老长时间，如果你有vpn，最好开启vpn，因为一些用到的文件被墙了！！我这里就遇到坑了，xz-5.0.3.tar.bz2和protobuf-2.6.1.tar.gz下载失败，而导致VLC编译失败，没办法，只能将上面两个文件单独下载下来. 解压并安装protobuf 一步一步执行下面如下命令： tar -zxf protobuf-2.6.1.tar.gz cd protobuf-2.6.1 ./configure make install 解压并安装xz 一步一步执行下面如下命令： tar -zxf xz-5.0.3.tar.bz2 cd xz-5.0.3 ./configure make install 执行完了后，继续回到VLC工程目录下执行命令： ./compile.sh 之后，VLC会继续执行下载、编译库文件，稍微等一段时间，快得几分钟，慢的十几分钟！！看编译成功后的截图： 编译结果 编译成功后，会在vlc-android/build/outputs/apk目录下生成编译后的apk包： 我们将其安装到真机上，效果图还是蛮不错的： VLC很强大，支持字幕，支持锁定屏幕，支持跳转到某个具体时间，支持0.25-4倍的慢放、快放、支持亮度调节、支持音量调节、支持快进、支持直播等特性，是做在线视频播放的绝佳选择之一！！！！ 上面两个xz-5.0.3.tar.bz2和protobuf-2.6.1.tar.gz可以在这里下载！ 最后，附上我编译好的项目VLC-Android，这里我只编译了四种so包（armeabi-v7a、armeabi、x86、mips），有需要的朋友自行下载。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"不错的IOS学习博客网站-IOS122","slug":"不错的IOS学习博客网站-IOS122","date":"2015-10-22T08:58:51.000Z","updated":"2015-10-22T09:07:09.000Z","comments":true,"path":"2015/10/22/不错的IOS学习博客网站-IOS122/","link":"","permalink":"http://hanhailong.com/2015/10/22/不错的IOS学习博客网站-IOS122/","excerpt":"","text":"这是不错的学习技术博客系列第四篇，只不过IOS122只讲解IOS技术。 当我第一次打开这个博客的时候，我被里面的第三库资源震惊了，没想到作者整理了这么多的第三库资源。最重要的是，里面的博文质量非常高，绝对是IOS学习技术的最佳去处！！！","categories":[],"tags":[{"name":"技术博客","slug":"技术博客","permalink":"http://hanhailong.com/tags/技术博客/"}]},{"title":"cocoapods安装失败-bad response Not Found 404 (http://ruby.taobao.org/latest_specs.4.8.gz","slug":"cocoapods安装失败-bad-response-Not-Found-404-http-ruby-taobao-org-latest-specs-4-8-gz","date":"2015-10-22T05:37:34.000Z","updated":"2015-10-22T06:17:49.000Z","comments":true,"path":"2015/10/22/cocoapods安装失败-bad-response-Not-Found-404-http-ruby-taobao-org-latest-specs-4-8-gz/","link":"","permalink":"http://hanhailong.com/2015/10/22/cocoapods安装失败-bad-response-Not-Found-404-http-ruby-taobao-org-latest-specs-4-8-gz/","excerpt":"最近把MAC系统升级到了最新版本-10.11（OS X EI Capitan），发现之前装的CocoaPods不能用了，只好重新装了。执行如下命令： sudo gem install cocoapods 发现报如下错误：","text":"最近把MAC系统升级到了最新版本-10.11（OS X EI Capitan），发现之前装的CocoaPods不能用了，只好重新装了。执行如下命令： sudo gem install cocoapods 发现报如下错误： 我之前就是用的淘宝的镜像http://ruby.taobao.org/，我们在浏览器上输入：http://ruby.taobao.org/，链接自动重定向到了https://ruby.taobao.org/，淘宝镜像也给了提示： 好吧，那我们只能删掉http的，改成https的，执行命令： gem sources --remove http://ruby.taobao.org/ gem sources -a https://ruby.taobao.org/ 改掉之后我们继续使用命令查看我们改之后的ruby镜像： gem sources -l 我们继续安装cocoapods，执行命令： sudo gem install cocoapods 这时候会让你输入密码，输入密码完了之后就开始真正的安装cocoapods了 安装完之后，执行命令： pod --version 出现版本0.39.0之后，就说明安装成功了！！！！","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://hanhailong.com/tags/IOS/"}]},{"title":"Android-教你自作一个简单而又实用的流式Tag标签布局","slug":"Android-教你自作一个简单而又实用的流式Tag标签布局","date":"2015-10-20T10:26:19.000Z","updated":"2015-10-20T13:44:35.000Z","comments":true,"path":"2015/10/20/Android-教你自作一个简单而又实用的流式Tag标签布局/","link":"","permalink":"http://hanhailong.com/2015/10/20/Android-教你自作一个简单而又实用的流式Tag标签布局/","excerpt":"在这一章节，我们继续学习Android自定义控件。这里要自定义的是Android里面的一个常用控件-Android流式Tag布局，这里我们命名为：FlowTagLayout，我们要实现的流式布局，有如下特色： 填充数据和ListView、GridView用法一样使用Adapter，更新数据直接通过adapter.notifyDataChanged来更新 支持点击、单选、多选三种模式：FLOW_TAG_CHECKED_NONE、FLOW_TAG_CHECKED_SINGLE、FLOW_TAG_CHECKED_MULTI 正式讲解之前先看下我们实现后的效果图：","text":"在这一章节，我们继续学习Android自定义控件。这里要自定义的是Android里面的一个常用控件-Android流式Tag布局，这里我们命名为：FlowTagLayout，我们要实现的流式布局，有如下特色： 填充数据和ListView、GridView用法一样使用Adapter，更新数据直接通过adapter.notifyDataChanged来更新 支持点击、单选、多选三种模式：FLOW_TAG_CHECKED_NONE、FLOW_TAG_CHECKED_SINGLE、FLOW_TAG_CHECKED_MULTI 正式讲解之前先看下我们实现后的效果图： 目前网上有很多的教程来写流式布局实现，我看到的版本大体上有两种，一种是继承ViewGroup，然后重写其onMeasure和onLayout方法，另一种则是继承自RelativeLayout，例如这个TagView 而我们这里采用的是第一种方法，因为我感觉第一种方法简单、清晰、明了！！ 因为我们直接继承的ViewGroup，所以要指定它的LayoutParams，这里因为只需要margin，所以我们直接返回MarginLayoutParams就可以了，代码如下： @Override public LayoutParams generateLayoutParams(AttributeSet attrs) { return new MarginLayoutParams(getContext(), attrs); } onMeasure测量 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); //获取Padding // 获得它的父容器为它设置的测量模式和大小 int sizeWidth = MeasureSpec.getSize(widthMeasureSpec); int sizeHeight = MeasureSpec.getSize(heightMeasureSpec); int modeWidth = MeasureSpec.getMode(widthMeasureSpec); int modeHeight = MeasureSpec.getMode(heightMeasureSpec); //FlowLayout最终的宽度和高度值 int resultWidth = 0; int resultHeight = 0; //测量时每一行的宽度 int lineWidth = 0; //测量时每一行的高度，加起来就是FlowLayout的高度 int lineHeight = 0; //遍历每个子元素 for (int i = 0, childCount = getChildCount(); i &lt; childCount; i++) { View childView = getChildAt(i); //测量每一个子view的宽和高 measureChild(childView, widthMeasureSpec, heightMeasureSpec); //获取到测量的宽和高 int childWidth = childView.getMeasuredWidth(); int childHeight = childView.getMeasuredHeight(); //因为子View可能设置margin，这里要加上margin的距离 MarginLayoutParams mlp = (MarginLayoutParams) childView.getLayoutParams(); int realChildWidth = childWidth + mlp.leftMargin + mlp.rightMargin; int realChildHeight = childHeight + mlp.topMargin + mlp.bottomMargin; //如果当前一行的宽度加上要加入的子view的宽度大于父容器给的宽度，就换行 if ((lineWidth + realChildWidth) &gt; sizeWidth) { //换行 resultWidth = Math.max(lineWidth, realChildWidth); resultHeight += realChildHeight; //换行了，lineWidth和lineHeight重新算 lineWidth = realChildWidth; lineHeight = realChildHeight; } else { //不换行，直接相加 lineWidth += realChildWidth; //每一行的高度取二者最大值 lineHeight = Math.max(lineHeight, realChildHeight); } //遍历到最后一个的时候，肯定走的是不换行 if (i == childCount - 1) { resultWidth = Math.max(lineWidth, resultWidth); resultHeight += lineHeight; } setMeasuredDimension(modeWidth == MeasureSpec.EXACTLY ? sizeWidth : resultWidth, modeHeight == MeasureSpec.EXACTLY ? sizeHeight : resultHeight); } } 代码注释的很详细，首先得到其父容器传入的测量模式和宽高的计算值，然后遍历所有的childView，使用measureChild方法对所有的childView进行测量。然后根据所有childView的测量得出的宽和高得到该ViewGroup如果设置为wrap_content时的宽和高 onLayout @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { int flowWidth = getWidth(); int childLeft = 0; int childTop = 0; //遍历子控件，记录每个子view的位置 for (int i = 0, childCount = getChildCount(); i &lt; childCount; i++) { View childView = getChildAt(i); //跳过View.GONE的子View if (childView.getVisibility() == View.GONE) { continue; } //获取到测量的宽和高 int childWidth = childView.getMeasuredWidth(); int childHeight = childView.getMeasuredHeight(); //因为子View可能设置margin，这里要加上margin的距离 MarginLayoutParams mlp = (MarginLayoutParams) childView.getLayoutParams(); if (childLeft + mlp.leftMargin + childWidth + mlp.rightMargin &gt; flowWidth) { //换行处理 childTop += (mlp.topMargin + childHeight + mlp.bottomMargin); childLeft = 0; } //布局 int left = childLeft + mlp.leftMargin; int top = childTop + mlp.topMargin; int right = childLeft + mlp.leftMargin + childWidth; int bottom = childTop + mlp.topMargin + childHeight; childView.layout(left, top, right, bottom); childLeft += (mlp.leftMargin + childWidth + mlp.rightMargin); } } onLayout方法就是将子View摆放到FlowTagLayout中，核心就是childView.layout(l,t,r,b)方法。 测量完了，布局也完了，下面就是填充数据了，我们这里采用的是Adapter模式，用法基本上和我们常用的ListView、GridView一样，用户只要写一个适配器Adapter，然后调用xxx.setAdapter方法，就把数据源绑到控件上了，而且这种做法还有个好处：子View可以是任意类型的控件 填充数据和ListView、GridView用法一样使用Adapter，更新数据直接通过adapter.notifyDataChanged来更新 我研究了下ListView和GridView的adapter.notifyDataChanged实现，一句话：观察者模式！首先，我们要在FlowTagLayout里面注册一个观察者，当我们调用adapter.notifyDataChanged的时候能通知这个观察者来刷新页面。 /** * 像ListView、GridView一样使用FlowLayout * * @param adapter */ public void setAdapter(ListAdapter adapter) { if (mAdapter != null &amp;&amp; mDataSetObserver != null) { mAdapter.unregisterDataSetObserver(mDataSetObserver); } //清除现有的数据 removeAllViews(); mAdapter = adapter; if (mAdapter != null) { mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver); } } 方法 mAdapter.registerDataSetObserver(mDataSetObserver);就注册了观察者，我们继续看： class AdapterDataSetObserver extends DataSetObserver { @Override public void onChanged() { super.onChanged(); reloadData(); } @Override public void onInvalidated() { super.onInvalidated(); } } 当我们调用adapter.notifyDataChanged方法的时候，就会执行onChanged这个方法，我加了一个reloadData方法： /** * 重新加载刷新数据 */ private void reloadData() { removeAllViews(); for (int i = 0; i &lt; mAdapter.getCount(); i++) { final int j = i; mCheckedTagArray.put(i, false); final View childView = mAdapter.getView(i, null, this); addView(childView, new MarginLayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT)); final int finalI = i; childView.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { if (mTagCheckMode == FLOW_TAG_CHECKED_NONE) { if (mOnTagClickListener != null) { mOnTagClickListener.onItemClick(FlowTagLayout.this, childView, j); } } else if (mTagCheckMode == FLOW_TAG_CHECKED_SINGLE) { //判断状态 if (mCheckedTagArray.get(j)) { mCheckedTagArray.put(j, false); childView.setSelected(false); if (mOnTagSelectListener != null) { mOnTagSelectListener.onItemSelect(FlowTagLayout.this, new ArrayList&lt;Integer&gt;()); } return; } for (int k = 0; k &lt; mAdapter.getCount(); k++) { mCheckedTagArray.put(k, false); getChildAt(k).setSelected(false); } mCheckedTagArray.put(j, true); childView.setSelected(true); if (mOnTagSelectListener != null) { mOnTagSelectListener.onItemSelect(FlowTagLayout.this, Arrays.asList(j)); } } else if (mTagCheckMode == FLOW_TAG_CHECKED_MULTI) { if (mCheckedTagArray.get(j)) { mCheckedTagArray.put(j, false); childView.setSelected(false); } else { mCheckedTagArray.put(j, true); childView.setSelected(true); } //回调 if (mOnTagSelectListener != null) { List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for (int k = 0; k &lt; mAdapter.getCount(); k++) { if (mCheckedTagArray.get(k)) { list.add(k); } } mOnTagSelectListener.onItemSelect(FlowTagLayout.this, list); } } } }); } } 这个方法的作用就是重新加载子View，先是移除所有的子View，然后从Adapter中获取子View，addView到FlowTagLayout中，在这个过程中，我们给每个子View添加了点击事件，点击事件里面的逻辑很简单，就是根据FlowTagLayout的三种模式分别处理单击、单选、多选逻辑，三种模式分别为： /** * FlowLayout not support checked */ public static final int FLOW_TAG_CHECKED_NONE = 0; /** * FlowLayout support single-select */ public static final int FLOW_TAG_CHECKED_SINGLE = 1; /** * FlowLayout support multi-select */ public static final int FLOW_TAG_CHECKED_MULTI = 2; 为了使单击、单选、多选事件通知到Activity、Fragment，我们加入了两个监听方法： /** * Created by HanHailong on 15/10/20. */ public interface OnTagClickListener { void onItemClick(FlowTagLayout parent, View view, int position); } 和 /** * Created by HanHailong on 15/10/20. */ public interface OnTagSelectListener { void onItemSelect(FlowTagLayout parent, List&lt;Integer&gt; selectedList); } 改写的都写了，我们怎么使用呢？请继续往下看 用法 首先，我们先写一个适配器TagAdapter，写法完全和写ListView的适配器一样： /** * Created by HanHailong on 15/10/19. */ public class TagAdapter&lt;T&gt; extends BaseAdapter { private final Context mContext; private final List&lt;T&gt; mDataList; public TagAdapter(Context context) { this.mContext = context; mDataList = new ArrayList&lt;&gt;(); } @Override public int getCount() { return mDataList.size(); } @Override public Object getItem(int position) { return mDataList.get(position); } @Override public long getItemId(int position) { return position; } @Override public View getView(int position, View convertView, ViewGroup parent) { View view = LayoutInflater.from(mContext).inflate(R.layout.tag_item, null); TextView textView = (TextView) view.findViewById(R.id.tv_tag); T t = mDataList.get(position); if (t instanceof String) { textView.setText((String) t); } return view; } public void onlyAddAll(List&lt;T&gt; datas) { mDataList.addAll(datas); notifyDataSetChanged(); } public void clearAndAddAll(List&lt;T&gt; datas) { mDataList.clear(); onlyAddAll(datas); } } 布局tag_item.xml &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;TextView android:id=\"@+id/tv_tag\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"10dp\" android:layout_marginTop=\"10dp\" android:background=\"@drawable/round_rectangle_bg\" android:paddingBottom=\"5dp\" android:paddingLeft=\"10dp\" android:paddingRight=\"10dp\" android:paddingTop=\"5dp\" android:text=\"TAG标签\" android:textColor=\"@color/normal_text_color\" /&gt; &lt;/LinearLayout&gt; 再看我们引用FlowTagLayout的主布局代码： &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;ScrollView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fillViewport=\"true\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" tools:context=\".MainActivity\" tools:showIn=\"@layout/activity_main\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingBottom=\"30dp\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"10dp\" android:text=\"颜色\\n(点击)\" /&gt; &lt;com.hhl.library.FlowTagLayout android:id=\"@+id/color_flow_layout\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"10dp\" android:orientation=\"horizontal\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"10dp\" android:text=\"尺寸\\n(单选)\" /&gt; &lt;com.hhl.library.FlowTagLayout android:id=\"@+id/size_flow_layout\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"10dp\" android:orientation=\"horizontal\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"10dp\" android:text=\"移动\\n(多选)\" /&gt; &lt;com.hhl.library.FlowTagLayout android:id=\"@+id/mobile_flow_layout\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt; 最后，我们看Activity里面是怎么使用的： package com.hhl.flowlayoutdemo; import android.os.Bundle; import android.support.design.widget.FloatingActionButton; import android.support.design.widget.Snackbar; import android.support.v7.app.AppCompatActivity; import android.support.v7.widget.Toolbar; import android.view.Menu; import android.view.MenuItem; import android.view.View; import com.hhl.library.FlowTagLayout; import com.hhl.library.OnTagClickListener; import com.hhl.library.OnTagSelectListener; import java.util.ArrayList; import java.util.List; public class MainActivity extends AppCompatActivity { private FlowTagLayout mColorFlowTagLayout; private FlowTagLayout mSizeFlowTagLayout; private FlowTagLayout mMobileFlowTagLayout; private TagAdapter&lt;String&gt; mSizeTagAdapter; private TagAdapter&lt;String&gt; mColorTagAdapter; private TagAdapter&lt;String&gt; mMobileTagAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Snackbar.make(view, \"Replace with your own action\", Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); } }); mColorFlowTagLayout = (FlowTagLayout) findViewById(R.id.color_flow_layout); mSizeFlowTagLayout = (FlowTagLayout) findViewById(R.id.size_flow_layout); mMobileFlowTagLayout = (FlowTagLayout) findViewById(R.id.mobile_flow_layout); //颜色 mColorTagAdapter = new TagAdapter&lt;&gt;(this); mColorFlowTagLayout.setAdapter(mColorTagAdapter); mColorFlowTagLayout.setOnTagClickListener(new OnTagClickListener() { @Override public void onItemClick(FlowTagLayout parent, View view, int position) { Snackbar.make(view, \"颜色:\" + parent.getAdapter().getItem(position), Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); } }); //尺寸 mSizeTagAdapter = new TagAdapter&lt;&gt;(this); mSizeFlowTagLayout.setTagCheckedMode(FlowTagLayout.FLOW_TAG_CHECKED_SINGLE); mSizeFlowTagLayout.setAdapter(mSizeTagAdapter); mSizeFlowTagLayout.setOnTagSelectListener(new OnTagSelectListener() { @Override public void onItemSelect(FlowTagLayout parent, List&lt;Integer&gt; selectedList) { if (selectedList != null &amp;&amp; selectedList.size() &gt; 0) { StringBuilder sb = new StringBuilder(); for (int i : selectedList) { sb.append(parent.getAdapter().getItem(i)); sb.append(\":\"); } Snackbar.make(parent, \"移动研发:\" + sb.toString(), Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); }else{ Snackbar.make(parent, \"没有选择标签\", Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); } } }); //移动研发标签 mMobileTagAdapter = new TagAdapter&lt;&gt;(this); mMobileFlowTagLayout.setTagCheckedMode(FlowTagLayout.FLOW_TAG_CHECKED_MULTI); mMobileFlowTagLayout.setAdapter(mMobileTagAdapter); mMobileFlowTagLayout.setOnTagSelectListener(new OnTagSelectListener() { @Override public void onItemSelect(FlowTagLayout parent, List&lt;Integer&gt; selectedList) { if (selectedList != null &amp;&amp; selectedList.size() &gt; 0) { StringBuilder sb = new StringBuilder(); for (int i : selectedList) { sb.append(parent.getAdapter().getItem(i)); sb.append(\":\"); } Snackbar.make(parent, \"移动研发:\" + sb.toString(), Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); }else{ Snackbar.make(parent, \"没有选择标签\", Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); } } }); initColorData(); initSizeData(); initMobileData(); } private void initMobileData() { List&lt;String&gt; dataSource = new ArrayList&lt;&gt;(); dataSource.add(\"android\"); dataSource.add(\"安卓\"); dataSource.add(\"SDK源码\"); dataSource.add(\"IOS\"); dataSource.add(\"iPhone\"); dataSource.add(\"游戏\"); dataSource.add(\"fragment\"); dataSource.add(\"viewcontroller\"); dataSource.add(\"cocoachina\"); dataSource.add(\"移动研发工程师\"); dataSource.add(\"移动互联网\"); dataSource.add(\"高薪+期权\"); mMobileTagAdapter.onlyAddAll(dataSource); } private void initColorData() { List&lt;String&gt; dataSource = new ArrayList&lt;&gt;(); dataSource.add(\"红色\"); dataSource.add(\"黑色\"); dataSource.add(\"花边色\"); dataSource.add(\"深蓝色\"); dataSource.add(\"白色\"); dataSource.add(\"玫瑰红色\"); dataSource.add(\"紫黑紫兰色\"); dataSource.add(\"葡萄红色\"); dataSource.add(\"屎黄色\"); dataSource.add(\"绿色\"); dataSource.add(\"彩虹色\"); dataSource.add(\"牡丹色\"); mColorTagAdapter.onlyAddAll(dataSource); } /** * 初始化数据 */ private void initSizeData() { List&lt;String&gt; dataSource = new ArrayList&lt;&gt;(); dataSource.add(\"28 (2.1尺)\"); dataSource.add(\"29 (2.2尺)\"); dataSource.add(\"30 (2.3尺)\"); dataSource.add(\"31 (2.4尺)\"); dataSource.add(\"32 (2.5尺)........\"); dataSource.add(\"33 (2.6尺)\"); dataSource.add(\"34 (2.7尺)\"); dataSource.add(\"35 (2.8尺)\"); dataSource.add(\"36 (2.9尺)\"); dataSource.add(\"37 (3.0尺)\"); dataSource.add(\"38 (3.1尺)\"); dataSource.add(\"39 (3.2尺)........\"); mSizeTagAdapter.onlyAddAll(dataSource); } @Override public boolean onCreateOptionsMenu(Menu menu) { // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; } @Override public boolean onOptionsItemSelected(MenuItem item) { // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) { return true; } return super.onOptionsItemSelected(item); } } 好了，一个简单而实用的流式标签就轻松搞定了！！ TODO 添加初始化选中标签 添加tag样式支持（颜色、图标等等） 像ListView、GridView一样复用子View 其他… 如果你觉得本篇博客对你有用，那么就留个言或者顶一个~~ 最后，附上github源码FlowTagLayout","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"Android Support Library 23.1 now available","slug":"Android-Support-Library-23-1-now-available","date":"2015-10-19T02:50:32.000Z","updated":"2015-10-19T03:14:48.000Z","comments":true,"path":"2015/10/19/Android-Support-Library-23-1-now-available/","link":"","permalink":"http://hanhailong.com/2015/10/19/Android-Support-Library-23-1-now-available/","excerpt":"","text":"Support V4 gets a number of important bug fixes as well as a few new features for NestedScrollView and around MediaSessionCompat. Media Router has gotten a design overhaul, making connecting and controlling remote devices such as Google Cast enabled devices even easier. RecyclerView has a significant backward incompatible change to the animation system, offering new flexibility and support for item content animations. You’ll find a SimpleItemAnimator helper class for easing the transition to the new animation system. AppCompat adds a new tint aware Seekbar, ImageButton, and ImageView and updating styling to SwitchCompat. Design improves TextInputLayout with support for character counting, the new SCROLL_FLAG_SNAP allows AppBarLayout children to snap completely on or off the screen when scrolling completes, and NavigationView now supports custom views for menu items. Percent adds support for setting a custom aspect ratio to both PercentFrameLayout and PercentRelativeLayout. Custom Tabs increases the customization available with the ability to hide the URL bar when scrolling down and change the custom action button for current custom tab session as well as the ability to receive tab shown and hidden events. Leanback updates GuidedStepFragment so it can be placed on top of existing content and adds new search completion type annotations for SearchFragment.","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"},{"name":"Android咨询","slug":"Android咨询","permalink":"http://hanhailong.com/tags/Android咨询/"}]},{"title":"Android-一步一步教你自定义IOS样式的UISwitch","slug":"Android-一步一步教你自定义IOS样式的UISwitch","date":"2015-10-17T13:08:13.000Z","updated":"2015-10-18T16:59:54.000Z","comments":true,"path":"2015/10/17/Android-一步一步教你自定义IOS样式的UISwitch/","link":"","permalink":"http://hanhailong.com/2015/10/17/Android-一步一步教你自定义IOS样式的UISwitch/","excerpt":"在这一章节，我们将开始在Android上做一个IOS风格的UISwitch控件。这篇文章主要涉及如下知识点： Android属性动画Animator 自定义手势GestureDetector 自定义View属性attrs 首先，让我们来看一下效果图：","text":"在这一章节，我们将开始在Android上做一个IOS风格的UISwitch控件。这篇文章主要涉及如下知识点： Android属性动画Animator 自定义手势GestureDetector 自定义View属性attrs 首先，让我们来看一下效果图： 自定义View属性 接下来，我们要先新建IOSSwitchView类，继承自View类，重写其构造方法，代码如下： /** * 高仿IOS风格的UISwitchView * Created by HanHailong on 15/10/15. */ public class IOSSwitchView extends View { public IOSSwitchView(Context context) { this(context, null); } public IOSSwitchView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public IOSSwitchView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(context, attrs); } } 然后，自定义我们需要的View属性，代码如下： &lt;declare-styleable name=\"IOSSwitchView\"&gt; &lt;attr name=\"tintColor\" format=\"reference|color\" /&gt; &lt;attr name=\"thumbTintColor\" format=\"reference|color\" /&gt; &lt;attr name=\"strokeWidth\" format=\"reference|dimension\" /&gt; &lt;attr name=\"isOn\" format=\"reference|boolean\" /&gt; &lt;/declare-styleable&gt; 其中，tintColor是Switch控件选中的颜色，，thumbTintColor是里面可拖动开关扳手的颜色，，strokeWidth是开关扳手的外边距宽度，isOn是开关的打开状态，true是打开状态，false是关闭状态。 代码里怎么接收在布局里设置的属性值呢？答案：TypedArray，我们继续看代码： TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.IOSSwitchView); mTintColor = a.getColor(R.styleable.IOSSwitchView_tintColor, Color.GREEN); mThumbTintColor = a.getColor(R.styleable.IOSSwitchView_thumbTintColor, Color.WHITE); int defaultStrokeWidth = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 1.5f, context.getResources() .getDisplayMetrics()); mStrokeWidth = a.getDimensionPixelOffset(R.styleable.IOSSwitchView_strokeWidth, defaultStrokeWidth); isOn = a.getBoolean(R.styleable.IOSSwitchView_isOn, false); 上面的代码都很简单，都是自定义View常规的步骤，接下来我们再看添加动画的代码，看我们的gif效果图，你会发现，中间的开关把手在你手指点击它（此时没松手）的时候，它会有一个拉伸的动画，松手的时候，它会移动到另一侧，所以我们这里需要两个属性动画，一个是：拉伸动画，一个是移动动画。另外，因为我们这里有个背景颜色的变化：在默认关闭的情况下，背景色是灰白色的，打开的情况下是我们设置的tintColor颜色的，这里我们采用的是画了两个圆角矩形实现的，先画的tintColor颜色的圆角矩形，后画的灰白色的圆角矩形，刚开始开关关闭的时候灰白色的圆角矩形完全覆盖在上面，此时它的大小和它下面的矩形大小是一样的，之后在我们打开开关thumb的时候，灰白色的圆角矩形大小变成0，这样我们就看到tintColor颜色的圆角矩形了，这就实现了我们的背景切换。所以，这里又加了一个属性动画：灰白色圆角矩形的放大缩小动画。介绍到这里，我们总算理清了，我们要实现三个动画：一个thumb拉伸动画、一个thumb位移动画、一个灰白色圆角矩形形变动画（放大缩小动画）。这里我们添加初始化动画代码： //灰白色矩形形变动画 mInnerContentAnimator = ObjectAnimator.ofFloat(this, new Property&lt;IOSSwitchView, Float&gt;(Float.class, \"innerbound\") { @Override public void set(IOSSwitchView object, Float value) { object.setInnerContentRate(value); } @Override public Float get(IOSSwitchView object) { return object.getInnerContentRate(); } }, innerContentRate, 1.0f); mInnerContentAnimator.setDuration(300); mInnerContentAnimator.setInterpolator(new DecelerateInterpolator()); //thumb拉伸动画 mThumbExpandAnimator = ObjectAnimator.ofFloat(this, new Property&lt;IOSSwitchView, Float&gt;(Float.class, \"thumbExpand\") { @Override public void set(IOSSwitchView object, Float value) { object.setThumbExpandRate(value); } @Override public Float get(IOSSwitchView object) { return object.getThumbExpandRate(); } }, thumbExpandRate, 1.0f); mThumbExpandAnimator.setDuration(300); mThumbExpandAnimator.setInterpolator(new DecelerateInterpolator()); //thumb位移动画 mThumbMoveAnimator = ObjectAnimator.ofFloat(this, new Property&lt;IOSSwitchView, Float&gt;(Float.class, \"thumbMove\") { @Override public void set(IOSSwitchView object, Float value) { object.setThumbMoveRate(value); } @Override public Float get(IOSSwitchView object) { return object.getThumbMoveRate(); } }, thumbMoveRate, 1.0f); mThumbMoveAnimator.setDuration(300); mThumbMoveAnimator.setInterpolator(new DecelerateInterpolator()); 初始化完三个属性动画后，我们下一步就该初始化滑动手势了，因为我们的IOSSwitchView支持thumb滑动而改变打开关闭状态，所以我们要添加支持滑动手势GestureDetector代码： //手势 mGestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() { @Override public boolean onDown(MotionEvent e) { if (!isEnabled()) return false; preIsOn = isOn; //灰白色矩形缩小到0 mInnerContentAnimator.setFloatValues(innerContentRate, 0.0f); mInnerContentAnimator.start(); //thumb有个拉伸的动作 mThumbExpandAnimator.setFloatValues(thumbExpandRate, 1.0f); mThumbExpandAnimator.start(); return true; } @Override public boolean onSingleTapUp(MotionEvent e) { //手指抬起执行一系列的动画 isOn = thumbState; if (preIsOn == isOn) {//反转 isOn = !isOn; thumbState = !thumbState; } //打开状态 if (thumbState) { //thumb移动到右侧打开区域 mThumbMoveAnimator.setFloatValues(thumbMoveRate, 1.0F); mThumbMoveAnimator.start(); //灰白色圆角矩形缩小到0 mInnerContentAnimator.setFloatValues(innerContentRate, 0.0F); mInnerContentAnimator.start(); } else {//关闭状态 //thumb移动到左侧关闭区域 mThumbMoveAnimator.setFloatValues(thumbMoveRate, 0.0F); mThumbMoveAnimator.start(); //灰白色圆角矩形放大到覆盖背景大小 mInnerContentAnimator.setFloatValues(innerContentRate, 1.0F); mInnerContentAnimator.start(); } //thumb恢复原大小 mThumbExpandAnimator.setFloatValues(thumbExpandRate, 0.0F); mThumbExpandAnimator.start(); if (mOnSwitchStateChangeListener != null &amp;&amp; preIsOn != isOn) { mOnSwitchStateChangeListener.onStateSwitched(isOn); } return true; } @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) { //在打开开关的区域 if (e2.getX() &gt; centerX) { //并且开关状态是关闭的，就执行打开开关操作 if (!thumbState) { thumbState = !thumbState; mThumbMoveAnimator.setFloatValues(thumbMoveRate, 1.0F); mThumbMoveAnimator.start(); mInnerContentAnimator.setFloatValues(innerContentRate, 0.0F); mInnerContentAnimator.start(); } } else {//在关闭区域 //开关处于打开状态 if (thumbState) { thumbState = !thumbState; //执行关闭开关动画 mThumbMoveAnimator.setFloatValues(thumbMoveRate, 0.0F); mThumbMoveAnimator.start(); } } return true; } }); //禁止长按 mGestureDetector.setIsLongpressEnabled(false); 因为OnGestureListener里面的方法没必要都实现，我们这用的是它的子静态类SimpleOnGestureListener，我们重写了里面的onDown、onSingleTapUp、onScroll方法。 onDown方法的作用就是在按下控件的时候，thumb执行一个拉伸动画，灰白色圆角矩形则执行缩小到0的动画。如下图所示：onSingleTapUp则是单点抬起手指后执行的操作，这里执行的就是开关互斥动画和互斥逻辑，之前如果是打开的状态，就变成关闭状态，相反则反之。。。onScroll方法则是手指滑动时的坐标大于中间X时则执行一个选中动画，相反则反之…手势识别添加完后，我们为了保证控件有一个好的UI效果展示，一般指控件的宽度和高度保持一个比例，我们重写其onMeasure方法，添加如下代码： @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); //测量宽度和高度 width = MeasureSpec.getSize(widthMeasureSpec); height = MeasureSpec.getSize(heightMeasureSpec); //保持一定的宽高比例 if ((float) height / (float) width &lt; 0.5f) { height = (int) (width 0.5); heightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.getMode(heightMeasureSpec)); widthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.getMode(widthMeasureSpec)); super.setMeasuredDimension(widthMeasureSpec, heightMeasureSpec); } centerX = width 0.5f; centerY = height 0.5f; cornerRadius = centerY; innerContentRectF.left = mStrokeWidth; innerContentRectF.top = mStrokeWidth; innerContentRectF.right = width - mStrokeWidth; innerContentRectF.bottom = height - mStrokeWidth; intrinsicInnerWidth = innerContentRectF.width(); intrinsicInnerHeight = innerContentRectF.height(); thumbRectF.left = mStrokeWidth; thumbRectF.top = mStrokeWidth; thumbRectF.right = width - mStrokeWidth; thumbRectF.bottom = height - mStrokeWidth; intrinsicThumbWidth = thumbRectF.height(); //thumb最大拉伸宽度 thumbMaxExpandWidth = width 0.7f; if (thumbMaxExpandWidth &gt; intrinsicThumbWidth 1.25f) { thumbMaxExpandWidth = intrinsicThumbWidth 1.25f; } }测量完后，我们就开始执行最后一步也是最重要的一步：将控件画到画布canvas上，我们重写onDraw方法： @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); float w = intrinsicInnerWidth 0.5f innerContentRate; float h = intrinsicInnerHeight 0.5f innerContentRate; this.innerContentRectF.left = centerX - w; this.innerContentRectF.top = centerY - h; this.innerContentRectF.right = centerX + w; this.innerContentRectF.bottom = centerY + h; //thumb拉伸宽度变化，其变化值从1-&gt;1.7之间 w = intrinsicThumbWidth + (thumbMaxExpandWidth - intrinsicThumbWidth) thumbExpandRate; boolean left = thumbRectF.left + thumbRectF.width() 0.5f &lt; centerX; if (left) { thumbRectF.left = thumbRectF.right - w; } else { thumbRectF.right = thumbRectF.left + w; } float kw = thumbRectF.width(); w = (float) (width - kw - (mStrokeWidth 2)) thumbMoveRate; thumbRectF.left = mStrokeWidth + w; thumbRectF.right = thumbRectF.left + kw; //颜色值过渡变化，从深灰白色变化到tintColor色 this.colorStep = transformRGBColor(thumbMoveRate, backgroundColor, mTintColor); //画TintColor颜色的圆角矩形 mPaint.setColor(colorStep); mPaint.setStyle(Paint.Style.FILL_AND_STROKE); drawRoundRect(0, 0, width, height, cornerRadius, canvas, mPaint); mPaint.setColor(foregroundColor); //画灰白色圆角矩形 canvas.drawRoundRect(innerContentRectF, innerContentRectF.height() 0.5f, innerContentRectF.height() 0.5f, mPaint); //画thumb mPaint.setColor(mThumbTintColor); canvas.drawRoundRect(thumbRectF, cornerRadius, cornerRadius, mPaint); mPaint.setColor(0xFFCCCCCC); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(1); canvas.drawRoundRect(thumbRectF, cornerRadius, cornerRadius, mPaint); }onDraw方法执行了四步绘制：四次绘制圆角矩形，第一次绘制背景tintColor颜色的圆角矩形，第二次绘制灰白色覆盖在上面的圆角矩形，第三次绘制thumb，第四次绘制一个空心的圆角矩形，这个是为了加深thumb和周围的颜色区分。其中，里面有个方法 transformRGBColor /** * RGB颜色过渡变化 * * @param progress * @param fromColor * @param toColor * @return */ private int transformRGBColor(float progress, int fromColor, int toColor) { int fr = (fromColor &gt;&gt; 16) &amp; 0xFF; int fg = (fromColor &gt;&gt; 8) &amp; 0xFF; int fb = fromColor &amp; 0xFF; int tr = (toColor &gt;&gt; 16) &amp; 0xFF; int tg = (toColor &gt;&gt; 8) &amp; 0xFF; int tb = toColor &amp; 0xFF; int rGap = (int) ((float) (tr - fr) * progress); int gGap = (int) ((float) (tg - fg) * progress); int bGap = (int) ((float) (tb - fb) * progress); return 0xFF000000 | ((fr + rGap) &lt;&lt; 16) | ((fg + gGap) &lt;&lt; 8) | (fb + bGap); } 为了将状态变化值传递给页面，一般指的是Activity、Fragment、View，我们需要定义一个接口： /** * SwitchView状态切换 */ public static interface OnSwitchStateChangeListener { /** * 是否选中 * * @param isOn */ public void onStateSwitched(boolean isOn); } 里面的一些细节这里就不讲了，最后怎么使用呢？分两步： 第一步：布局xml &lt;com.hhl.library.IOSSwitchView android:id=\"@+id/switch_view\" android:layout_width=\"55dp\" android:layout_height=\"35dp\" android:layout_gravity=\"center\" app:thumbTintColor=\"#fff\" app:tintColor=\"#00ff00\" /&gt; 第二步：代码 mSwitchView = (IOSSwitchView) findViewById(R.id.switch_view); mStatusTv = (TextView) findViewById(R.id.tv_status); mSwitchView.setOnSwitchStateChangeListener(new IOSSwitchView.OnSwitchStateChangeListener() { @Override public void onStateSwitched(boolean isOn) { if (isOn) { mStatusTv.setText(\"状态：开\"); } else { mStatusTv.setText(\"状态：关\"); } } }); 最后，附上源码：github-IOSSwitchView","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"RxBus—通过RxJava来替换EventBus","slug":"RxBus—通过RxJava来替换EventBus","date":"2015-10-09T15:25:07.000Z","updated":"2015-10-10T02:18:49.000Z","comments":true,"path":"2015/10/09/RxBus—通过RxJava来替换EventBus/","link":"","permalink":"http://hanhailong.com/2015/10/09/RxBus—通过RxJava来替换EventBus/","excerpt":"前言 RxJava有多火？看看Github上star数量就知道了，那什么是RxJava呢？ RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。 换一种说法，RxJava 是一个响应式编程框架，采用观察者设计模式。所以自然少不了 Observable 和 Subscriber 这两个东东了。","text":"前言 RxJava有多火？看看Github上star数量就知道了，那什么是RxJava呢？ RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。 换一种说法，RxJava 是一个响应式编程框架，采用观察者设计模式。所以自然少不了 Observable 和 Subscriber 这两个东东了。 而针对Android，则有一个基于RxJava的RxAndroid 甚至Jake Wharton大神还基于RxJava写了一个针对Android平台的binding apiRxBinding 而这篇博文讲的就是基于RxJava实现的一个Event Bus-&gt;RxBus 懂得Android的开发者都知道，目前Android上最火的两个Event Bus库是Otto和Green Robot’sEventBus，两个事件总线库写的都非常不错。不过这里不是讲事件总线，而是讲如何通过RxJava来实现事件总线的效果。 总体来说，代码非常的简单，十几行代码就搞定了！ 首先，我们来定义一个RxBus单例类： 123456789101112131415161718192021222324252627282930313233343536import rx.Observable;import rx.subjects.PublishSubject;import rx.subjects.SerializedSubject;import rx.subjects.Subject;/** * Created by HanHailong on 15/10/9. */public class RxBus &#123; private static volatile RxBus mDefaultInstance; private RxBus() &#123; &#125; public static RxBus getDefault() &#123; if (mDefaultInstance == null) &#123; synchronized (RxBus.class) &#123; if (mDefaultInstance == null) &#123; mDefaultInstance = new RxBus(); &#125; &#125; &#125; return mDefaultInstance; &#125; private final Subject&lt;Object, Object&gt; _bus = new SerializedSubject&lt;&gt;(PublishSubject.create()); public void send(Object o) &#123; _bus.onNext(o); &#125; public Observable&lt;Object&gt; toObservable() &#123; return _bus; &#125;&#125; 代码非常的简单，使用呢？则更简单了，一般来讲，事件总线，包括一个发送事件和多个接收事件。 先看发送事件的代码： 1RxBus.getDefault().send(new TapEvent()); 而在你想接收事件的地方，只需要加上下面代码就可以了： 12345678910RxBus.getDefault().toObservable().subscribe(new Action1&lt;Object&gt;() &#123; @Override public void call(Object event) &#123; if (event instanceof TapEvent) &#123; //do something &#125;else if(event instanceof otherEvent)&#123; //do otherthing &#125; &#125; &#125;); 这样，一个简单的Event Bus就实现了！如果你的项目已经开始使用RxJava，建议可以把Otto和Green Robot’sEventBus去掉了，直接使用RxBus！！ 当然，不要忘了在build.gradle引入RxJava和RxAndroid： compile 'io.reactivex:rxandroid:1.0.1' compile 'io.reactivex:rxjava:1.0.14'","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"},{"name":"RxAndroid","slug":"RxAndroid","permalink":"http://hanhailong.com/tags/RxAndroid/"},{"name":"RxJava","slug":"RxJava","permalink":"http://hanhailong.com/tags/RxJava/"}]},{"title":"Hexo—添加百度统计代码","slug":"Hexo—添加百度统计代码","date":"2015-10-08T15:31:31.000Z","updated":"2015-10-08T16:05:53.000Z","comments":true,"path":"2015/10/08/Hexo—添加百度统计代码/","link":"","permalink":"http://hanhailong.com/2015/10/08/Hexo—添加百度统计代码/","excerpt":"","text":"本博客采用的是Yilia主题，这里就以Yilia讲解为例，首先你要去百度统计注册账号，并获取到相关的百度统计代码： 编辑文件themes/yilia/_config.yml，添加一行配置代码： baidu_tongji: true 新建文件themes/yilia/layout/_partial/baidu_tongji.ejs，内容如下： &lt;% if (theme.baidu_tongji) { %&gt; &lt;script type=\"text/javascript\"&gt; #申请的百度统计代码 &lt;/script&gt; &lt;% } %&gt; 编辑themes/yilia/layout/_partial/head.ejs文件，在&lt;/head&gt;之前添加代码： &lt;%- partial(\"baidu_tongji\") %&gt; 重新部署发布，搞定睡觉！！！","categories":[],"tags":[{"name":"Hexo主题","slug":"Hexo主题","permalink":"http://hanhailong.com/tags/Hexo主题/"}]},{"title":"Hexo—正确添加RSS订阅","slug":"Hexo—正确添加RSS订阅","date":"2015-10-08T13:07:13.000Z","updated":"2015-10-08T13:51:57.000Z","comments":true,"path":"2015/10/08/Hexo—正确添加RSS订阅/","link":"","permalink":"http://hanhailong.com/2015/10/08/Hexo—正确添加RSS订阅/","excerpt":"看到别人的博客都有RSS订阅功能，就想着给自己的博客也添加RSS订阅功能。 看网上的教程，写的不是很详细，都是很简单的一句话。而我按照网上的教程愣是没整出来。真是验证了一句古话：尽信书不如无书 最后，终于让我整出来了，特此把完整的过程记录一下：","text":"看到别人的博客都有RSS订阅功能，就想着给自己的博客也添加RSS订阅功能。 看网上的教程，写的不是很详细，都是很简单的一句话。而我按照网上的教程愣是没整出来。真是验证了一句古话：尽信书不如无书 最后，终于让我整出来了，特此把完整的过程记录一下： 先看下整出来的效果图： 首先，先安装hexo-generator-feed $ npm install hexo-generator-feed --save 安装完后，会在node_modules目录下生成hexo-generator-feed目录，如图： 安装完hexo-generator-feed后，将其配置到根目录的_config.yml # Extensions ## Plugins: http://hexo.io/plugins/ #RSS订阅 plugin: - hexo-generator-feed #Feed Atom feed: type: atom path: atom.xml limit: 20 其中，feed是可选项，可配可不配！ 最后，在你当前主题下的_config.yml下，添加RSS订阅链接即可，这里我用的是Yilia主题，subnav下添加rss： # SubNav subnav: rss: \"/atom.xml\" 添加之后，运行hexo g后，就会在页面上生成RSS图标，如下图：","categories":[],"tags":[{"name":"Hexo主题","slug":"Hexo主题","permalink":"http://hanhailong.com/tags/Hexo主题/"}]},{"title":"不错的学习技术博客之三—泡在网上的日子","slug":"不错的学习技术博客之三—泡在网上的日子","date":"2015-10-08T08:19:33.000Z","updated":"2015-10-08T08:27:38.000Z","comments":true,"path":"2015/10/08/不错的学习技术博客之三—泡在网上的日子/","link":"","permalink":"http://hanhailong.com/2015/10/08/不错的学习技术博客之三—泡在网上的日子/","excerpt":"","text":"这是不错的学习技术博客系列第三篇，泡在网上的日子上面的技术博客质量都非常高，文章内容非常广泛，不仅包括Android和IOS，还包括Html5/css3、JS、java、php等，甚至还包括设计模式和算法。 还有就是包括代码，里面的代码大部分都托管在github上面，这里做了比较详细的系统分类，总体做的非常不错，我经常去上面浏览学习！！！","categories":[],"tags":[{"name":"技术博客","slug":"技术博客","permalink":"http://hanhailong.com/tags/技术博客/"}]},{"title":"Android-内存优化之图片优化","slug":"Android-内存优化之图片优化","date":"2015-10-06T12:21:39.000Z","updated":"2015-10-06T12:41:12.000Z","comments":true,"path":"2015/10/06/Android-内存优化之图片优化/","link":"","permalink":"http://hanhailong.com/2015/10/06/Android-内存优化之图片优化/","excerpt":"网上有很多大拿分享的关于Android性能优化的文章，主要是通过各种工具分析，使用合理的技巧优化APP的体验，提升APP的流畅度，但关于内存优化的文章很少有看到。在Android设备内存动不动就上G的情况下，的确没有必要去太在意APP对Android系统内存的消耗，但在实际工作中我做的是教育类的小学APP，APP中的按钮、背景、动画变换基本上全是图片，在2K屏上（分辨率2048*1536）一张背景图片就会占用内存12M，来回切换几次内存占用就会增涨到上百兆，为了在不影响APP的视觉效果的前提下，有必要通过各种手段来降低APP对内存的消耗，下面是我在实践过程中使用的一些方法，很多都是不太成熟的项目，也不够深入，只是将其作为一种处理方式分享给大家。","text":"网上有很多大拿分享的关于Android性能优化的文章，主要是通过各种工具分析，使用合理的技巧优化APP的体验，提升APP的流畅度，但关于内存优化的文章很少有看到。在Android设备内存动不动就上G的情况下，的确没有必要去太在意APP对Android系统内存的消耗，但在实际工作中我做的是教育类的小学APP，APP中的按钮、背景、动画变换基本上全是图片，在2K屏上（分辨率2048*1536）一张背景图片就会占用内存12M，来回切换几次内存占用就会增涨到上百兆，为了在不影响APP的视觉效果的前提下，有必要通过各种手段来降低APP对内存的消耗，下面是我在实践过程中使用的一些方法，很多都是不太成熟的项目，也不够深入，只是将其作为一种处理方式分享给大家。 通过DDMS的APP内存占用查看工具分析发现，APP中占用内存最多的是图片，每个Activity中图片占用内存占大半，本文重点分享对图片的内存优化。 不要将Button的背景设置为selector 在布局文件和代码中，都可以为Button设置background为selector，这样方便实现按钮的正反选效果，但实际跟踪发现，如果是将Button的背景设置为selector，在初始化Button的时候会将正反选图片都加载在内存中（具体可以查看Android源码，在类Drawable.java的createFromXmlInner方法中对图片进行解析，最终调用Drawable的inflate方法），相当于一个按钮占用了两张相同大小图片所使用的内存，如果一个界面上按钮很多或者是按钮很大，光是按钮占用的内存就会很大，可以通过在布局文件中给按钮只设置正常状态下的背景图片，然后在代码中监听按钮的点击状态，当按下按钮时为按钮设置反选效果的图片，抬起时重新设置为正常状态下的背景，具体实现方式如下： public class ImageButtonClickUtils { private ImageButtonClickUtils(){ } /** * 设置按钮的正反选效果 * * */ public static void setClickState(View view, final int normalResId, final int pressResId){ view.setOnTouchListener(new OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { switch(event.getAction()){ case MotionEvent.ACTION_DOWN:{ v.setBackgroundResource(pressResId); } break; case MotionEvent.ACTION_MOVE:{ v.setBackgroundResource(pressResId); } break; case MotionEvent.ACTION_UP:{ v.setBackgroundResource(normalResId); } break; default:{ } break; } // 为了不影响监听按钮的onClick回调，返回值应为false return false; } }); } } 通过上面这种方式就可以解决同一个按钮占用两倍内存的问题，如果你觉得为一个按钮提供正反选两张图片会导致APK的体积变大，可以通过如下方式实现按钮点击的反选效果，这种方式既不会存在Button占用两倍内存的情况，又减小了APK的体积（Android 5.0中的tintColor也可以实现类似的效果）： ImageButton personalInfoBtn = (ImageButton)findViewById(R.id.personalBtnId); personalInfoBtn.setOnTouchListener(new OnTouchListener() { @SuppressLint(\"ClickableViewAccessibility\") @Override public boolean onTouch(View v, MotionEvent event) { int action = event.getAction(); if(action == MotionEvent.ACTION_DOWN){ ((ImageButton)v).setColorFilter(getResources().getColor(0X50000000)); }else if(action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL){ ((ImageButton)v).clearColorFilter(); } // 为了不影响监听按钮的onClick回调，返回值应为false return false; } }); 将背景图片放在非UI线程绘制，提升APP的效率 在高分辨率的平板设备上，绘制大背景的图片会影响程序的运行效率，严重情况下就和没有开硬件加速的时候使用手写功能一样，相当地卡，最后我们的解决方案是将背景图片通过SurfaceView来绘制，这样相当于是在非UI线程绘制，不会影响到UI线程做其它事情： import android.content.Context; import android.content.res.TypedArray; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.graphics.Canvas; import android.graphics.Matrix; import android.graphics.PixelFormat; import android.util.AttributeSet; import android.util.DisplayMetrics; import android.view.SurfaceHolder; import android.view.SurfaceView; import com.hhl.activity.R; public class RootSurfaceView extends SurfaceView implements SurfaceHolder.Callback, Runnable{ private float mViewWidth = 0; private float mViewHeight = 0; private int mResourceId = 0; private Context mContext = null; private volatile boolean isRunning = false; private SurfaceHolder mSurfaceHolder = null; public RootSurfaceView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); initRootSurfaceView(context, attrs, defStyleAttr, 0); } public RootSurfaceView(Context context, AttributeSet attrs) { super(context, attrs); initRootSurfaceView(context, attrs, 0, 0); } private void initRootSurfaceView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes){ mContext = context; DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics(); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RootSurfaceView, defStyleAttr, defStyleRes); int n = a.getIndexCount(); mViewWidth = displayMetrics.widthPixels; mViewHeight = displayMetrics.heightPixels; for(int index=0; index&lt;n; index++){ int attr = a.getIndex(index); switch(attr){ case R.styleable.RootSurfaceView_background:{ mResourceId = a.getResourceId(attr, 0); } break; case R.styleable.RootSurfaceView_view_width:{ mViewWidth = a.getDimension(attr, displayMetrics.widthPixels); } break; case R.styleable.RootSurfaceView_view_height:{ mViewHeight = a.getDimension(attr, displayMetrics.heightPixels); } break; default:{ } break; } } a.recycle(); mSurfaceHolder = getHolder(); mSurfaceHolder.addCallback(this); mSurfaceHolder.setFormat(PixelFormat.TRANSLUCENT); } private Bitmap getDrawBitmap(Context context, float width, float height) { Bitmap bitmap = BitmapFactory.decodeResource(getResources(), mResourceId); Bitmap resultBitmap = zoomImage(bitmap, width, height); return resultBitmap; } @Override public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3) { System.out.println(\"RootSurfaceView surfaceChanged\"); } @Override public void surfaceCreated(SurfaceHolder holder) { drawBackGround(holder); System.out.println(\"RootSurfaceView surfaceCreated\"); } @Override public void surfaceDestroyed(SurfaceHolder holder) { isRunning = false; System.out.println(\"RootSurfaceView surfaceDestroyed\"); } @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); System.out.println(\"RootSurfaceView onAttachedToWindow\"); } @Override protected void onDetachedFromWindow() { super.onDetachedFromWindow(); System.out.println(\"RootSurfaceView onDetachedFromWindow\"); } @Override public void run(){ while(isRunning){ synchronized (mSurfaceHolder) { if(!mSurfaceHolder.getSurface().isValid()){ continue; } drawBackGround(mSurfaceHolder); } isRunning = false; break; } } private void drawBackGround(SurfaceHolder holder) { Canvas canvas = holder.lockCanvas(); Bitmap bitmap = getDrawBitmap(mContext, mViewWidth, mViewHeight); canvas.drawBitmap(bitmap, 0, 0, null); bitmap.recycle(); holder.unlockCanvasAndPost(canvas); } public static Bitmap zoomImage( Bitmap bgimage , float newWidth , float newHeight ) { float width = bgimage.getWidth( ); float height = bgimage.getHeight( ); Matrix matrix = new Matrix(); float scaleWidth = newWidth/width; float scaleHeight = newHeight/height; matrix.postScale( scaleWidth, scaleHeight ); Bitmap bitmap = Bitmap.createBitmap( bgimage, 0, 0, ( int ) width , ( int ) height, matrix, true ); if( bitmap != bgimage ){ bgimage.recycle(); bgimage = null; } return bitmap; } } 在res/values/attr.xml文件中定义自定义View的自定义属性： &lt;declare-styleable name=\"RootSurfaceView\"&gt; &lt;attr name=\"background\" format=\"reference\" /&gt; &lt;attr name=\"view_width\" format=\"dimension\" /&gt; &lt;attr name=\"view_height\" format=\"dimension\" /&gt; &lt;/declare-styleable&gt; 没有必要使用硬件加速的界面建议关掉硬件加速 通过DDMS的heap跟踪发现，相比于关闭硬件加速，在打开硬件加速的情况下会消耗更多的内存，但有的界面打开或者关闭硬件加速对程序的运行效率并没有太大的影响，此种情况下可以考虑在AndroidManifest.xml文件中关闭掉对应Activity的硬件加速，like this： &lt;!-- 设置界面 --&gt; &lt;activity android:name=\".SettingActivity\" android:hardwareAccelerated=\"false\" android:screenOrientation=\"sensorLandscape\"&gt; &lt;/activity&gt; 注意：如果使用到WebView、视频播放、手写、动画等功能时，关掉硬件加速会严重音效程序的运行效率，这种情况可以只关闭掉Activity中某些view的硬件加速，整个Activity的硬件加速不关闭。 如果Activity中某个View需要关闭硬件加速，但整个Activity不能关闭，可以调用view层级关闭硬件加速的方法： // view.setLayerType || 在定义view的构造方法中调用该方法 setLayerType(View.LAYER_TYPE_SOFTWARE, null); 尽量少用AnimationDrawable，如果必须要可以自定义图片切换器代替AnimationDrawable AnimationDrawable也是一个耗内存大户，图片帧数越多耗内存越大，具体可以查看AnimationDrawable的源码，在AnimationDrawable实例化的时候，Drawable的createFromXmlInner方法会调用AnimationDrawable的inflate方法，该方法里面有一个while循环去一次性将所有帧都读取出来，也就是在初始化的时候就将所有的帧读在内存中了，有多少张图片，它就要消耗对应大小的内存。 虽然可以通过如下方式释放AnimationDrawable占用的内存，但是当退出使用AnimationDrawable的界面，再次进入使用其播放动画时，会报使用已经回收了的图片的异常，这个应该是Android对图片的处理机制导致的，虽然Activity被finish掉了，但是这个Activity中使用到的图片还是在内存中，如果被回收，下次进入时就会报异常信息： /** * 释放AnimationDrawable占用的内存 * * * */ @SuppressWarnings(\"unused\") private void freeAnimationDrawable(AnimationDrawable animationDrawable) { animationDrawable.stop(); for (int i = 0; i &lt; animationDrawable.getNumberOfFrames(); ++i){ Drawable frame = animationDrawable.getFrame(i); if (frame instanceof BitmapDrawable) { ((BitmapDrawable)frame).getBitmap().recycle(); } frame.setCallback(null); } animationDrawable.setCallback(null); } 通常情况下我会自定义一个ImageView来实现AnimationDrawable的功能，根据图片之间切换的时间间隔来定时设置ImageView的背景图片，这样始终只是一个ImageView实例，更换的只是其背景，占用内存会比AnimationDrawable小很多： /** * 图片动态切换器 * * */ public class AnimImageView { private static final int MSG_START = 0xf1; private static final int MSG_STOP = 0xf2; private static final int STATE_STOP = 0xf3; private static final int STATE_RUNNING = 0xf4; /* 运行状态*/ private int mState = STATE_RUNNING; private ImageView mImageView; /* 图片资源ID列表*/ private List&lt;Integer&gt; mResourceIdList = null; /* 定时任务*/ private Timer mTimer = null; private AnimTimerTask mTimeTask = null; /* 记录播放位置*/ private int mFrameIndex = 0; /* 播放形式*/ private boolean isLooping = false; public AnimImageView( ){ mTimer = new Timer(); } /** * 设置动画播放资源 * * */ public void setAnimation( HanziImageView imageview, List&lt;Integer&gt; resourceIdList ){ mImageView = imageview; mResourceIdList = resourceIdList; } /** * 开始播放动画 * @param loop 时候循环播放 * @param duration 动画播放时间间隔 * */ public void start(boolean loop, int duration){ stop(); isLooping = loop; mFrameIndex = 0; mState = STATE_RUNNING; mTimeTask = new AnimTimerTask( ); mTimer.schedule(mTimeTask, 0, duration); } /** * 停止动画播放 * * */ public void stop(){ if (mTimeTask != null) { mFrameIndex = 0; mState = STATE_STOP; mTimer.purge(); mTimeTask.cancel(); mTimeTask = null; mImageView.setBackgroundResource(0); } } /** * 定时器任务 * * */ class AnimTimerTask extends TimerTask { @Override public void run() { if(mFrameIndex &lt; 0 || mState == STATE_STOP){ return; } if( mFrameIndex &lt; mResourceIdList.size() ){ Message msg = AnimHanlder.obtainMessage(MSG_START,0,0,null); msg.sendToTarget(); }else{ mFrameIndex = 0; if(!isLooping){ Message msg = AnimHanlder.obtainMessage(MSG_STOP,0,0,null); msg.sendToTarget(); } } } } private Handler AnimHanlder = new Handler(){ public void handleMessage(android.os.Message msg) { switch (msg.what) { case MSG_START:{ if(mFrameIndex &gt;=0 &amp;&amp; mFrameIndex &lt; mResourceIdList.size() &amp;&amp; mState == STATE_RUNNING){ mImageView.setImageResource(mResourceIdList.get(mFrameIndex)); mFrameIndex++; } } break; case MSG_STOP:{ if (mTimeTask != null) { mFrameIndex = 0; mTimer.purge(); mTimeTask.cancel(); mState = STATE_STOP; mTimeTask = null; mImageView.setImageResource(0); } } break; default: break; } } }; } 其它优化方式 尽量将Activity中的小图片和背景合并，一张小图片既浪费布局的时间，又平白地增加了内存占用； 不要在Activity的主题中为Activity设置默认的背景图片，这样会导致Activity占用的内存翻倍： &lt;!--千万不要在主题中为Activity设置默认背景--&gt; &lt;style name=\"Activity_Style\" parent=\"@android:Theme.Holo.Light.NoActionBar\"&gt; &lt;item name=\"android:background\"&gt;@drawable/*&lt;/item&gt; &lt;/style&gt; 对于在需要时才显示的图片或者布局，可以使用ViewStub标签，通过sdk/tools目录下的hierarchyviewer.bat查看布局文件会发现，使用viewstub标签的组件几乎不消耗布局的时间，在代码中当需要显示时再去实例化有助于提高Activity的布局效率和节省Activity消耗的内存。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"不错的学习技术博客之二————trinea.cn","slug":"不错的学习技术博客之二————trinea-cn","date":"2015-10-06T03:14:05.000Z","updated":"2015-10-06T03:28:28.000Z","comments":true,"path":"2015/10/06/不错的学习技术博客之二————trinea-cn/","link":"","permalink":"http://hanhailong.com/2015/10/06/不错的学习技术博客之二————trinea-cn/","excerpt":"","text":"这是不错的学习技术博客系列第二篇，trinea这个技术博客主要记录Android和Java方面的技术文章，侧重点在于性能调优、开源项目经验分享、新技术调研等等，而作者本身编程功底很深，2010年加入阿里巴巴，目前在杭州快的担任移动端架构师！","categories":[],"tags":[{"name":"技术博客","slug":"技术博客","permalink":"http://hanhailong.com/tags/技术博客/"}]},{"title":"不错的学习技术博客之一————美团tech.meituan","slug":"不错的学习技术博客之一————美团tech-meituan","date":"2015-10-06T03:00:14.000Z","updated":"2015-10-06T03:16:58.000Z","comments":true,"path":"2015/10/06/不错的学习技术博客之一————美团tech-meituan/","link":"","permalink":"http://hanhailong.com/2015/10/06/不错的学习技术博客之一————美团tech-meituan/","excerpt":"","text":"之前看过很多的技术博客，美团的教学技术博客还是蛮不错的，之前看过里面的一篇文章美团Android自动化之旅—适配渠道包，讲的真心不错，如果再配合使用Gradle生成一个App的不同版本，且可以同时安装在一个手机上，基本上使用Gradle来构建Android应用就没啥问题了！ 里面的文章讲的透彻清晰！非常值得去学习！","categories":[],"tags":[{"name":"技术博客","slug":"技术博客","permalink":"http://hanhailong.com/tags/技术博客/"}]},{"title":"Android不错的开源库之-ExplosionField（View粒子炸裂效果）","slug":"Android不错的开源库之-ExplosionField（View粒子炸裂效果）","date":"2015-10-06T00:36:16.000Z","updated":"2015-10-06T01:14:31.000Z","comments":true,"path":"2015/10/06/Android不错的开源库之-ExplosionField（View粒子炸裂效果）/","link":"","permalink":"http://hanhailong.com/2015/10/06/Android不错的开源库之-ExplosionField（View粒子炸裂效果）/","excerpt":"前几天微博上出了一个非常优秀的Android开源组件-ExplosionField，效果非常的炫酷，类似MIUI卸载app的动画，先看效果：","text":"前几天微博上出了一个非常优秀的Android开源组件-ExplosionField，效果非常的炫酷，类似MIUI卸载app的动画，先看效果： 我阅读了下源码，代码写的非常的不错，作者的代码功力非常深厚。这里就不赘述了，有需要的可以自己去看。 怎么使用呢？ 在你的build.gradle: dependencies { compile 'tyrantgit:explosionfield:1.0.0' } 在Java代码里： ExplosionField explosionField = ...; explosionField.explode(view);","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"The resource could not be loaded because the App Transport Security policy requires the use of a secure connection","slug":"The-resource-could-not-be-loaded-because-the-App-Transport-Security-policy-requires-the-use-of-a-secure-connection","date":"2015-10-05T01:36:33.000Z","updated":"2015-10-05T02:12:54.000Z","comments":true,"path":"2015/10/05/The-resource-could-not-be-loaded-because-the-App-Transport-Security-policy-requires-the-use-of-a-secure-connection/","link":"","permalink":"http://hanhailong.com/2015/10/05/The-resource-could-not-be-loaded-because-the-App-Transport-Security-policy-requires-the-use-of-a-secure-connection/","excerpt":"最近把Xcode升级到最新正式版7.0.1后，发现所有的项目凡是有http请求的都访问失败了，只有https请求的可以访问成功。报错内容如下：","text":"最近把Xcode升级到最新正式版7.0.1后，发现所有的项目凡是有http请求的都访问失败了，只有https请求的可以访问成功。报错内容如下： Google后查证，iOS9引入了新特性App Transport Security (ATS) 新特性要求App内访问的网络必须使用HTTPS协议。但是现在公司的项目使用的是HTTP协议，使用私有加密方式保证数据安全。现在也不能马上改成HTTPS协议传输。 如果要让ios9支持http访问怎么做呢？我们可以采用如下方式： 在Info.plist中添加使用 NSAppTransportSecurity类型使用 Dictionary 在使用NSAppTransportSecurity下添加使用NSAllowsArbitraryLoads类型Boolean,值设为使用YES 最后，修改完后Info.plist的效果图如下： 经过修改之后再请求网络，发现就正常了！","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://hanhailong.com/tags/IOS/"}]},{"title":"IOS-通过自定义iCarousel来高仿土巴兔选择装修风格效果(中间选中项放大)","slug":"IOS-通过自定义iCarousel来高仿土巴兔选择装修风格效果-中间选中项放大","date":"2015-09-28T10:22:33.000Z","updated":"2015-09-28T11:25:54.000Z","comments":true,"path":"2015/09/28/IOS-通过自定义iCarousel来高仿土巴兔选择装修风格效果-中间选中项放大/","link":"","permalink":"http://hanhailong.com/2015/09/28/IOS-通过自定义iCarousel来高仿土巴兔选择装修风格效果-中间选中项放大/","excerpt":"这是Android-通过自定义ViewPager来高仿土巴兔选择装修风格效果的姐妹篇，上篇通过自定义ViewPager来实现了选中的一项居中并放大的效果，这里通过iCarousel来实现这个效果，iCarousel是我最喜欢的一个IOS开源库之一，我几乎每个IOS项目都用到了它，真的是非常的赞。好了，废话不多说，马上进入主题，在开始之前，先看下我们高仿后的效果图：","text":"这是Android-通过自定义ViewPager来高仿土巴兔选择装修风格效果的姐妹篇，上篇通过自定义ViewPager来实现了选中的一项居中并放大的效果，这里通过iCarousel来实现这个效果，iCarousel是我最喜欢的一个IOS开源库之一，我几乎每个IOS项目都用到了它，真的是非常的赞。好了，废话不多说，马上进入主题，在开始之前，先看下我们高仿后的效果图： 要实现这个效果，总体难度上要比Android上轻松不少，你不需要关心点击左右边缘切换到相应的Item，iCarousel都已经帮你实现了，而且iCarousel的每个View都是支持复用。 总体难点就一个地方，那就是自定义iCarousel，然后设置相应的缩放动画。 首先，我们需要把iCarousel的type值设置成iCarouselTypeCustom，看代码 -(iCarousel *)iCarousel{ CGFloat height = ScreenWidth - 2 *PAGE_OFFSET; if (_iCarousel == nil) { _iCarousel = [[iCarousel alloc] initWithFrame:CGRectMake(0, (ScreenHeight-height)*0.5, ScreenWidth, height)]; _iCarousel.delegate = self; _iCarousel.dataSource = self; _iCarousel.bounces = NO; _iCarousel.pagingEnabled = YES; _iCarousel.type = iCarouselTypeCustom; } return _iCarousel; } 然后，我们设置iCarousel两个必须的代理方法viewForItemAtIndex和numberOfItemsInCarousel，看代码： #pragma mark - iCarousel代理 -(UIView *)carousel:(iCarousel *)carousel viewForItemAtIndex:(NSInteger)index reusingView:(UIView *)view{ if (view == nil) { CGFloat viewWidth = ScreenWidth - 2*PAGE_OFFSET; view = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, viewWidth, viewWidth)]; } ((UIImageView *)view).image = [UIImage imageNamed:[self.dataList objectAtIndex:index]]; return view; } -(NSInteger)numberOfItemsInCarousel:(iCarousel *)carousel{ return self.dataList.count; } 经过上面设置后，我们的iCarousel就加进来了，但是你会发现，加进来的iCarousel不能滑动了，这是什么鬼。。。。 这是为什么呢？这是因为我们有一个非常重要的方法没有实现，这个方法是: -(CATransform3D)carousel:(iCarousel *)carousel itemTransformForOffset:(CGFloat)offset baseTransform:(CATransform3D)transform 这个方法就是整个iCarousel的核心所在，所有的动画效果都是这个方法来实现的 这里稍微讲解下iCarousel的原理： iCarousel不是基于UIScrollView实现的，而是直接继承UIView来实现 iCarousel通过UIPanGestureRecognizer来计算和维护scrollOffset这个变量 iCarousel本身并不会改变itemView的位置 而是靠修改itemView的layer.transform来实现位移和形变 为了实现我们想要中间放大的效果，就必须重写这个方法，看下我们的代码： -(CATransform3D)carousel:(iCarousel *)carousel itemTransformForOffset:(CGFloat)offset baseTransform:(CATransform3D)transform{ static CGFloat max_sacle = 1.0f; static CGFloat min_scale = 0.6f; if (offset &lt;= 1 &amp;&amp; offset &gt;= -1) { float tempScale = offset &lt; 0 ? 1+offset : 1-offset; float slope = (max_sacle - min_scale) / 1; CGFloat scale = min_scale + slope*tempScale; transform = CATransform3DScale(transform, scale, scale, 1); }else{ transform = CATransform3DScale(transform, min_scale, min_scale, 1); } return CATransform3DTranslate(transform, offset * self.iCarousel.itemWidth * 1.4, 0.0, 0.0); } 核心的算法和我们Android版本的是一样的，只不过这里加了这个形变，一个是Scale形变，一个是移动Translate形变。经过上面的代码就实现我们想要的结果了。 小结 总体实现来说，这个要比Android版本的要简单多了，核心代码就是改变layer.transform属性值。 这也说明iCarousel是多么优秀的一个开源库，说到这里，我个人是非常不喜欢重复造轮子的，能用最少的代码达到所需的要求是我一直以来的准则，而且很多经典的轮子库(比如iCarousel)也值得你去深入探索和学习，了解作者的想法和思路(站在巨人的肩膀)是一种非常不错的学习方法和开阔视野的途径。 最后附上源码github","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://hanhailong.com/tags/IOS/"}]},{"title":"Android-通过自定义ViewPager来高仿土巴兔选择装修风格效果","slug":"Android-通过自定义ViewPager来高仿土巴兔选择装修风格效果","date":"2015-09-27T08:30:20.000Z","updated":"2015-09-28T01:38:47.000Z","comments":true,"path":"2015/09/27/Android-通过自定义ViewPager来高仿土巴兔选择装修风格效果/","link":"","permalink":"http://hanhailong.com/2015/09/27/Android-通过自定义ViewPager来高仿土巴兔选择装修风格效果/","excerpt":"最近看到有同事在用土巴兔这个app，看了里面的一些效果非常的不错，就试着模仿了一下，首先模仿的是土巴兔里面一个选择装修风格的效果，先看原版效果图如下：","text":"最近看到有同事在用土巴兔这个app，看了里面的一些效果非常的不错，就试着模仿了一下，首先模仿的是土巴兔里面一个选择装修风格的效果，先看原版效果图如下： 这种效果实现的方式很多，比如HorizonalScrollView、Recyclerview(水平)、ViewPager等等，这里我使用ViewPager来高仿，为啥通过ViewPager来高仿呢，一是ViewPager提供了PageTransformer，很容易的实现切换动画效果，二是ViewPager很容易控制滑动选中的一项居中，这里先看下高仿后的效果图，效果还是很不错的： 要实现这种效果，核心知识点有如下几个： android:clipChildren设置为false，意味着不限制子View在其范围内，也就是说子view可以超出父view的范围 通过PageTransformer来实现缩放动画 拦截点击事件的位置来实现点击切换viewpager，这个为什么要实现，后面再说 下面我们一步一步讲解来实现这个布局效果 定义布局xml &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/page_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@android:color/white\" android:clipChildren=\"false\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" tools:context=\".MainActivity\" tools:showIn=\"@layout/activity_main\"&gt; &lt;com.hhl.tubatu.ClipViewPager android:id=\"@+id/viewpager\" android:layout_width=\"200dp\" android:layout_height=\"200dp\" android:layout_centerInParent=\"true\" android:clipChildren=\"false\" android:overScrollMode=\"never\" /&gt; &lt;/RelativeLayout&gt; 上面的RelativeLayout和自定义的ClipViewPager都各自添加了一个属性android:clipChildren=”false”，clipChildren的意思是是否限制子View在其范围内，这个默认是true，也就是默认是限制子view在其范围的 给ViewPager设置缩放动画，这里通过PageTransformer来实现 mViewPager = (ClipViewPager) findViewById(R.id.viewpager); mViewPager.setPageTransformer(true, new ScalePageTransformer()); 再来看ScalePageTransformer的实现，核心就是实现transformPage(View page, float position)这个方法 /** * Created by HanHailong on 15/9/27. */ public class ScalePageTransformer implements ViewPager.PageTransformer { public static final float MAX_SCALE = 1.2f; public static final float MIN_SCALE = 0.6f; @Override public void transformPage(View page, float position) { if (position &lt; -1) { position = -1; } else if (position &gt; 1) { position = 1; } float tempScale = position &lt; 0 ? 1 + position : 1 - position; float slope = (MAX_SCALE - MIN_SCALE) / 1; //一个公式 float scaleValue = MIN_SCALE + tempScale * slope; page.setScaleX(scaleValue); page.setScaleY(scaleValue); } } 其实核心代码就是这个动画实现部分，这里设置了一个最大缩放和最小缩放比例，当处于最中间的view忘左边滑动时，它的position值是小于0的，并且是越来越小,它右边的view的position是从1逐渐减小到0的。 下面我们看下在Activity的完整实现代码 import android.content.Context; import android.os.Bundle; import android.support.design.widget.FloatingActionButton; import android.support.design.widget.Snackbar; import android.support.v7.app.AppCompatActivity; import android.support.v7.widget.Toolbar; import android.view.Menu; import android.view.MenuItem; import android.view.MotionEvent; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import com.hhl.tubatu.adapter.RecyclingPagerAdapter; import java.util.ArrayList; import java.util.List; public class MainActivity extends AppCompatActivity { private ClipViewPager mViewPager; private TubatuAdapter mPagerAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Snackbar.make(view, \"Replace with your own action\", Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); } }); mViewPager = (ClipViewPager) findViewById(R.id.viewpager); mViewPager.setPageTransformer(true, new ScalePageTransformer()); findViewById(R.id.page_container).setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { return mViewPager.dispatchTouchEvent(event); } }); mPagerAdapter = new TubatuAdapter(this); mViewPager.setAdapter(mPagerAdapter); initData(); } private void initData() { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(R.drawable.style_xiandai); list.add(R.drawable.style_jianyue); list.add(R.drawable.style_oushi); list.add(R.drawable.style_zhongshi); list.add(R.drawable.style_meishi); list.add(R.drawable.style_dzh); list.add(R.drawable.style_dny); list.add(R.drawable.style_rishi); //设置OffscreenPageLimit mViewPager.setOffscreenPageLimit(list.size()); mPagerAdapter.addAll(list); } public static class TubatuAdapter extends RecyclingPagerAdapter { private final List&lt;Integer&gt; mList; private final Context mContext; public TubatuAdapter(Context context) { mList = new ArrayList&lt;&gt;(); mContext = context; } public void addAll(List&lt;Integer&gt; list) { mList.addAll(list); notifyDataSetChanged(); } @Override public View getView(int position, View convertView, ViewGroup container) { ImageView imageView = null; if (convertView == null) { imageView = new ImageView(mContext); } else { imageView = (ImageView) convertView; } imageView.setTag(position); imageView.setImageResource(mList.get(position)); return imageView; } @Override public int getCount() { return mList.size(); } } } 这里需要注意几点，一是 mViewPager.setOffscreenPageLimit(list.size());这里需要将setOffscreenPageLimit的值设置成数据源的总个数，如果不加这句话，会导致左右切换异常；二是需要将整个页面的事件分发给ViewPager，不然的话只有ViewPager中间的view能滑动，其他的都不能滑动，这是肯定的，因为ViewPager总体布局就是中间那一块大小，其他的子布局都跑到ViewPager外面来了。三是你发现ViewPager加了setOnTouchListener方法后，滑动是可以了，但是点击左右两边不能切换，这里需要重写ViewPager的dispatchTouchEvent方法，下面看ClipViewPager代码： package com.hhl.tubatu; import android.content.Context; import android.support.v4.view.ViewPager; import android.util.AttributeSet; import android.view.MotionEvent; import android.view.View; /** * Created by HanHailong on 15/9/27. */ public class ClipViewPager extends ViewPager { public ClipViewPager(Context context) { super(context); } public ClipViewPager(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_UP) { View view = viewOfClickOnScreen(ev); if (view != null) { setCurrentItem(indexOfChild(view)); } } return super.dispatchTouchEvent(ev); } /** * @param ev * @return */ private View viewOfClickOnScreen(MotionEvent ev) { int childCount = getChildCount(); int[] location = new int[2]; for (int i = 0; i &lt; childCount; i++) { View v = getChildAt(i); v.getLocationOnScreen(location); int minX = location[0]; int minY = getTop(); int maxX = location[0] + v.getWidth(); int maxY = getBottom(); float x = ev.getX(); float y = ev.getY(); if ((x &gt; minX &amp;&amp; x &lt; maxX) &amp;&amp; (y &gt; minY &amp;&amp; y &lt; maxY)) { return v; } } return null; } } 实现原理就是手指点击屏幕，如果点击的位置恰好落在ViewPager某个子View范围内，就让ViewPager切换到哪个子View！viewOfClickOnScreen方法是获取手指点击ViewPager中的哪个子View，最后调用setCurrentItem切换到相应的子View，经过以上设置就大功告成了！ 补充一下，RecyclingPagerAdapter是Jake WhartonAndroid大神封装的可用于复用的PagerAdapter。 最后附上源码github","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"Android：第一个App用户量突破十万大关，正迈向二十万...","slug":"Android：第一个App用户量突破十万大关，正迈向二十万","date":"2015-09-24T02:48:11.000Z","updated":"2015-09-24T02:55:00.000Z","comments":true,"path":"2015/09/24/Android：第一个App用户量突破十万大关，正迈向二十万/","link":"","permalink":"http://hanhailong.com/2015/09/24/Android：第一个App用户量突破十万大关，正迈向二十万/","excerpt":"","text":"做了N个app了，这是第一个app用户量突破十万的，极客学院Android客户端用户量已经达到13万了，每天活跃用户量三四千，每天新增用户不到1千。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"Android-三张图搞定Touch事件传递机制","slug":"Android-三张图搞定Touch事件传递机制","date":"2015-09-23T22:27:43.000Z","updated":"2015-09-23T22:33:28.000Z","comments":true,"path":"2015/09/24/Android-三张图搞定Touch事件传递机制/","link":"","permalink":"http://hanhailong.com/2015/09/24/Android-三张图搞定Touch事件传递机制/","excerpt":"之前看了很多关于Android事件Touch传递机制的文章，感觉还是老外讲的最清楚。原版PDF地址：Mastering the Android Touch System，github的demo地址：demo","text":"之前看了很多关于Android事件Touch传递机制的文章，感觉还是老外讲的最清楚。原版PDF地址：Mastering the Android Touch System，github的demo地址：demo 上图之前先讲下Android事件的基础知识： 所有的Touch事件都封装到MotionEvent里面 事件处理包括三种情况，分别为：传递—-dispatchTouchEvent()函数、拦截——onInterceptTouchEvent()函数、消费—-onTouchEvent()函数和OnTouchListener 事件类型分为ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_POINTER_DOWN, ACTION_POINTER_UP, ACTION_CANCEL等，每个事件都是以ACTION_DOWN开始ACTION_UP结束 Android事件传递流程： 事件都是从Activity.dispatchTouchEvent()开始传递 事件由父View传递给子View，ViewGroup可以通过onInterceptTouchEvent()方法对事件拦截，停止其向子view传递 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数。 如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来，也就是说ACTION_DOWN必须返回true，之后的事件才会传递进来 OnTouchListener优先于onTouchEvent()对事件进行消费 效果图如下： View不处理事件流程图（View没有消费事件） View处理事件 事件拦截","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"Android-通过@Keep注解来防止类、构造函数、方法、变量等混淆","slug":"Android-通过-Keep注解来防止类、构造函数、方法、变量等混淆","date":"2015-09-20T13:01:28.000Z","updated":"2015-09-23T22:37:22.000Z","comments":true,"path":"2015/09/20/Android-通过-Keep注解来防止类、构造函数、方法、变量等混淆/","link":"","permalink":"http://hanhailong.com/2015/09/20/Android-通过-Keep注解来防止类、构造函数、方法、变量等混淆/","excerpt":"我们在开发Android应用的时候，经常遇到这样一种问题：那就是防止proguard混淆我们特定的变量、方法等等。","text":"我们在开发Android应用的时候，经常遇到这样一种问题：那就是防止proguard混淆我们特定的变量、方法等等。 举个例子，我们定义了一个类，这个类实现了Serializable接口；当然这个类不能混淆，否则反序列化会出错。通常这种情况下，我们会在proguard-rules.pro配置文件中加入以下代码： -keepnames class * implements java.io.Serializable -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient &lt;fields&gt;; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); } 但是这个是混淆的实现Serializable的类，有时候我们需要混淆没有共同特征的类、方法和属性时，这种写法就非常蛋疼了。 这里介绍一种比较新颖、轻快的方法，通过@Keep注解来灵活的防止混淆，用起来非常的灵活、快捷、方便，怎样用呢？像普通的注解一样，如下： //防止混淆类 @Keep public class Person {} //防止混淆变量 @Keep public String name; //防止混淆方法 @Keep public int getAge(){} 但是当你加上上面的注解后，发现@Keep并没有起作用，该混淆的还是混淆了，这是为什么呢？ 原因目前Gradle还不支持@Keep混淆，Google只是定义好了一个这种注解，并没有实现它，也就是说@Keep目前只是一个空壳。这里我们来手动开启它，让它支持防止混淆，在你的progurad-rules.pro配置文件里面加入以下代码： #手动启用support keep注解 #http://tools.android.com/tech-docs/support- annotations -dontskipnonpubliclibraryclassmembers -printconfiguration -keep,allowobfuscation @interface android.support.annotation.Keep -keep @android.support.annotation.Keep class * -keepclassmembers class * { @android.support.annotation.Keep *; } 加入后如下： 这样就开启了，重新打Realease包发现程序可以正常运行了！","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://hanhailong.com/tags/Android/"}]},{"title":"alfi-一个Android Library Finder","slug":"alfi-一个Android-Library-Finder","date":"2015-09-18T02:50:53.000Z","updated":"2015-09-18T03:00:42.000Z","comments":true,"path":"2015/09/18/alfi-一个Android-Library-Finder/","link":"","permalink":"http://hanhailong.com/2015/09/18/alfi-一个Android-Library-Finder/","excerpt":"#alfi Android Library Finder Search through thousands of android libraries that can help you scale your projects elegantly","text":"#alfi Android Library Finder Search through thousands of android libraries that can help you scale your projects elegantly ##安装打开终端terminal： $ gem install alfi ##使用搜索一个Android Library库： alfi picasso ##最后一步 复制这个查询出的库到你的build.gradle并且sync it ##github库地址 ##alfi","categories":[],"tags":[{"name":"Android工具","slug":"Android工具","permalink":"http://hanhailong.com/tags/Android工具/"}]},{"title":"Hexo主题-在博客左上角添加ForkMeOnGithub功能","slug":"Hexo主题-在博客左上角添加ForkMeOnGithub功能","date":"2015-09-17T03:28:31.000Z","updated":"2015-09-17T03:52:19.000Z","comments":true,"path":"2015/09/17/Hexo主题-在博客左上角添加ForkMeOnGithub功能/","link":"","permalink":"http://hanhailong.com/2015/09/17/Hexo主题-在博客左上角添加ForkMeOnGithub功能/","excerpt":"群里有同学问我博客左上角的Fork me on Github是怎么实现的，我这里简单介绍一下，其实实现原理很简单，因为我这里用的yilia主题，你只要改下themes/yilia/layout/_partial/left-col.ejs文件下的&lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;，在这个标签里面添加下面的代码，具体代码请看详情：","text":"群里有同学问我博客左上角的Fork me on Github是怎么实现的，我这里简单介绍一下，其实实现原理很简单，因为我这里用的yilia主题，你只要改下themes/yilia/layout/_partial/left-col.ejs文件下的&lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;，在这个标签里面添加下面的代码，具体代码请看详情： &lt;a href=&quot;https://github.com/hanhailong&quot; target=&quot;_Blank&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; left: 0; border: 0;&quot; src=&quot;http://img01.taobaocdn.com/imgextra/i1/102975691/TB2YWCacpXXXXaCXXXXXXXXXXXX-102975691.png&quot; alt=&quot;Fork me on GitHub&quot; data-canonical-src=&quot;http://img01.taobaocdn.com/imgextra/i1/102975691/TB2YWCacpXXXXaCXXXXXXXXXXXX-102975691.png&quot;&gt;&lt;/a&gt; 其中href中的链接换成你自己的github链接就可以了，这样就实现了！ 效果图如下：","categories":[],"tags":[{"name":"Hexo主题","slug":"Hexo主题","permalink":"http://hanhailong.com/tags/Hexo主题/"}]},{"title":"Hexo主题-yilia和next","slug":"Hexo主题-yilia和next","date":"2015-09-17T03:04:05.000Z","updated":"2015-09-17T03:21:34.000Z","comments":true,"path":"2015/09/17/Hexo主题-yilia和next/","link":"","permalink":"http://hanhailong.com/2015/09/17/Hexo主题-yilia和next/","excerpt":"最近在看Hexo主题相关的东西，我现在正在使用的是yilia主题，效果非常赞哦！另外再介绍一个star数量也比较高的主题next，效果也是很不错的！两个主题的具体内容看详情…","text":"最近在看Hexo主题相关的东西，我现在正在使用的是yilia主题，效果非常赞哦！另外再介绍一个star数量也比较高的主题next，效果也是很不错的！两个主题的具体内容看详情… yilia主题的效果图为： 最近又看到了next，效果也挺不错，看效果图： 最重要的是，里面有个非常详细的wiki，详细讲解了怎么设置头像、关于我、创建分类、侧边栏等等，链接wiki地址在next-wiki","categories":[],"tags":[{"name":"Hexo主题","slug":"Hexo主题","permalink":"http://hanhailong.com/tags/Hexo主题/"}]},{"title":"欢迎来到极客学院！","slug":"欢迎来到极客学院！","date":"2015-09-16T06:16:26.000Z","updated":"2015-09-28T03:44:47.000Z","comments":true,"path":"2015/09/16/欢迎来到极客学院！/","link":"","permalink":"http://hanhailong.com/2015/09/16/欢迎来到极客学院！/","excerpt":"","text":"2015年加入极客学院，开始新的移动研发里程！！！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://hanhailong.com/tags/随笔/"}]}]}