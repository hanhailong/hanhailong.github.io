<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[韩海龙的博客]]></title>
  <subtitle><![CDATA[学习总结 思考感悟 知识管理 代码分享]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://hanhailong.com/"/>
  <updated>2016-04-24T14:18:57.000Z</updated>
  <id>http://hanhailong.com/</id>
  
  <author>
    <name><![CDATA[韩海龙]]></name>
    <email><![CDATA[hanhailong.cool@163.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[React-Native-Android热更新]]></title>
    <link href="http://hanhailong.com/2016/04/23/React-Native-Android%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://hanhailong.com/2016/04/23/React-Native-Android热更新/</id>
    <published>2016-04-23T11:20:42.000Z</published>
    <updated>2016-04-24T14:18:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>为什么要有热更新，热更新的好处是什么？</p>
<h1 id="推荐JS开发工具">推荐JS开发工具</h1><ol>
<li>Sublime</li>
<li>WebStorm</li>
<li>其他</li>
</ol>
<h1 id="native增量更新方案">native增量更新方案</h1><p>参考<a href="https://github.com/cundong/SmartAppUpdates" target="_blank" rel="external">SmartAppUpdates</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="简介">简介</h1><p>为什么要有热更新，热更新的好处是什么？</p>
<h1 id="推荐JS开发工具">推荐JS开发工具</h1><ol>
<li>Sublime</li>
<li>WebStorm</li>
<li>其他</li>
</ol>
<h1 i]]>
    </summary>
    
      <category term="React-Native" scheme="http://hanhailong.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React-Native移植-Android]]></title>
    <link href="http://hanhailong.com/2016/04/23/React-Native%E7%A7%BB%E6%A4%8D-Android/"/>
    <id>http://hanhailong.com/2016/04/23/React-Native移植-Android/</id>
    <published>2016-04-23T11:20:17.000Z</published>
    <updated>2016-04-24T14:14:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>参考链接：<a href="http://facebook.github.io/react-native/releases/0.25/docs/embedded-app-android.html#content" target="_blank" rel="external"><br>Integrating with Existing Apps</a></p>
<p>由于公司业务需要，部分模块需要将native代码转移到<a href="https://github.com/facebook/react-native" target="_blank" rel="external">react-native</a>，并且由于是已有项目，所以我这里单独把react-native移植到项目来，移植的过程中遇到了一些问题，这里也记录了下。</p>
<p>网上的一些教程资料都不是很全，而且一些关键的步骤说的都不是很详细，这里我们从零开始。</p>
<p>还有就是环境配置这里不讲了，都是很基础的东西！</p>
<h1 id="新建一个Android项目">新建一个Android项目</h1><p>这里我们新建一个<a href="https://github.com/hanhailong/ReactNativeProject" target="_blank" rel="external">ReactNativeProject</a>，初始化目录结构如下：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rn/RN_init.png?raw=true" alt=""></p>
<h1 id="引入React-Native">引入React-Native</h1><p>在你的app目录下的build.gradle加入react-native依赖，我加入的是最新版本的0.20.1</p>
<pre><code><span class="keyword">compile</span> <span class="string">'com.facebook.react:react-native:0.20.1'</span>
</code></pre><p>然后在<em>AndroidManifest.xml</em>加入访问网络权限，当然一般已经项目都有这个权限，如果有这一步可以忽略</p>
<pre><code>&lt;uses-permission android:<span class="property">name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;
</code></pre><p>为了让项目支持调试RN，需要在<em>AndroidManifest.xml</em>里面加入RN的<em>DevSettingsActivity</em>，如下：</p>
<pre><code>&lt;activity android:<span class="property">name</span>=<span class="string">"com.facebook.react.devsupport.DevSettingsActivity"</span> /&gt;
</code></pre><p>这样真机晃动手机或者点击Menu菜单就会打开相关的调试页面，如图下所示：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rn/RN_DEV.png?raw=true" alt=""></p>
<p>这里部署完后，还有一个坑，就是React-Native对编译版本和最小编译版本都有要求，它需要app的<em>build.gradle</em>文件的<em>compileSdkVersion</em>为23，<em>minSdkVersion</em>为16，因为我们项目要求最低版本为15甚至更低，这里需要在app的<em>AndroidManifest.xml</em>加入</p>
<pre><code><span class="tag">&lt;<span class="title">uses-sdk</span> <span class="attribute">tools:overrideLibrary</span>=<span class="value">"com.facebook.react"</span> /&gt;</span>
</code></pre><a id="more"></a>
<h1 id="加入基础的Android原生代码和JS代码">加入基础的Android原生代码和JS代码</h1><p>我们新建一个<em>MyReactActivity</em>，完整代码贴下</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">DefaultHardwareBackBtnHandler</span> </span>{

    <span class="keyword">private</span> ReactRootView mReactRootView;
    <span class="keyword">private</span> ReactInstanceManager mReactInstanceManager;

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.activity_my_react);

        mReactRootView = (ReactRootView) findViewById(R.id.react_root);

        mReactInstanceManager = ReactInstanceManager.builder()
                .setApplication(getApplication())
                .setBundleAssetName(<span class="string">"index.android.bundle"</span>)
                .setJSMainModuleName(<span class="string">"index.android"</span>)
                .addPackage(<span class="keyword">new</span> MainReactPackage())
                .setUseDeveloperSupport(BuildConfig.DEBUG)
                .setInitialLifecycleState(LifecycleState.RESUMED)
                .build();

        mReactRootView.startReactApplication(mReactInstanceManager, <span class="string">"ReactNativeProject"</span>, <span class="keyword">null</span>);

    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">invokeDefaultOnBackPressed</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onBackPressed();
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onPause();

        <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) {
            mReactInstanceManager.onPause();
        }
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onResume();

        <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) {
            mReactInstanceManager.onResume(<span class="keyword">this</span>, <span class="keyword">this</span>);
        }
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>{
        <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) {
            mReactInstanceManager.onBackPressed();
        } <span class="keyword">else</span> {
            <span class="keyword">super</span>.onBackPressed();
        }
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onKeyUp</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>{
        <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; mReactInstanceManager != <span class="keyword">null</span>) {
            mReactInstanceManager.showDevOptionsDialog();
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onKeyUp</span><span class="params">(keyCode, event)</span></span>;
    }


}
</code></pre><p>因为<em>ReactRootView</em>本身就是一个FrameLayout，我没有按官网来直接new一个，而是直接把它放到布局<em>activity_my_react.xml</em>里面了，代码如下：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
    <span class="attribute">android:paddingBottom</span>=<span class="value">"@dimen/activity_vertical_margin"</span>
    <span class="attribute">android:paddingLeft</span>=<span class="value">"@dimen/activity_horizontal_margin"</span>
    <span class="attribute">android:paddingRight</span>=<span class="value">"@dimen/activity_horizontal_margin"</span>
    <span class="attribute">android:paddingTop</span>=<span class="value">"@dimen/activity_vertical_margin"</span>
    <span class="attribute">tools:context</span>=<span class="value">"com.hhl.reactnativeproject.MyReactActivity"</span>&gt;</span>

    <span class="tag">&lt;<span class="title">TextView</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"100dp"</span>
        <span class="attribute">android:gravity</span>=<span class="value">"center"</span>
        <span class="attribute">android:text</span>=<span class="value">"我是本地控件TextView"</span>
        <span class="attribute">android:textSize</span>=<span class="value">"20sp"</span> /&gt;</span>

    <span class="tag">&lt;<span class="title">com.facebook.react.ReactRootView</span>
        <span class="attribute">android:id</span>=<span class="value">"@+id/react_root"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span> /&gt;</span>

<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>这里需要强调一下下，Activity里面有两个方法，<em>setBundleAssetName</em>和<em>setJSMainModuleName</em>，其中<em>setBundleAssetName</em>间接调用了<em>setJSBundleFile</em>，而<em>setJSBundleFile</em>就是我们以后要讲的热修复的关键；而<em>setJSMainModuleName</em>设置的就是index.android.js的名字，这个可以更改目录位置。</p>
<p>Android代码加完了，开始加入JS代码，这里我们在项目根目录下，也就是我们的ReactNativeProject目录下加入index.android.js文件和package.json文件，index.android.js文件简单代码如下：</p>
<pre><code><span class="pi">'use strict'</span>;

<span class="keyword">import</span> React, {
  Text,
  View
} <span class="keyword">from</span> <span class="string">'react-native'</span>;

<span class="class"><span class="keyword">class</span> <span class="title">ReactNativeProject</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{
  render() {
    <span class="keyword">return</span> (
      <span class="xml"><span class="tag">&lt;<span class="title">View</span> <span class="attribute">style</span>=<span class="value">{styles.container}</span>&gt;</span>
        <span class="tag">&lt;<span class="title">Text</span> <span class="attribute">style</span>=<span class="value">{styles.hello}</span>&gt;</span>Hello, World<span class="tag">&lt;/<span class="title">Text</span>&gt;</span>
        <span class="tag">&lt;<span class="title">Text</span>&gt;</span>测试ReactNative<span class="tag">&lt;/<span class="title">Text</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">View</span>&gt;</span>
    )</span>
  }
}
<span class="keyword">var</span> styles = React.StyleSheet.create({
  container: {
    flex: <span class="number">1</span>,
    justifyContent: <span class="string">'center'</span>,
  },
  hello: {
    fontSize: <span class="number">20</span>,
    textAlign: <span class="string">'center'</span>,
    margin: <span class="number">10</span>,
  },
});

React.AppRegistry.registerComponent(<span class="string">'ReactNativeProject'</span>, () =&gt; ReactNativeProject);
</code></pre><p>package.json代码如下：</p>
<pre><code>{
  "<span class="attribute">name</span>": <span class="value"><span class="string">"ReactNativeProject"</span></span>,
  "<span class="attribute">version</span>": <span class="value"><span class="string">"1.0.0"</span></span>,
  "<span class="attribute">description</span>": <span class="value"><span class="string">"demo"</span></span>,
  "<span class="attribute">main</span>": <span class="value"><span class="string">"index.js"</span></span>,
  "<span class="attribute">scripts</span>": <span class="value">{
    "<span class="attribute">test</span>": <span class="value"><span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span>,
    "<span class="attribute">start</span>": <span class="value"><span class="string">"node node_modules/react-native/local-cli/cli.js start"</span>
  </span>}</span>,
  "<span class="attribute">author</span>": <span class="value"><span class="string">"hanhailong"</span></span>,
  "<span class="attribute">license</span>": <span class="value"><span class="string">"ISC"</span></span>,
  "<span class="attribute">dependencies</span>": <span class="value">{
    "<span class="attribute">react</span>": <span class="value"><span class="string">"^0.14.8"</span></span>,
    "<span class="attribute">react-native</span>": <span class="value"><span class="string">"^0.24.1"</span>
  </span>}
</span>}
</code></pre><h1 id="项目配置运行调试">项目配置运行调试</h1><p>在<em>ReactNativeProject</em>目录下执行如下命令</p>
<pre><code><span class="variable">$ </span>npm init
<span class="variable">$ </span>npm install --save react-native
<span class="variable">$ </span>curl -o .flowconfig <span class="symbol">https:</span>/<span class="regexp">/raw.githubusercontent.com/facebook</span><span class="regexp">/react-native/master</span><span class="regexp">/.flowconfig</span>
</code></pre><p>npm init命令可以不用执行，它如要用来生成package.json文件，前面我们已经创建过了，npm install –save react-native执行后会在目录下面生成node_modules文件夹并添加<em>react-native</em>的npm依赖</p>
<p>首先启动RN的npm本地服务：</p>
<pre><code>$ <span class="built_in">npm</span> start
</code></pre><p>启动后如下：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rn/RN_command.png?raw=true" alt="npm启动"></p>
<p>在MainActivity里面我们加入跳转到<em>MyReactActivity</em>的代码，</p>
<pre><code><span class="type">Intent</span> <span class="type">intent</span> = new <span class="type">Intent</span>(MainActivity.this, MyReactActivity.<span class="keyword">class</span>);
startActivity(<span class="type">intent</span>);
</code></pre><h1 id="项目结构图">项目结构图</h1><p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rn/RN_complete.png?raw=true" alt=""></p>
<h1 id="项目运行效果">项目运行效果</h1><p>最后我们运行项目，运行效果图如下：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rn/RN_xiaoguo.gif?raw=true" alt=""></p>
<h1 id="编译可能遇到的问题">编译可能遇到的问题</h1><h2 id="Caused_by:_java-lang-IllegalAccessError:_tried_to_access_method_android-support-v4-net-ConnectivityManagerCompat-:(Lcom/facebook/react/bridge/ReactApplicationContext;)V_from_class_com-facebook-react-modules-netinfo-NetInfoModule">Caused by: java.lang.IllegalAccessError: tried to access method android.support.v4.net.ConnectivityManagerCompat.<init>:(Lcom/facebook/react/bridge/ReactApplicationContext;)V from class com.facebook.react.modules.netinfo.NetInfoModule</init></h2><p>我的项目的appcompat的版本是23.2.1，改成23.0.1就好了</p>
<pre><code><span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:23.0.1'</span>
</code></pre><h1 id="下一节讲解RN热更新">下一节讲解RN热更新</h1><p>下一节我们将讲解RN的热更新，敬请期待！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="简介">简介</h1><p>参考链接：<a href="http://facebook.github.io/react-native/releases/0.25/docs/embedded-app-android.html#content"><br>Integrating with Existing Apps</a></p>
<p>由于公司业务需要，部分模块需要将native代码转移到<a href="https://github.com/facebook/react-native">react-native</a>，并且由于是已有项目，所以我这里单独把react-native移植到项目来，移植的过程中遇到了一些问题，这里也记录了下。</p>
<p>网上的一些教程资料都不是很全，而且一些关键的步骤说的都不是很详细，这里我们从零开始。</p>
<p>还有就是环境配置这里不讲了，都是很基础的东西！</p>
<h1 id="新建一个Android项目">新建一个Android项目</h1><p>这里我们新建一个<a href="https://github.com/hanhailong/ReactNativeProject">ReactNativeProject</a>，初始化目录结构如下：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rn/RN_init.png?raw=true" alt=""></p>
<h1 id="引入React-Native">引入React-Native</h1><p>在你的app目录下的build.gradle加入react-native依赖，我加入的是最新版本的0.20.1</p>
<pre><code><span class="keyword">compile</span> <span class="string">'com.facebook.react:react-native:0.20.1'</span>
</code></pre><p>然后在<em>AndroidManifest.xml</em>加入访问网络权限，当然一般已经项目都有这个权限，如果有这一步可以忽略</p>
<pre><code>&lt;uses-permission android:<span class="property">name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;
</code></pre><p>为了让项目支持调试RN，需要在<em>AndroidManifest.xml</em>里面加入RN的<em>DevSettingsActivity</em>，如下：</p>
<pre><code>&lt;activity android:<span class="property">name</span>=<span class="string">"com.facebook.react.devsupport.DevSettingsActivity"</span> /&gt;
</code></pre><p>这样真机晃动手机或者点击Menu菜单就会打开相关的调试页面，如图下所示：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rn/RN_DEV.png?raw=true" alt=""></p>
<p>这里部署完后，还有一个坑，就是React-Native对编译版本和最小编译版本都有要求，它需要app的<em>build.gradle</em>文件的<em>compileSdkVersion</em>为23，<em>minSdkVersion</em>为16，因为我们项目要求最低版本为15甚至更低，这里需要在app的<em>AndroidManifest.xml</em>加入</p>
<pre><code><span class="tag">&lt;<span class="title">uses-sdk</span> <span class="attribute">tools:overrideLibrary</span>=<span class="value">"com.facebook.react"</span> /&gt;</span>
</code></pre>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
      <category term="React-Native" scheme="http://hanhailong.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[apk打包流程梳理]]></title>
    <link href="http://hanhailong.com/2016/04/02/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <id>http://hanhailong.com/2016/04/02/apk打包流程梳理/</id>
    <published>2016-04-02T05:42:26.000Z</published>
    <updated>2016-04-02T07:47:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>一些初学Android的开发者可能只知道写完项目，然后点击AndroidStudio中的run按钮就可以把项目运行到手机或者模拟器上，而一个apk是怎么从编译打包到最后签名安装到手机上的原理不知道，这里就带领大家理解一下内部的原理</p>
<h1 id="简单build流程">简单build流程</h1><p>首先，我们看下官网介绍<a href="http://developer.android.com/intl/zh-cn/tools/building/index.html" target="_blank" rel="external">Building and Running Overview</a>,官网给了我们一张非常简单的编译、打包、apk生成内容以及签名的图片，因为官网必须得用vpn才能访问，这里我就直接下载下来了，简单build图片如下：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/build-simplified.png?raw=true" alt=""></p>
<p>图片大体介绍了从Project到运行到设备或者模拟器的一个大体流程，我们也从中看到一个完整的apk包含如下内容：一个或多个dex文件、resources.arsc、未编译的资源文件以及AndroidManifest.xml文件等等</p>
<h1 id="详细打包流程">详细打包流程</h1><p>官网给了我们一张非常清晰的打包流程图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/android_build.png?raw=true" alt=""></p>
<h1 id="打包步骤">打包步骤</h1><p>总体打包步骤我们可以概括以下七步：</p>
<ol>
<li>通过aapt打包资源文件，生成R.java和resources.arsc</li>
<li>处理aidl文件，生成对应的java接口文件</li>
<li>编译项目工程源代码，生成.class文件</li>
<li>Dex命令处理，将第三步生成的.class文件和第三方的库一起生成classes.dex文件</li>
<li>通过apkbuilder工具将aapt生成的resources.arsc、classes.dex（可能多个）、其他的资源一块打包生成apk文件</li>
<li>通过Jarsigner对第五步生成的apk进行debug或者release签名，只有签名完的apk才能进行安装</li>
<li>通过aipalign对签名后的apk进行对其处理，使apk中所有资源文件距离文件起始偏移为4字节的整数倍，从而在通过内存映射访问apk文件时会更快</li>
</ol>
<p>其实还应该有最后一步，那就是通过adb install命令将生成的apk安装到设备或者模拟器上</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="简介">简介</h1><p>一些初学Android的开发者可能只知道写完项目，然后点击AndroidStudio中的run按钮就可以把项目运行到手机或者模拟器上，而一个apk是怎么从编译打包到最后签名安装到手机上的原理不知道，这里就带领大家理解一下内部的原理</p]]>
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[接口和抽象类区别]]></title>
    <link href="http://hanhailong.com/2016/04/01/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8C%BA%E5%88%AB/"/>
    <id>http://hanhailong.com/2016/04/01/接口和抽象类区别/</id>
    <published>2016-04-01T07:03:02.000Z</published>
    <updated>2016-04-01T10:25:23.000Z</updated>
    <content type="html"><![CDATA[<p>接口和抽象类有什么区别？</p>
<p>你选择使用接口和抽象类的依据是什么？</p>
<h1 id="理解抽象">理解抽象</h1><p>abstract class和interface是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。 abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于 abstract class和interface的选择显得比较随意。</p>
<p>其实，两者之间还是有很大的区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。本文将对它们之间的区别进行一番剖析，试图给开发者提供一个在二者之间进行选择的依据。</p>
<h1 id="语法定义理解">语法定义理解</h1><ol>
<li><p>抽象类</p>
<pre><code><span class="annotation">abstract</span> <span class="keyword">class</span> Demo ｛    

    <span class="annotation">abstract</span> <span class="keyword">void</span> method<span class="number">1</span>();    

    <span class="annotation">abstract</span> <span class="keyword">void</span> method<span class="number">2</span>();    

    …    

｝    
</code></pre></li>
<li><p>接口</p>
<pre><code><span class="keyword">interface</span> <span class="title">Demo</span> {    

    <span class="function"><span class="keyword">void</span> <span class="title">method1</span>(<span class="params"></span>)</span>;    

    <span class="function"><span class="keyword">void</span> <span class="title">method2</span>(<span class="params"></span>)</span>;    

    …    

}    
</code></pre></li>
</ol>
<p>在abstract class方式中，Demo可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface方式的实现中，Demo只能够有静态的 不能被修改的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊 形式的abstract class。</p>
<a id="more"></a>
<h1 id="编程角度理解">编程角度理解</h1><p>首先，abstract class在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。也许，这是Java语言的设计者在考虑Java对于多重继承的支持方面的一种折中考虑吧。</p>
<p>其次，在abstract class的定义中，我们可以赋予方法的默认行为。但是在interface的定义中，方法却不能拥有默认行为，为了绕过这个限制，必须使用委托，但是这会 增加一些复杂性，有时会造成很大的麻烦。</p>
<h1 id="一般性理解">一般性理解</h1><p>接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。<br>抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。<br>人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.<br>所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。</p>
<h1 id="总结">总结</h1><ol>
<li><p>抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。</p>
</li>
<li><p>抽象类要被子类继承，接口要被类实现。</p>
</li>
<li><p>接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现</p>
</li>
<li><p>接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。</p>
</li>
<li><p>抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。</p>
</li>
<li><p>抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。</p>
</li>
<li><p>抽象类里可以没有抽象方法</p>
</li>
<li><p>如果一个类里有抽象方法，那么这个类只能是抽象类</p>
</li>
<li><p>抽象方法要被实现，所以不能是静态的，也不能是私有的。</p>
</li>
<li><p>接口可继承接口，并可多继承接口，但类只能单根继承。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>接口和抽象类有什么区别？</p>
<p>你选择使用接口和抽象类的依据是什么？</p>
<h1 id="理解抽象">理解抽象</h1><p>abstract class和interface是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。 abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于 abstract class和interface的选择显得比较随意。</p>
<p>其实，两者之间还是有很大的区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。本文将对它们之间的区别进行一番剖析，试图给开发者提供一个在二者之间进行选择的依据。</p>
<h1 id="语法定义理解">语法定义理解</h1><ol>
<li><p>抽象类</p>
<pre><code><span class="annotation">abstract</span> <span class="keyword">class</span> Demo ｛    

    <span class="annotation">abstract</span> <span class="keyword">void</span> method<span class="number">1</span>();    

    <span class="annotation">abstract</span> <span class="keyword">void</span> method<span class="number">2</span>();    

    …    

｝    
</code></pre></li>
<li><p>接口</p>
<pre><code><span class="keyword">interface</span> <span class="title">Demo</span> {    

    <span class="function"><span class="keyword">void</span> <span class="title">method1</span>(<span class="params"></span>)</span>;    

    <span class="function"><span class="keyword">void</span> <span class="title">method2</span>(<span class="params"></span>)</span>;    

    …    

}    
</code></pre></li>
</ol>
<p>在abstract class方式中，Demo可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface方式的实现中，Demo只能够有静态的 不能被修改的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊 形式的abstract class。</p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://hanhailong.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java反转单链表实战]]></title>
    <link href="http://hanhailong.com/2016/02/25/Java%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E6%88%98/"/>
    <id>http://hanhailong.com/2016/02/25/Java反转单链表实战/</id>
    <published>2016-02-25T15:49:07.000Z</published>
    <updated>2016-03-02T13:58:13.000Z</updated>
    <content type="html"><![CDATA[<p>算法是程序代码的灵魂！！！Java反转单链表这种算法一般会在面试中遇到，尤其是一些大公司！！！这里就来通过Java代码实战来讲解下实现反转的两种方法。</p>
<ol>
<li>递归</li>
<li>普通遍历</li>
</ol>
<p>这里介绍的两种方法都很常见，递归在算法里面非常常见！！</p>
<p>首先，我们要定义一个Node节点类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span>{
    <span class="keyword">int</span> <span class="keyword">value</span>;
    Node nextNode;
    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span>, Node nextNode</span>) </span>{
        super();
        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;
        <span class="keyword">this</span>.nextNode = nextNode;
    }
}
</code></pre><p>因为是单链表，这里只有<em>nextNode</em>和当前节点的值。</p>
<a id="more"></a>
<p>我们这里初始化n个节点的链表，我们写一个初始化Node的方法：</p>
<pre><code><span class="comment">/**
     * 初始化单链表
     * <span class="doctag">@param</span> num 数量
     * <span class="doctag">@return</span>
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Node <span class="title">init</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{
        Node node = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="keyword">null</span>);
        Node cur = <span class="keyword">null</span>;
        Node temp = <span class="keyword">null</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; num;i++){
            temp = <span class="keyword">new</span> Node(i, <span class="keyword">null</span>);
            <span class="keyword">if</span> (i == <span class="number">1</span>) {
                node.nextNode = temp;
            }<span class="keyword">else</span>{
                cur.nextNode = temp;
            }
            cur = temp;
        }
        <span class="keyword">return</span> node;
    }
</code></pre><p>然后，再把这个链表循环打印一下，先写一个out输出打印方法：</p>
<pre><code><span class="comment">/**
     * 打印节点值
     * @param head
     */</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">out</span>(<span class="params">Node head</span>) </span>{
        Node tempNode = head;
        <span class="keyword">while</span>(tempNode != <span class="keyword">null</span>){            
            System.err.println(tempNode.<span class="keyword">value</span>);
            tempNode = tempNode.nextNode;
        }
    }
</code></pre><p>我们在<em>main</em>方法里面打印一下结果：</p>
<pre><code>Node head = init<span class="list">(<span class="number">10</span>)</span><span class="comment">;</span>
out<span class="list">(<span class="keyword">head</span>)</span><span class="comment">;</span>
</code></pre><p>最后输出的结果值为：</p>
<pre><code><span class="number">0</span>
<span class="number">1</span>
<span class="number">2</span>
<span class="number">3</span>
<span class="number">4</span>
<span class="number">5</span>
<span class="number">6</span>
<span class="number">7</span>
<span class="number">8</span>
<span class="number">9</span>
</code></pre><h2>普通遍历</h2>

<pre><code>/**
     * 反转单链表
     * <span class="constant">@param</span> head
     * <span class="constant">@return</span>
     */
    private <span class="keyword">static</span> Node reverseHead(Node head) {
        <span class="keyword">if</span> (head == <span class="literal">null</span>) {
            <span class="keyword">return</span> head<span class="comment">;</span>
        }

        Node pre = head<span class="comment">;</span>
        Node cur = head.nextNode<span class="comment">;</span>
        Node <span class="keyword">next</span> = <span class="literal">null</span><span class="comment">;</span>
        <span class="keyword">while</span>(cur != <span class="literal">null</span>){
            <span class="keyword">next</span> = cur.nextNode<span class="comment">;</span>
            cur.nextNode = pre<span class="comment">;</span>

            pre = cur<span class="comment">;</span>
            cur = <span class="keyword">next</span><span class="comment">;</span>
        }
        head.nextNode = <span class="literal">null</span><span class="comment">;</span>
        head = pre<span class="comment">;</span>
        <span class="keyword">return</span> head<span class="comment">;</span>
    }
</code></pre><p>我们在main函数里调用下这个方法：</p>
<pre><code>Node reverseHead = reverseHead<span class="list">(<span class="keyword">head</span>)</span><span class="comment">;</span>
out<span class="list">(<span class="keyword">reverseHead</span>)</span><span class="comment">;</span>
</code></pre><p>我们看下输出的结果值：</p>
<pre><code><span class="number">9</span>
<span class="number">8</span>
<span class="number">7</span>
<span class="number">6</span>
<span class="number">5</span>
<span class="number">4</span>
<span class="number">3</span>
<span class="number">2</span>
<span class="number">1</span>
<span class="number">0</span>
</code></pre><h2>递归</h2>

<pre><code><span class="comment">/**
     * 递归反转
     * <span class="doctag">@param</span> head
     * <span class="doctag">@return</span>
     */</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function">Node <span class="title">reverseByRecur</span><span class="params">(Node current)</span> </span>{
        <span class="keyword">if</span> (current == <span class="keyword">null</span> || current.nextNode == <span class="keyword">null</span>) <span class="keyword">return</span> current;  
         Node nextNode = current.nextNode;  
         current.nextNode = <span class="keyword">null</span>;  
         Node reverseRest = reverseByRecur(nextNode);  
         nextNode.nextNode = current;  
         <span class="keyword">return</span> reverseRest;  
    }
</code></pre><p>我们在main函数里调用：</p>
<pre><code>out<span class="list">(<span class="keyword">reverseByRecur</span><span class="list">(<span class="keyword">head</span>)</span>)</span><span class="comment">;</span>
</code></pre><p>我们看下输出的结果值：</p>
<pre><code><span class="number">9</span>
<span class="number">8</span>
<span class="number">7</span>
<span class="number">6</span>
<span class="number">5</span>
<span class="number">4</span>
<span class="number">3</span>
<span class="number">2</span>
<span class="number">1</span>
<span class="number">0</span>
</code></pre><p>两种方法都可以实现单链表反转，普通循环遍历容易理解一点，递归需要很强的逻辑性和思维性！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>算法是程序代码的灵魂！！！Java反转单链表这种算法一般会在面试中遇到，尤其是一些大公司！！！这里就来通过Java代码实战来讲解下实现反转的两种方法。</p>
<ol>
<li>递归</li>
<li>普通遍历</li>
</ol>
<p>这里介绍的两种方法都很常见，递归在算法里面非常常见！！</p>
<p>首先，我们要定义一个Node节点类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span>{
    <span class="keyword">int</span> <span class="keyword">value</span>;
    Node nextNode;
    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span>, Node nextNode</span>) </span>{
        super();
        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;
        <span class="keyword">this</span>.nextNode = nextNode;
    }
}
</code></pre><p>因为是单链表，这里只有<em>nextNode</em>和当前节点的值。</p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://hanhailong.com/tags/Java/"/>
    
      <category term="算法" scheme="http://hanhailong.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rebound-Android的弹簧动画库]]></title>
    <link href="http://hanhailong.com/2016/02/16/Rebound-Android%E7%9A%84%E5%BC%B9%E7%B0%A7%E5%8A%A8%E7%94%BB%E5%BA%93/"/>
    <id>http://hanhailong.com/2016/02/16/Rebound-Android的弹簧动画库/</id>
    <published>2016-02-16T15:55:13.000Z</published>
    <updated>2016-02-18T09:14:09.000Z</updated>
    <content type="html"><![CDATA[<h2>简介</h2>

<p><a href="http://facebook.github.io/rebound/" target="_blank" rel="external">官方网站</a></p>
<p><a href="https://github.com/facebook/rebound" target="_blank" rel="external">github</a></p>
<p><em>Rebound</em>是facebook出品的一个弹簧动画库，与之对应的IOS版本有一个<a href="https://github.com/facebook/pop" target="_blank" rel="external">pop</a>动画库，也是非常的强大给力。Facebook真是互联网企业中的楷模，开源了很多的实用开源库，大赞一个！！！</p>
<p>讲解<em>Rebound</em>之前，先看看我们根据<em>Rebound</em>高仿的新浪微博弹出菜单，看效果图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/tanhuang-offical-demo3.gif?raw=true" alt=""></p>
<a id="more"></a>
<p>话说回来，facebook为啥推出这个库呢？主要就是现有的动画离真实物理世界差别比较明显，为了让动画看起来真实自然，带有力量的效果，<em>Rebound</em>应运而生。两个比较重要的参数，一个是拉力Tension，一个是摩擦力Friction，拉力越大，弹簧效果越明显；摩擦力越大，弹框效果阻力越大、越不明显。如果这个摩擦力的值设置为0，就像真实世界中处于真空状态，一点摩擦力都没有，这个弹簧效果会一直无限制重复下去，根本停不下来，不信看效果图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/tanhuang-wuxian.gif?raw=true" alt=""></p>
<p>我们把摩擦力的值改成1试试：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/tanhuang-moca1.gif?raw=true" alt=""></p>
<h2>初级用法</h2>

<p><em>Rebound</em>提供了非常简洁的api方法来供我们调用，我们只需要配置一些简单的参数就可以使用了，下面看看官网给出的例子：</p>
<pre><code><span class="comment">// Create a system to run the physics loop for a set of springs.</span>
SpringSystem springSystem = SpringSystem.create();

<span class="comment">// Add a spring to the system.</span>
Spring <span class="keyword">spring</span> = springSystem.createSpring();

<span class="comment">// Add a listener to observe the motion of the spring.</span>
<span class="keyword">spring</span>.addListener(new SimpleSpringListener() {

  <span class="variable">@Override</span>
  public void onSpringUpdate(Spring <span class="keyword">spring</span>) {
    <span class="comment">// You can observe the updates in the spring</span>
    <span class="comment">// state by asking its current value in onSpringUpdate.</span>
    <span class="keyword">float</span> value = (<span class="keyword">float</span>) <span class="keyword">spring</span>.getCurrentValue();
    <span class="keyword">float</span> <span class="keyword">scale</span> = <span class="number">1</span>f - (value * <span class="number">0.5</span>f);
    myView.setScaleX(<span class="keyword">scale</span>);
    myView.setScaleY(<span class="keyword">scale</span>);
  }
});

<span class="comment">// Set the spring in motion; moving from 0 to 1</span>
<span class="keyword">spring</span>.setEndValue(<span class="number">1</span>);
</code></pre><p>我们看下对应的效果图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/tanhuang-offical-demo.gif?raw=true" alt=""></p>
<p>你们发现，好像弹簧效果不明显，<em>Rebound</em>默认的拉力和摩擦力参数分别是40和7，我们看下<em>Rebound</em>里面有个<em>defaultConfig</em></p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> SpringConfig defaultConfig = SpringConfig.fromOrigamiTensionAndFriction(<span class="number">40</span>, <span class="number">7</span>);
</code></pre><p>为了让弹簧效果更明显，我们修改下<em>SpringConfig</em>的值，代码如下：</p>
<pre><code>spring.setSpringConfig(SpringConfig.fromOrigamiTensionAndFriction(<span class="number">100</span>,<span class="number">1</span>));
</code></pre><p>我们将拉力值改成100，摩擦力值改成1，效果图如下：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/tanhuang-offical-demo1.gif?raw=true" alt=""></p>
<p>效果很赞了吧！</p>
<h2>高级用法：多个view连锁动画</h2>

<p>如果想要做很多view的连锁动画怎么办？<em>Rebound</em>也提供了<em>SpringChain</em>这个接口。直接看代码吧：</p>
<pre><code>SpringChain springChain = SpringChain.create(<span class="number">40</span>,<span class="number">6</span>,<span class="number">50</span>,<span class="number">7</span>);

<span class="keyword">int</span> childCount = viewGroup.getChildCount();
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) {
    final View view = viewGroup.getChildAt(i);

    springChain.addSpring(<span class="keyword">new</span> SimpleSpringListener() {
        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSpringUpdate</span><span class="params">(Spring spring)</span> </span>{
            view.setTranslationY((<span class="keyword">float</span>) spring.getCurrentValue());
        }
    });
}

List&lt;Spring&gt; springs = springChain.getAllSprings();
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; springs.size(); i++) {
    springs.get(i).setCurrentValue(<span class="number">400</span>);
}

springChain.setControlSpringIndex(<span class="number">2</span>).getControlSpring().setEndValue(<span class="number">0</span>);
</code></pre><p>效果图如下：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/tanhuang-offical-demo2.gif?raw=true" alt=""></p>
<p>我们来看看<em>SpringChain</em>这个类，创建它有两个create方法：</p>
<ol>
<li>默认无参数create()</li>
<li>有参数的create(int mainTension,int mainFriction,int attachmentTension,int attachmentFriction)</li>
</ol>
<p>其中带参数的第一个参数表示起主导作用Spring的拉力系数，第二个参数表示起主导作用Spring的摩擦力系数，第三个和第四个表示附属的拉力和摩擦力系数</p>
<p><em>SpringChain</em>需要设置一个起主导控制作用的Spring，通过<em>setControlSpringIndex</em>方法来设置</p>
<h2>高仿新浪弹出菜单</h2>

<p>先看下高仿后的效果图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/tanhuang-offical-demo3.gif?raw=true" alt=""></p>
<p>这里给出示例代码：</p>
<pre><code>PopMenu popMenu = <span class="keyword">new</span> PopMenu.Builder().attachToActivity(MainActivity.<span class="keyword">this</span>)
                .addMenuItem(<span class="keyword">new</span> PopMenuItem(<span class="string">"文字"</span>, getResources().getDrawable(R.drawable.tabbar_compose_idea)))
                .addMenuItem(<span class="keyword">new</span> PopMenuItem(<span class="string">"照片/视频"</span>, getResources().getDrawable(R.drawable.tabbar_compose_photo)))
                .addMenuItem(<span class="keyword">new</span> PopMenuItem(<span class="string">"头条文章"</span>, getResources().getDrawable(R.drawable.tabbar_compose_headlines)))
                .addMenuItem(<span class="keyword">new</span> PopMenuItem(<span class="string">"签到"</span>, getResources().getDrawable(R.drawable.tabbar_compose_lbs)))
                .addMenuItem(<span class="keyword">new</span> PopMenuItem(<span class="string">"点评"</span>, getResources().getDrawable(R.drawable.tabbar_compose_review)))
                .addMenuItem(<span class="keyword">new</span> PopMenuItem(<span class="string">"更多"</span>, getResources().getDrawable(R.drawable.tabbar_compose_more)))
                .setOnItemClickListener(<span class="keyword">new</span> PopMenuItemListener() {
                    <span class="annotation">@Override</span>
                    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(PopMenu popMenu, <span class="keyword">int</span> position)</span> </span>{
                        Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"你点击了第"</span> + position + <span class="string">"个位置"</span>, Toast.LENGTH_SHORT).show();
                    }
                })
                .build();   
popMenu.show();
</code></pre><p>这里由于篇幅原因，就暂时先不讲解实现原理了，如需要看源码去我的github上下载，下载地址为：<a href="https://github.com/hanhailong/sina-popmenu" target="_blank" rel="external">高仿新浪弹出菜单</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>简介</h2>

<p><a href="http://facebook.github.io/rebound/">官方网站</a></p>
<p><a href="https://github.com/facebook/rebound">github</a></p>
<p><em>Rebound</em>是facebook出品的一个弹簧动画库，与之对应的IOS版本有一个<a href="https://github.com/facebook/pop">pop</a>动画库，也是非常的强大给力。Facebook真是互联网企业中的楷模，开源了很多的实用开源库，大赞一个！！！</p>
<p>讲解<em>Rebound</em>之前，先看看我们根据<em>Rebound</em>高仿的新浪微博弹出菜单，看效果图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/tanhuang-offical-demo3.gif?raw=true" alt=""></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OC、Swift代码注释#pragma mark]]></title>
    <link href="http://hanhailong.com/2016/02/16/OC%E3%80%81Swift%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A-pragma-mark/"/>
    <id>http://hanhailong.com/2016/02/16/OC、Swift代码注释-pragma-mark/</id>
    <published>2016-02-16T08:10:49.000Z</published>
    <updated>2016-02-18T09:25:26.000Z</updated>
    <content type="html"><![CDATA[<p>以前在我们写OC代码的时候，经常通过下面语法来为代码添加注释：</p>
<pre><code><span class="id">#pragma</span> <span class="tag">mark</span> – Initialization 
<span class="tag">code</span> here...
<span class="id">#pragma</span> <span class="tag">mark</span> – Table Managementmore 
<span class="tag">code</span> here...
</code></pre><p>但是，如果是Swift代码，这种写法就不好使了，下面给出Swift代码注释，Swift代码注释有三种:</p>
<ol>
<li><p>MARK</p>
<pre><code><span class="comment">// MARK: - Initialization</span>
<span class="tag">code</span> here...
<span class="comment">// MARK: - View Managementmore </span>
<span class="tag">code</span> here...
</code></pre></li>
<li><p>TODO</p>
<pre><code><span class="comment">// <span class="doctag">TODO:</span> - <span class="label">XXXXXXXX</span></span>
<span class="tag">code</span> here...
</code></pre></li>
<li><p>FIXME</p>
<pre><code><span class="comment">// <span class="doctag">FIXME:</span> - <span class="label">XXXXXXXX</span></span>
<span class="tag">code</span> here...
</code></pre></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>以前在我们写OC代码的时候，经常通过下面语法来为代码添加注释：</p>
<pre><code><span class="id">#pragma</span> <span class="tag">mark</span> – Initialization 
<span clas]]>
    </summary>
    
      <category term="IOS" scheme="http://hanhailong.com/tags/IOS/"/>
    
      <category term="OC" scheme="http://hanhailong.com/tags/OC/"/>
    
      <category term="Swift" scheme="http://hanhailong.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift-？和！的区别]]></title>
    <link href="http://hanhailong.com/2016/01/28/Swift-%EF%BC%9F%E5%92%8C%EF%BC%81%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://hanhailong.com/2016/01/28/Swift-？和！的区别/</id>
    <published>2016-01-28T02:43:42.000Z</published>
    <updated>2016-01-29T07:30:24.000Z</updated>
    <content type="html"><![CDATA[<p>Swift 是一种新的编程语言，用于编写iOS，OS X 和 watchOS应用程序。Swift 结合了 C 和 Objective-C 的优点并且不受 C 兼容性的限制。Swift 采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift 是基于成熟而且倍受喜爱的 Cocoa 和 Cocoa Touch 框架，它的降临将重新定义软件开发。</p>
<p>今天我们的主角是可选类型？和！</p>
<p>Swift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值，也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化。如果在使用变量之前不进行初始化就会报错：</p>
<pre><code><span class="keyword">var</span> <span class="keyword">value</span> : String
<span class="comment">//error: variable 'stringValue' used before being initialized</span>
<span class="keyword">let</span> hash = <span class="keyword">value</span>.hashValue
</code></pre><a id="more"></a>
<h2>Optional简介</h2>

<p>讲到这里，我们的主角就要正式登场了——<em>Optional</em>，<em>Optional</em>其实是一个enum枚举值，它有两个值：<em>None</em>和<em>Some</em>。<em>Optional.None</em>其实就是nil，<em>Optional.Some</em>就是非nil，它会通过<em>Some(T)</em>来进行Wrap包装原始值，这也是为啥使用<em>Optional</em>类型的时候要进行拆包unWrap（从enum中读取原始值）了。下面是<em>Optional</em>的定义：</p>
<pre><code><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; : <span class="title">LogicValue</span>, <span class="title">Reflectable</span> </span>{
    <span class="keyword">case</span> <span class="type">None</span>
    <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">T</span>)
    <span class="keyword">init</span>()
    <span class="keyword">init</span>(<span class="number">_</span> some: <span class="type">T</span>)

    <span class="comment">/// Allow use in a Boolean context.</span>
    <span class="func"><span class="keyword">func</span> <span class="title">getLogicValue</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span>

    <span class="comment">/// Haskell's fmap, which was mis-named</span>
    <span class="func"><span class="keyword">func</span> <span class="title">map</span><span class="generics">&lt;U&gt;</span><span class="params">(f: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">U</span>?
    <span class="func"><span class="keyword">func</span> <span class="title">getMirror</span><span class="params">()</span></span> -&gt; <span class="type">Mirror</span>
}
</code></pre><p>声明为<em>Optional</em>只需要在类型后面紧跟一个?或者！即可，如:</p>
<pre><code><span class="keyword">var</span> strValue: <span class="built_in">String</span>?   <span class="comment">//?相当于下面这种写法的语法糖</span>
<span class="keyword">var</span> strValue: Optional&lt;<span class="built_in">String</span>&gt;  
</code></pre><p>上面的？这个Optional可选项类型声明，意思是我声明了一个Optional类型，而不是声明了一个String类型，它可能包含一个String值，也可能不包含，不包含默认值就为nil。我们可以通过if判断来区分是否为nil：</p>
<pre><code><span class="keyword">if</span> strValue {
    //<span class="keyword">do</span> something <span class="keyword">with</span> strValue
}
</code></pre><p>那么我们怎么使用Optional可选类型的值呢？直接在后面加上一个？号即可。如果是nil值，也就是Optional.None，会跳过后面的操作不执行，如果有值，也就是Optional.Some，就会进行unWrap拆包操作，比如：</p>
<pre><code>//正确
<span class="built_in">let</span> <span class="built_in">hash</span>Value = strValue?.hashValue
//错误
<span class="built_in">let</span> <span class="built_in">hash</span>Value = strValue.hashValue
</code></pre><p>有一种特殊情况，假如我们非常肯定strValue一定是非nil的，我们也可以采用强制拆包处理：使用！</p>
<pre><code><span class="built_in">let</span> <span class="built_in">hash</span>Value = strValue!.hashValue
</code></pre><p>!就代表强制拆包，假如strValue是nil，你强制拆包也会报错</p>
<h2>Optional可选类型？的使用场景</h2>

<ol>
<li><p>声明Optional变量</p>
<pre><code><span class="keyword">var</span> strValue : <span class="built_in">String</span>?
</code></pre></li>
<li><p>用在对Optional值操作中，用来判断是否能响应后面的操作</p>
<pre><code><span class="built_in">let</span> <span class="built_in">hash</span>Value = strValue?.hashValue
</code></pre></li>
<li><p>用于安全调用protocol的optional方法</p>
<pre><code><span class="variable">@objc</span> protocol Downloadable {
    <span class="variable">@optional</span> func <span class="function">download</span>(<span class="attribute">toPath</span>: String) -&gt; Bool;
}

<span class="variable">@objc</span> class <span class="attribute">Content</span>: Downloadable {
    <span class="comment">//download method not be implemented</span>
}

var <span class="attribute">delegate</span>: Downloadable = <span class="function">Downloadable</span>()
delegate.download?(<span class="string">"some path"</span>)
</code></pre></li>
<li><p>使用 <em>as?</em> 向下转型</p>
<pre><code><span class="keyword">if</span> <span class="keyword">let</span> dataSource = <span class="keyword">object</span> <span class="keyword">as</span>? UITableViewDataSource {
    <span class="keyword">let</span> rowsInFirstSection  = dataSource.tableView(tableView, numberOfRowsInSection: <span class="number">0</span>)
}
</code></pre></li>
</ol>
<h2>Optional可选类型！的使用场景</h2>

<ol>
<li><p>强制对可选类型Optional进行拆包</p>
<pre><code><span class="built_in">let</span> <span class="built_in">hash</span>Value = strValue!.hashValue
</code></pre></li>
<li><p>声明隐式拆包，一般用于类中的属性</p>
<pre><code><span class="keyword">var</span> strValue : <span class="built_in">String</span>!
</code></pre></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Swift 是一种新的编程语言，用于编写iOS，OS X 和 watchOS应用程序。Swift 结合了 C 和 Objective-C 的优点并且不受 C 兼容性的限制。Swift 采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift 是基于成熟而且倍受喜爱的 Cocoa 和 Cocoa Touch 框架，它的降临将重新定义软件开发。</p>
<p>今天我们的主角是可选类型？和！</p>
<p>Swift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值，也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化。如果在使用变量之前不进行初始化就会报错：</p>
<pre><code><span class="keyword">var</span> <span class="keyword">value</span> : String
<span class="comment">//error: variable 'stringValue' used before being initialized</span>
<span class="keyword">let</span> hash = <span class="keyword">value</span>.hashValue
</code></pre>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://hanhailong.com/tags/IOS/"/>
    
      <category term="Swift" scheme="http://hanhailong.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android小知识总结]]></title>
    <link href="http://hanhailong.com/2016/01/14/Android%E5%B0%8F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://hanhailong.com/2016/01/14/Android小知识总结/</id>
    <published>2016-01-14T15:00:27.000Z</published>
    <updated>2016-04-20T08:49:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="onCreate中计算View的高度">onCreate中计算View的高度</h1><p>可以借助getViewTreeObserver().addOnGlobalLayoutListener()来获得宽度或者高度，示例代码如下：</p>
<pre><code>mWebView.getViewTreeObserver().addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() {
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>{
                mWebView.getWidth();
                mWebView.getHeight();
                <span class="comment">//防止调用多次</span>
                mWebView.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);
            }
        });
</code></pre><h1 id="PopupWindow计算高度">PopupWindow计算高度</h1><p>PopupWindow在初始化创建好后，我想知道它的高度和宽度，可以这样计算：</p>
<pre><code><span class="tag">popupWindow</span><span class="class">.getContentView</span>()<span class="class">.measure</span>(0, 0);
<span class="tag">popupWindow</span><span class="class">.getContentView</span>()<span class="class">.getMeasuredWidth</span>();
<span class="tag">popupWindow</span><span class="class">.getContentView</span>()<span class="class">.getMeasuredHeight</span>();
</code></pre><a id="more"></a>
<h1 id="Theme-NoDisplay">Theme.NoDisplay</h1><p>在Android中想进行一些无界面的处理又不适合使用service时，此时可以在项目的AndroidManifest.xml文件中相应的Activity标签中添加这样一行：</p>
<pre><code><span class="symbol">android:</span>theme=”<span class="variable">@android</span><span class="symbol">:style/Theme</span>.<span class="constant">NoDisplay</span>
</code></pre><h1 id="activity父级activity的重建">activity父级activity的重建</h1><p>当我们从其他App跳转到我们应用内部时，可能我们跳转到的不是应用的第一层级页面而是深层次的页面，这时候我们需要在关闭应用内部页面时，对高层的页面进行重建。</p>
<ol>
<li><p>为activity指定父级activity</p>
<pre><code><span class="tag">&lt;<span class="title">application</span>&gt;</span> 
    <span class="comment">&lt;!-- 首层activity --&gt;</span>
    <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">"com.example.Mainactivity"</span>/&gt;</span> 
     <span class="comment">&lt;!-- 第二层级activity --&gt;</span>
     <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">"com.example.SecondeActivity"</span> <span class="attribute">android:parentActivityName</span>=<span class="value">"com.example.Mainactivity"</span> &gt;</span> 
         <span class="comment">&lt;!-- 父activity的meta-data，用来支持4.0以下版本 --&gt;</span>
         <span class="tag">&lt;<span class="title">meta-data</span> <span class="attribute">android:name</span>=<span class="value">"android.support.PARENT_ACTIVITY"</span> <span class="attribute">android:value</span>=<span class="value">"com.example.Mainactivity"</span> /&gt;</span>
     <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>
<span class="tag">&lt;/<span class="title">application</span>&gt;</span>
</code></pre></li>
<li><p>二级页面返回时，重建任务栈</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>{ 
    <span class="comment">// 获得指向父级activity的intent，NavUtils在support v4 包中 </span>
    Intent upIntent = NavUtils.getParentActivityIntent(<span class="keyword">this</span>); 
    <span class="comment">// 判断是否需要重建任务栈 </span>
    <span class="keyword">if</span> (NavUtils.shouldUpRecreateTask(<span class="keyword">this</span>, upIntent)) {
         <span class="comment">// 这个activity不是这个app任务的一部分, 所以当向上导航时创建</span>
         <span class="comment">// 用合成后退栈(synthesized back stack)创建一个新任务。</span>
          TaskStackBuilder.create(<span class="keyword">this</span>)
         <span class="comment">// 添加这个activity的所有父activity到后退栈中</span>
          .addNextIntentWithParentStack(upIntent)
           <span class="comment">// 向上导航到最近的一个父activity</span>
           .startActivities();
     } <span class="keyword">else</span> {
         <span class="comment">// 这个activity是这个app任务的一部分, 所以</span>
         <span class="comment">// 向上导航至逻辑父activity.</span>
         NavUtils.navigateUpTo(<span class="keyword">this</span>, upIntent);
     }
     <span class="keyword">super</span>.onBackPressed();
}
</code></pre></li>
</ol>
<h1 id="兼容低版本修改图片的tintColor">兼容低版本修改图片的tintColor</h1><pre><code><span class="tag">drawable</span><span class="class">.setColorFilter</span>(<span class="tag">Color</span><span class="class">.RED</span>,<span class="tag">PorterDuff</span><span class="class">.Mode</span><span class="class">.SRC_IN</span>);
</code></pre><h1 id="使用dumpsys命令查看系统信息">使用dumpsys命令查看系统信息</h1><p>dumpsys命令很强大，可以查看当前系统的信息，用的还比较多，dumpsys常用命令如下：</p>
<pre><code>dumpsys     <span class="string">[options]</span>
             meminfo 显示内存信息
             cpuinfo 显示cpu信息
             account 显示accounts信息
             activity 显示所有的activities信息
             window 显示键盘、窗口信息
             wifi 显示wifi信息
</code></pre><p>例如：查看某个程序内部内存信息</p>
<pre><code>adb <span class="built_in">shell</span> dumpsys meminfo 包名 <span class="operator">or</span> pid    
</code></pre><p>再或者查看当前打开app的页面信息，这个很有用</p>
<pre><code>adb <span class="keyword">shell</span> dumpsys <span class="keyword">window</span> windows | grep -<span class="keyword">E</span> 'mCurrentFocus'    
</code></pre><p>结果类似如下：</p>
<pre><code>mCurrentFocus=Window{<span class="number">43469</span>d60 u0 <span class="keyword">com</span>.jikexueyuan.geekacademy.debug/<span class="keyword">com</span>.jikexueyuan.geekacademy.ui.activity.ActivityHomeV3}
</code></pre><h1 id="Recyleview的LayoutManager设置成StaggeredGridLayoutManager后获取某个字view的spanIndex（也就是在第几列）">Recyleview的LayoutManager设置成StaggeredGridLayoutManager后获取某个字view的spanIndex（也就是在第几列）</h1><pre><code><span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">MyItemDecoration</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">RecyclerView</span>.<span class="title">ItemDecoration</span> {</span>
    <span class="annotation">@Override</span>
    public void getItemOffsets(<span class="type">Rect</span> outRect, <span class="type">View</span> view, <span class="type">RecyclerView</span> parent, <span class="type">RecyclerView</span>.<span class="type">State</span> state) {
        <span class="keyword">super</span>.getItemOffsets(outRect, view, parent, state);
        int index = ((<span class="type">StaggeredGridLayoutManager</span>.<span class="type">LayoutParams</span>) view.getLayoutParams()).getSpanIndex();
    }
}
</code></pre><h1 id="如果获取当前手机为每个app分配的堆大小，也就是内存大小">如果获取当前手机为每个app分配的堆大小，也就是内存大小</h1><pre><code>ActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE)<span class="comment">;  </span>
int heapSize = manager.getMemoryClass()<span class="comment">;</span>
</code></pre><p>注意：这里获得heapSize是M为单位返回的 </p>
<h1 id="duplicate_entry:_android/support/annotation/ColorRes-class">duplicate entry: android/support/annotation/ColorRes.class</h1><p>解决方案，只需要在app下的build.gradle加入以下配置就好了：</p>
<pre><code><span class="keyword">configurations</span> { all*.<span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.android.support'</span>, module: <span class="string">'support-v4'</span> }
</code></pre><h1 id="待续…">待续…</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="onCreate中计算View的高度">onCreate中计算View的高度</h1><p>可以借助getViewTreeObserver().addOnGlobalLayoutListener()来获得宽度或者高度，示例代码如下：</p>
<pre><code>mWebView.getViewTreeObserver().addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() {
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>{
                mWebView.getWidth();
                mWebView.getHeight();
                <span class="comment">//防止调用多次</span>
                mWebView.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);
            }
        });
</code></pre><h1 id="PopupWindow计算高度">PopupWindow计算高度</h1><p>PopupWindow在初始化创建好后，我想知道它的高度和宽度，可以这样计算：</p>
<pre><code><span class="tag">popupWindow</span><span class="class">.getContentView</span>()<span class="class">.measure</span>(0, 0);
<span class="tag">popupWindow</span><span class="class">.getContentView</span>()<span class="class">.getMeasuredWidth</span>();
<span class="tag">popupWindow</span><span class="class">.getContentView</span>()<span class="class">.getMeasuredHeight</span>();
</code></pre>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IOS开发小技巧]]></title>
    <link href="http://hanhailong.com/2016/01/12/IOS%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://hanhailong.com/2016/01/12/IOS开发小技巧/</id>
    <published>2016-01-12T08:05:17.000Z</published>
    <updated>2016-01-24T15:05:44.000Z</updated>
    <content type="html"><![CDATA[<h2>IOS配置某个圆角大小</h2>

<p>iOS开发中各种圆角也随处可见,最简单给控件添加圆角的方式就是给视图的layer设置corner属性了:</p>
<pre><code><span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span><span class="variable">.cornerRadius</span> = <span class="number">5.</span>f;  
<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span><span class="variable">.masksToBounds</span> = <span class="literal">YES</span>;  
</code></pre><p>这种方式无法配置圆角数量(只能添加view的四个角全为圆角),无法配置某个圆角大小.</p>
<p>这个问题我们可以用<em>UIBezierPath</em>来完美解决，示例代码如下：</p>
<pre><code><span class="built_in">UIBezierPath</span> *maskPath = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span> byRoundingCorners:<span class="built_in">UIRectCornerTopLeft</span> | <span class="built_in">UIRectCornerBottomLeft</span> cornerRadii:<span class="built_in">CGSizeMake</span>(<span class="number">20</span>, <span class="number">0</span>)];

<span class="built_in">CAShapeLayer</span> *maskLayer = [[<span class="built_in">CAShapeLayer</span> alloc] init];

maskLayer<span class="variable">.frame</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span>;

maskLayer<span class="variable">.path</span> = maskPath<span class="variable">.CGPath</span>;

<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span><span class="variable">.mask</span> = maskLayer;

<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span><span class="variable">.cornerRadius</span> = <span class="number">5.</span>f;
<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span><span class="variable">.masksToBounds</span> = <span class="literal">YES</span>;
</code></pre><p>想要配置某个角为圆角的话,只需要指定对应的<em>UIRectCorner</em>即可，<em>UIRectCorner</em>有五个值：</p>
<pre><code><span class="built_in">UIRectCornerAllCorners</span> 全角
<span class="built_in">UIRectCornerTopLeft</span>    左上角
<span class="built_in">UIRectCornerTopRight</span>   右上角
<span class="built_in">UIRectCornerBottomLeft</span> 左下角
<span class="built_in">UIRectCornerBottomRight</span> 右下角
</code></pre><h2>UITableView分割线顶到头</h2>

<p>我们在使用tableview时会发现分割线的左边会短一些，通常可以使用setSeparatorInset:UIEdgeInsetsZero 来解决。但是升级到XCode6之后，在iOS8里发现没有效果。下面给出解决办法：</p>
<ol>
<li><p>第一步</p>
<p>  if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) {</p>
<pre><code>[<span class="literal">self</span>.<span class="built_in">table</span>View <span class="built_in">set</span>SeparatorInset:UIEdgeInsetsZero];
</code></pre><p>  }</p>
<p>  if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) {</p>
<pre><code>[<span class="literal">self</span>.<span class="built_in">table</span>View <span class="built_in">set</span>LayoutMargins:UIEdgeInsetsZero];
</code></pre><p>  }</p>
</li>
</ol>
<ol>
<li><p>第二步</p>
<pre><code><span class="tag">-</span> (void)<span class="tag">tableView</span>:(UITableView *)<span class="tag">tableView</span> <span class="tag">willDisplayCell</span>:(UITableViewCell *)<span class="tag">cell</span> <span class="tag">forRowAtIndexPath</span>:(NSIndexPath *)<span class="tag">indexPath</span>{
    <span class="tag">if</span> ([cell <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="attribute">setSeparatorInset</span>:)]) {
        <span class="attr_selector">[cell setSeparatorInset:UIEdgeInsetsZero]</span>;
    }
    <span class="tag">if</span> ([cell <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="attribute">setLayoutMargins</span>:)]) {
        <span class="attr_selector">[cell setLayoutMargins:UIEdgeInsetsZero]</span>;
    }
}
</code></pre></li>
</ol>
<p></p><h3>持续更新中…<h3><p></p>
</h3></h3>]]></content>
    <summary type="html">
    <![CDATA[<h2>IOS配置某个圆角大小</h2>

<p>iOS开发中各种圆角也随处可见,最简单给控件添加圆角的方式就是给视图的layer设置corner属性了:</p>
<pre><code><span class="keyword">self</span><span class="v]]>
    </summary>
    
      <category term="IOS" scheme="http://hanhailong.com/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java小知识总结]]></title>
    <link href="http://hanhailong.com/2016/01/11/Java%E5%B0%8F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://hanhailong.com/2016/01/11/Java小知识总结/</id>
    <published>2016-01-11T09:41:10.000Z</published>
    <updated>2016-01-11T10:07:01.000Z</updated>
    <content type="html"><![CDATA[<h2>编译时、运行时</h2>

<p><strong>编译时</strong>顾名思义就是正在编译的时候.那啥叫编译呢?就是编译器帮你把源代码翻译成机器能识别的代码。例如：Java编译器把写的java文件编译成jvm能识别的class字节码文件。</p>
<p>而在编译的时候会涉及到一些比如常量折叠等技术，这个以后细讲！</p>
<p><strong>运行时</strong>就是代码跑起来了.被装载到内存中去了.(你的代码保存在磁盘上没装入内存之前是个死家伙.只有跑到内存中才变成活的).而运行时类型检查就与前面讲的编译时类型检查(或者静态类型检查)不一样.不是简单的扫描代码.而是在内存中做些操作,做些判断.</p>
<h2>下面的代码片段中，行A和行B所标识的代码有什么区别呢？</h2>

<pre><code><span class="keyword">public</span> <span class="keyword">class</span> ConstantFolding {

    <span class="keyword">static</span> final  <span class="keyword">int</span> number1 = <span class="number">5</span>;

    <span class="keyword">static</span> final  <span class="keyword">int</span> number2 = <span class="number">6</span>;

    <span class="keyword">static</span> <span class="keyword">int</span> number3 = <span class="number">5</span>;

    <span class="keyword">static</span> <span class="keyword">int</span> number4= <span class="number">6</span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[ ] args)</span> </span>{

          <span class="keyword">int</span> product1 = number1 * number2;         <span class="comment">//line A</span>

          <span class="keyword">int</span> product2 = number3 * number4;         <span class="comment">//line B</span>

    }
}
</code></pre><p>在行A的代码中，product的值是在编译期计算的，行B则是在运行时计算的。如果你使用Java反编译器（例如，jd-gui）来反编译ConstantFolding.class文件的话，那么你就会从下面的结果里得到答案。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> ConstantFolding
{
  <span class="keyword">static</span> final <span class="keyword">int</span> number1 = <span class="number">5</span>;
  <span class="keyword">static</span> final <span class="keyword">int</span> number2 = <span class="number">6</span>;
  <span class="keyword">static</span> <span class="keyword">int</span> number3 = <span class="number">5</span>;
  <span class="keyword">static</span> <span class="keyword">int</span> number4 = <span class="number">6</span>;

  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[ ] args)</span>
  </span>{
      <span class="keyword">int</span> product1 = <span class="number">30</span>;
      <span class="keyword">int</span> product2 = number3 * number4;
  }
}
</code></pre><p>常量折叠是一种Java编译器使用的优化技术。由于final变量的值不会改变，因此就可以对它们优化。Java反编译器和javap命令都是查看编译后的代码（例如，字节码）的利器。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>编译时、运行时</h2>

<p><strong>编译时</strong>顾名思义就是正在编译的时候.那啥叫编译呢?就是编译器帮你把源代码翻译成机器能识别的代码。例如：Java编译器把写的java文件编译成jvm能识别的class字节码文件。</p>
<p>而在编译的时候]]>
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
      <category term="Java" scheme="http://hanhailong.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android进阶之ProGuard代码混淆]]></title>
    <link href="http://hanhailong.com/2015/12/28/Android%E8%BF%9B%E9%98%B6%E4%B9%8BProGuard%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    <id>http://hanhailong.com/2015/12/28/Android进阶之ProGuard代码混淆/</id>
    <published>2015-12-28T13:35:41.000Z</published>
    <updated>2016-01-29T03:47:30.000Z</updated>
    <content type="html"><![CDATA[<h2>简介</h2>

<p><a href="http://developer.android.com/intl/zh-cn/tools/help/proguard.html" target="_blank" rel="external">Proguard</a>工具通过移除无用的代码以及使用语义隐晦的名称来重命名类、字段和方法，从而达到压缩、优化和混淆代码的目的。最终您将获得一个较小的 .apk 文件，此文件更难于进行反向工程。由于 ProGuard 会使应用更难于进行反向工程，因此当应用使用对安全性要求极高的功能时（例如，当您向应用授予许可时），您必须使用此工具。</p>
<p>ProGuard 已集成到 Android 构建系统，所以您无需手动调用此工具。只有当您在发布模式下构建应用时，ProGuard 才会运行，因此当您在调试模式下构建应用时，就无需处理混淆后的代码。是否运行 ProGuard 完全由您决定，但我们强烈建议您运行该工具。</p>
<p>本文介绍如何启用和配置 ProGuard，以及如何使用 retrace 工具解码混淆后的堆栈跟踪信息。</p>
<p>除了基本的Proguard混淆外，还有一些其他的混淆方式和工具。例如：混淆资源</p>
<p><a href="http://tech.meituan.com/mt-android-resource-obfuscation.html" target="_blank" rel="external">美团资源混淆</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=208135658&amp;idx=1&amp;sn=ac9bd6b4927e9e82f9fa14e396183a8f&amp;scene=0#rd" target="_blank" rel="external">微信资源混淆</a></p>
<a id="more"></a>
<h2>开启Proguard</h2>

<ol>
<li><p>Ant、Eclipse构建</p>
<pre><code>&lt;project_root&gt;/project<span class="class">.properties</span> 文件中设置 proguard<span class="class">.config</span> 属性。该路径可以是绝对路径，也可以是项目根目录的相对路径。

proguard.config=proguard.cfg
</code></pre></li>
<li><p>AndroidStudio-Gradle构建</p>
<pre><code><span class="title">android</span> {
    <span class="title">buildTypes</span> {
        <span class="title">release</span> {
            <span class="title">minifyEnabled</span> <span class="built_in">true</span>
            proguardFile getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>)
        }
    }

    productFlavors {
        <span class="title">flavor1</span> {
        }
        <span class="title">flavor2</span> {
            <span class="title">proguardFile</span> <span class="string">'some-other-rules.txt'</span>
        }
    }
}
</code></pre></li>
</ol>
<p>提示:</p>
<p>getDefaultProguardFile()可以返回这两个文件的绝对路径。<br>proguardFile 可以配置多个混淆文件</p>
<h2>配置Proguard</h2>

<p>在某些情况下，<em>proguard.cfg或proguard-android.txt</em> 文件中的默认配置足以满足您的需求。不过，在很多情况下，ProGuard 很难做出正确分析，因此可能会移除它认为无用而实际上您的应用却需要的代码。部分示例如下：</p>
<ul>
<li>一个只在 AndroidManifest.xml 文件中引用的类</li>
<li>一个通过 JNI 调用的方法</li>
<li>动态引用的字段和方法</li>
</ul>
<p>默认的 <em>proguard.cfg或proguard-android.txt</em> 文件旨在涵盖一般的使用情形，但您可能会遇到异常情况，例如 ClassNotFoundException（此异常情况会在 ProGuard 删除您的应用调用的整个类时发生）。</p>
<p>您可以通过在 <em>proguard.cfg或proguard-android.txt</em> 文件中添加一个 <font color="red">-keep</font> 行，来修复因 ProGuard 在删除代码而造成的错误。例如：</p>
<pre><code>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> <span class="inheritance">&lt;<span class="parent">MyClass</span></span>&gt;</span></span>
</code></pre><p>在使用 -keep 选项时，您既有许多选择也有不少需要注意的方面，因此我们强烈建议您阅读 <a href="https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/introduction.html" target="_blank" rel="external">ProGuard</a> 手册，详细了解如何自定义您的配置文件。该手册中的“Keep 选项概述”和“示例”部分尤其有用；问题排查部分则概述了在 ProGuard 删除代码后您可能会遇到的其他常见问题。</p>
<p>下面给出一个常用的默认配置命令：</p>
<pre><code>-include {fileame}  从给定的文件中读取配置参数
-libraryjars libs/xxxx.jar 指定库jar包
-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Activity</span> 保留类不被删除
-<span class="title">keep</span> <span class="title">class</span> <span class="title">className</span>$<span class="title">InnerName</span></span>{ 保留内部类的属性和方法
    <span class="keyword">public</span> &lt;fields&gt;;
    <span class="keyword">public</span> &lt;methods&gt;;
}
-keepclassmembers <span class="class"><span class="keyword">class</span> * <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>{ 保留类的成员
    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.io.ObjectStreamField[] serialPersistentFields;
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream)</span></span>;
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream)</span></span>;
    java.lang.<span class="function">Object <span class="title">writeReplace</span><span class="params">()</span></span>;
    java.lang.<span class="function">Object <span class="title">readResolve</span><span class="params">()</span></span>;
}
-dontshrink 不压缩输入的类文件
-dontoptimize 不优化输入的类文件
-keepattributes *Annotation* 保留Annotation
-dontwarn xxx.xxx.** 不检查引用
</code></pre><h2>Proguard产生的文件</h2>

<p>当混淆后的代码输出堆栈跟踪信息时，方法名称会被混淆，即便仍能进行调试，难度也会很大。幸运的是，ProGuard 在每次运行时都会输出以下文件：</p>
<ol>
<li><p>dump.txt</p>
<p> 描述 .apk 文件中所有类文件的内部结构</p>
</li>
<li><p>mapping.txt</p>
<p> 列出原始与混淆后的类、方法和字段名称之间的对应关系。</p>
<p> Windows 上的 retrace.bat 脚本以及 Linux 或 Mac OS X 上的 retrace.sh 脚本可以将混淆后的堆栈跟踪信息转换成可读文件，此文件位于 <sdk_root>/tools/proguard/ 目录中。执行 retrace 工具的语法如下：</sdk_root></p>
<pre><code>retrace.bat|retrace.sh [-verbose] mapping.txt <span class="annotation">[&lt;stacktrace_file&gt;]</span>
</code></pre><p> 例如：</p>
<pre><code>retrace<span class="class">.bat</span> -verbose mapping<span class="class">.txt</span> obfuscated_trace.txt
</code></pre><p> 建议发布时应保留mapping.txt文件。</p>
</li>
<li><p>seeds.txt</p>
<p> 列出未混淆的类和成员</p>
</li>
<li><p>usage.txt</p>
<p> 列出从 .apk 删除的代码</p>
</li>
</ol>
<p></p><h2>@Keep注解来防止混淆</h2><p></p>
<p>写到这，你是不是发现了一个问题：非常的麻烦、一点都不灵活，而且通过-keep的方式防止混淆那种有共同特征的类、属性或方式非常有用，但是没有共同特征的呢？</p>
<p>这里介绍一种比较新颖、轻快的方法，通过@Keep注解来灵活的防止混淆，用起来非常的灵活、快捷、方便，怎样用呢？像普通的注解一样，如下：</p>
<pre><code><span class="comment">//防止混淆类</span>
<span class="variable">@Keep</span>
public class Person {}

<span class="comment">//防止混淆变量</span>
<span class="variable">@Keep</span>
public String name;

<span class="comment">//防止混淆方法</span>
<span class="variable">@Keep</span>
public int <span class="function">getAge</span>(){}
</code></pre><p>但是当你加上上面的注解后，发现@Keep并没有起作用，该混淆的还是混淆了，这是为什么呢？</p>
<p>原因目前Gradle还不支持@Keep混淆，Google只是定义好了一个这种注解，并没有实现它，也就是说@Keep目前只是一个空壳。这里我们来手动开启它，让它支持防止混淆，在你的<em>proguard.cfg或proguard-android.txt</em>配置文件里面加入以下代码：</p>
<pre><code>#手动启用support keep注解
-<span class="ruby">dontskipnonpubliclibraryclassmembers
</span>-<span class="ruby">printconfiguration
</span>-<span class="ruby">keep,allowobfuscation <span class="variable">@interface</span> android.support.annotation.<span class="constant">Keep</span>
</span>-<span class="ruby">keep <span class="variable">@android</span>.support.annotation.<span class="constant">Keep</span> <span class="class"><span class="keyword">class</span> *</span>
</span>-<span class="ruby">keepclassmembers <span class="class"><span class="keyword">class</span> * {</span>
</span>    @android.support.annotation.Keep *;
}
</code></pre><h2>Proguard相关语法</h2>

<p>后面的文件名，类名，或者包名等可以使用占位符代替<br>“?”表示一个字符 可以匹配多个字符，但是如果是一个类，不会匹配其前面的包名<br>“*”可以匹配多个字符，会匹配前面的包名。</p>
<ul>
<li>输入输出选项<ul>
<li>-include filename<br>从给定的文件中读取配置参数</li>
<li>-injars class_path<br>输入(即使用的) jar文件路径</li>
<li>-outjars class_path<br>输出 jar 路径</li>
<li>-libraryjars class_path<br>指定的jar将不被混淆</li>
<li>-skipnonpubliclibraryclasses<br>跳过(不混淆) jars中的 非public classes</li>
<li>-dontskipnonpubliclibraryclasses<br>不跳过(混淆) jars中的 非public classes   默认选项</li>
<li>-dontskipnonpubliclibraryclassmembers<br>不跳过 jars中的非public classes的members</li>
<li>-keepdirectories [directory_filter]<br>指定目录 keep 在 out jars中  <ul>
<li>保持不变的选项（混淆不进行处理的内容）</li>
</ul>
</li>
<li>-keep {Modifier} {class_specification}<br>保护指定的类文件和类的成员</li>
<li>-keepclassmembers {modifier} {class_specification}<br>保护指定类的成员，如果此类受到保护他们会保护的更好</li>
<li>-keepclasseswithmembers {class_specification}<br>保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。</li>
<li>-keepnames {class_specification}<br>保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除）</li>
<li>-keepclassmembernames {class_specification}<br>保护指定的类的成员的名称（如果他们不会压缩步骤中删除）</li>
<li>-keepclasseswithmembernames {class_specification}<br>保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后）</li>
<li>-printseeds {filename}<br>列出类和类的成员-keep选项的清单，标准输出到给定的文件<ul>
<li>压缩选项</li>
</ul>
</li>
<li>-dontshrink<br>不启用 shrink。shrink操作默认启用，主要的作用是将一些无效代码给移除，即没有被显示调用的代码。</li>
<li>-printusage [filename]<br>打印被移除的代码，在标准输出</li>
<li>-whyareyoukeeping class_specification<br>打印 在shrink过程中 为什么有些代码被 keep<ul>
<li>优化选项</li>
</ul>
</li>
<li>-dontoptimize<br>该选项表示 不启用。optimization，默认启用<br>当不使用该选项时，下面的才有效</li>
<li>-optimizations optimization_filter<br>根据optimization_filter指定要优化的文件</li>
<li>-optimizationpasses n<br>优化数量 n  </li>
<li>-assumenosideeffects class_specification<br>优化时允许访问并修改类和类的成员的 访问修饰符，可能作用域会变大。</li>
<li>-mergeinterfacesaggressively<br>合并接口，即使它们的实现类未实现合并后接口的所有方法。<ul>
<li>混淆选项</li>
</ul>
</li>
<li>-dontobfuscate<br>不混淆</li>
<li>-printmapping [filename]<br>打印 映射旧名到新名</li>
<li>-applymapping filename<br>打印相关</li>
<li>-obfuscationdictionary filename<br>指定外部模糊字典</li>
<li>-classobfuscationdictionary filename<br>指定class模糊字典</li>
<li>-packageobfuscationdictionary filename<br>指定package模糊字典</li>
<li>-overloadaggressively<br>过度加载，多个属性和方法使用相同的名字，只是参数和返回类型不同 可能各种异常</li>
<li>-useuniqueclassmembernames<br>类和类成员都使用唯一的名字</li>
<li>-dontusemixedcaseclassnames<br>不使用大小写混合类名</li>
<li>-keeppackagenames [package_filter]<br>保持packagename 不混淆</li>
<li>-flattenpackagehierarchy [package_name]<br>指定重新打包,所有包重命名,这个选项会进一步模糊包名 好东西<br>将包里的类混淆成n个再重新打包到一个个的package中，注：混淆是有用，但是我用的时候安装会崩溃，不知道为什么？</li>
<li>-repackageclasses [package_name]<br>将包里的类混淆成n个再重新打包到一个统一的package中  会覆盖flattenpackagehierarchy选项</li>
<li>-keepattributes [attribute_filter]<br>混淆时可能被移除下面这些东西，如果想保留，需要用该选项。“Annotation、Exceptions, Signature, Deprecated, SourceFile, SourceDir, LineNumberTable”<ul>
<li>预校验选项</li>
</ul>
</li>
<li>-dontpreverify<br>不预校验，默认选项<ul>
<li>通用选项</li>
</ul>
</li>
<li>-verbose<br>打印日志</li>
<li>-dontnote [class_filter]<br>不打印某些错误</li>
<li>-dontwarn [class_filter]<br>不打印警告信息</li>
<li>-ignorewarnings<br>忽略警告，继续执行</li>
<li>-printconfiguration [filename]<br>打印配置文件</li>
<li>-dump [filename]<br>指定打印类结构</li>
</ul>
</li>
</ul>
<h2> demo示例</h2>

<pre><code>##--- For:android默认 ---
-<span class="ruby">optimizationpasses <span class="number">5</span>  <span class="comment"># 指定代码的压缩级别</span>
</span>-<span class="ruby">allowaccessmodification <span class="comment">#优化时允许访问并修改有修饰符的类和类的成员</span>
</span>-<span class="ruby">dontusemixedcaseclassnames  <span class="comment"># 是否使用大小写混合</span>
</span>-<span class="ruby">dontskipnonpubliclibraryclasses  <span class="comment"># 是否混淆第三方jar</span>
</span>-<span class="ruby">dontpreverify  <span class="comment"># 混淆时是否做预校验</span>
</span>-<span class="ruby">verbose    <span class="comment"># 混淆时是否记录日志</span>
</span>-<span class="ruby">ignorewarnings  <span class="comment"># 忽略警告，避免打包时某些警告出现</span>
</span>-<span class="ruby">optimizations !code/simplification/arithmetic,!code/simplification/cast,!field/*,!<span class="class"><span class="keyword">class</span>/<span class="title">merging</span>/*  <span class="comment"># 混淆时所采用的算法</span></span>
</span>
-<span class="ruby">keepattributes *<span class="constant">Annotation</span>*
</span>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">google</span>.<span class="title">vending</span>.<span class="title">licensing</span>.<span class="title">ILicensingService</span></span>
</span>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">android</span>.<span class="title">vending</span>.<span class="title">licensing</span>.<span class="title">ILicensingService</span></span>
</span>-<span class="ruby">keepclasseswithmembernames <span class="class"><span class="keyword">class</span> * { <span class="comment"># 保持 native 方法不被混淆</span></span>
</span>    native &lt;methods&gt;;
}

-<span class="ruby">keepclassmembers public <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">View</span> {</span>
</span>   void set*(***);
   *** get*();
}

-<span class="ruby">keepclassmembers <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Activity</span> {</span>
</span>   public void *(android.view.View);
}

-<span class="ruby">keepclassmembers enum * {  <span class="comment"># 保持枚举 enum 类不被混淆</span>
</span>    public static **[] values();
    public static ** valueOf(java.lang.String);
}

-<span class="ruby">keep <span class="class"><span class="keyword">class</span> * <span class="title">implements</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Parcelable</span> { <span class="comment"># 保持 Parcelable 不被混淆</span></span>
</span>  public static final android.os.Parcelable$Creator *;
}

-<span class="ruby">keepclassmembers <span class="class"><span class="keyword">class</span> **.<span class="title">R</span>$* { <span class="comment">#不混淆R文件</span></span>
</span>    public static &lt;fields&gt;;
}

-<span class="ruby">dontwarn android.support.**
</span>##--- End android默认 ---

##--- For:不能被混淆的 ---
-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Activity</span></span>
</span>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Fragment</span></span>
</span>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Application</span></span>
</span>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Service</span></span>
</span>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">content</span>.<span class="title">BroadcastReceiver</span></span>
</span>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">content</span>.<span class="title">ContentProvider</span></span>
</span>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">backup</span>.<span class="title">BackupAgentHelper</span></span>
</span>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">preference</span>.<span class="title">Preference</span></span>
</span>
##--- For:保持自定义控件类不被混淆 ---
-<span class="ruby">keepclasseswithmembers <span class="class"><span class="keyword">class</span> * {</span>
</span>    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);
}
-<span class="ruby">keepclasseswithmembers <span class="class"><span class="keyword">class</span> * {</span>
</span>    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);
}
##--- For:android-support-v4 ---
-<span class="ruby">dontwarn android.support.v4.**
</span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.** { *;</span> }
</span>-<span class="ruby">keep interface android.support.v4.app.** { *; }
</span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.** { *;</span> }
</span>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.**</span>
</span>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.<span class="title">widget</span></span>
</span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.<span class="title">app</span>.** {*;</span>}
</span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> * <span class="title">extends</span> <span class="title">android</span>.<span class="title">support</span>.<span class="title">v4</span>.<span class="title">view</span>.** {*;</span>}
</span>
##--- For:Serializable ---
-<span class="ruby">keep <span class="class"><span class="keyword">class</span> * <span class="title">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> {*;</span>}
</span>-<span class="ruby">keepnames <span class="class"><span class="keyword">class</span> * <span class="title">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>
</span>-<span class="ruby">keepclassmembers <span class="class"><span class="keyword">class</span> * <span class="title">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> {*;</span>}
</span>
##--- For:Gson ---
-<span class="ruby">keepattributes *<span class="constant">Annotation</span>*
</span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">sun</span>.<span class="title">misc</span>.<span class="title">Unsafe</span> { *;</span> }
</span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">idea</span>.<span class="title">fifaalarmclock</span>.<span class="title">entity</span>.***</span>
</span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">google</span>.<span class="title">gson</span>.<span class="title">stream</span>.** { *;</span> }
</span>
##--- For:Remove log ---
-<span class="ruby">assumenosideeffects <span class="class"><span class="keyword">class</span> <span class="title">android</span>.<span class="title">util</span>.<span class="title">Log</span> {</span>
</span>    public static boolean isLoggable(java.lang.String, int);
    public static int v(...);
    public static int i(...);
    public static int w(...);
    public static int d(...);
    public static int e(...);
}

##--- For:attributes(未启用) ---
#-keepattributes SourceFile,LineNumberTable # 保持反编译工具能看到代码的行数，以及release包安装后出现异常信息可以知道在哪行代码出现异常，建议不启用
-<span class="ruby">keepattributes *<span class="constant">Annotation</span>* <span class="comment">#使用注解</span>
</span>-<span class="ruby">keepattributes <span class="constant">Signature</span> <span class="comment">#过滤泛型  出现类型转换错误时，启用这个</span>
</span>#-keepattributes *Exceptions*,EnclosingMethod  #没试过，未知效果
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2>简介</h2>

<p><a href="http://developer.android.com/intl/zh-cn/tools/help/proguard.html">Proguard</a>工具通过移除无用的代码以及使用语义隐晦的名称来重命名类、字段和方法，从而达到压缩、优化和混淆代码的目的。最终您将获得一个较小的 .apk 文件，此文件更难于进行反向工程。由于 ProGuard 会使应用更难于进行反向工程，因此当应用使用对安全性要求极高的功能时（例如，当您向应用授予许可时），您必须使用此工具。</p>
<p>ProGuard 已集成到 Android 构建系统，所以您无需手动调用此工具。只有当您在发布模式下构建应用时，ProGuard 才会运行，因此当您在调试模式下构建应用时，就无需处理混淆后的代码。是否运行 ProGuard 完全由您决定，但我们强烈建议您运行该工具。</p>
<p>本文介绍如何启用和配置 ProGuard，以及如何使用 retrace 工具解码混淆后的堆栈跟踪信息。</p>
<p>除了基本的Proguard混淆外，还有一些其他的混淆方式和工具。例如：混淆资源</p>
<p><a href="http://tech.meituan.com/mt-android-resource-obfuscation.html">美团资源混淆</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=208135658&amp;idx=1&amp;sn=ac9bd6b4927e9e82f9fa14e396183a8f&amp;scene=0#rd">微信资源混淆</a></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之如何避免Overdraw]]></title>
    <link href="http://hanhailong.com/2015/12/27/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DOverdraw/"/>
    <id>http://hanhailong.com/2015/12/27/Android性能优化之如何避免Overdraw/</id>
    <published>2015-12-27T12:14:37.000Z</published>
    <updated>2015-12-27T13:04:19.000Z</updated>
    <content type="html"><![CDATA[<h2>什么是Overdraw？</h2>

<p>Overdraw就是过度绘制，是指在一帧的时间内（16.67ms）像素被绘制了多次，理论上一个像素每次只绘制一次是最优的，但是由于重叠的布局导致一些像素会被多次绘制，而每次绘制都会对应到CPU的一组绘图命令和GPU的一些操作，当这个操作耗时超过16.67ms时，就会出现掉帧现象，也就是我们所说的卡顿，所以对重叠不可见元素的重复绘制会产生额外的开销，需要尽量减少Overdraw的发生。</p>
<p>Android提供了测量Overdraw的选项，在开发者选项－调试GPU过度绘制（Show GPU Overdraw），打开选项就可以看到当前页面Overdraw的状态，就可以观察屏幕的绘制状态。该工具会使用三种不同的颜色绘制屏幕，来指示overdraw发生在哪里以及程度如何，其中：</p>
<p>没有颜色： 意味着没有overdraw。像素只画了一次。</p>
<p>蓝色： 意味着overdraw 1倍。像素绘制了两次。大片的蓝色还是可以接受的（若整个窗口是蓝色的，可以摆脱一层）。</p>
<p>绿色： 意味着overdraw 2倍。像素绘制了三次。中等大小的绿色区域是可以接受的但你应该尝试优化、减少它们。</p>
<p>浅红： 意味着overdraw 3倍。像素绘制了四次，小范围可以接受。</p>
<p>暗红： 意味着overdraw 4倍。像素绘制了五次或者更多。这是错误的，要修复它们。</p>
<p><img src="http://jbcdn2.b0.upaiyun.com/2015/12/1f79c3f75b4b42bd4b2140ff7d14ee73.jpg" alt=""></p>
<p>那么我们怎么来消灭overdraw呢？总的原则就是：尽量避免重叠不可见元素的绘制，基于这个原则，我们大概可以想出以下几招： </p>
<a id="more"></a>
<h2>第一招：合理选择控件容器</h2>

<p>既然overdraw是因为重复绘制了同一片区域的像素点，那我们首先想到的是解决布局问题。Android提供的Layout控件主要包括LinearLayout、TableLayout、FrameLayout、RelativeLayout。俗话说条条大路通罗马，同一个界面我们可以使用不同的容器控件来表达，但是各个容器控件描述界面的复杂度是不一样的。一般来说LinearLayout最易，RelativeLayout较复杂。但是尺有所短，寸有所长，LinearLayout只能用来描述一个方向上连续排列的控件，而RelativeLayout几乎可以用于描述任意复杂度的界面。但是我又要说但是了，表达能力越强的容器控件，性能往往略低一些，因为系统需要将更多的时间花在计算子控件的位置上。综上所述：LinearLayout易用，效率高，表达能力有限。RelativeLayout复杂，表达能力强，效率稍逊。</p>
<p>那么对于同一界面而言，作为开发者考虑是使用尽量少的、表达能力强的RelativeLayout作为容器，还是选择多个、表达能力稍弱的LinearLayout来展示。从减少overdraw的角度来看，LinearLayout会增加控件数的层级，自然是RelativeLayout更优，但是当某一界面在使用LinearLayout并不会比RelativeLayout带来更多的控件数和控件层级时，LinearLayout则是首选。所以在表达界面的时候，作为一个有前瞻性的开发者要根据实际情况来选择合适容器控件，在保证性能的同时，尽量避免overdraw。</p>
<h2>第二招：去掉window的默认背景</h2>

<p>当我们使用了Android自带的一些主题时，window会被默认添加一个纯色的背景，这个背景是被DecorView持有的。当我们的自定义布局时又添加了一张背景图或者设置背景色，那么DecorView的background此时对我们来说是无用的，但是它会产生一次Overdraw，带来绘制性能损耗。</p>
<p>去掉window的背景可以在onCreate()中setContentView()之后调用</p>
<pre><code>getWindow().setBackgroundDrawable(<span class="literal">null</span>);
</code></pre><p>或者在theme中添加</p>
<pre><code><span class="label">android:</span>windowbackground=<span class="string">"null"</span>；
</code></pre><h2>第三招：去掉其他不必要的背景</h2>

<p>有时候为了方便会先给Layout设置一个整体的背景，再给子View设置背景，这里也会造成重叠，如果子View宽度mach_parent，可以看到完全覆盖了Layout的一部分，这里就可以通过分别设置背景来减少重绘。再比如如果采用的是selector的背景，将normal状态的color设置为“@android:color/transparent”,也同样可以解决问题。这里只简单举两个例子，我们在开发过程中的一些习惯性思维定式会带来不经意的Overdraw，所以开发过程中我们为某个View或者ViewGroup设置背景的时候，先思考下是否真的有必要，或者思考下这个背景能不能分段设置在子View上，而不是图方便直接设置在根View上。</p>
<h2>第四招：ClipRect &amp; QuickReject</h2>

<p>为了解决Overdraw的问题，Android系统会通过避免绘制那些完全不可见的组件来尽量减少消耗。但是不幸的是，对于那些过于复杂的自定义的View(通常重写了onDraw方法)，Android系统无法检测在onDraw里面具体会执行什么操作，系统无法监控并自动优化，也就无法避免Overdraw了。但是我们可以通过canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。除了clipRect方法之外，我们还可以使用canvas.quickreject()来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。</p>
<h2>第五招：ViewStub</h2>

<p>ViewStub是个什么东西？一句话总结：高效占位符。<br>我们经常会遇到这样的情况，运行时动态根据条件来决定显示哪个View或布局。常用的做法是把View都写在上面，先把它们的可见性都设为View.GONE，然后在代码中动态的更改它的可见性。这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点就是，耗费资源。虽然把View的初始可见View.GONE但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。<br>推荐的做法是使用android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。</p>
<pre><code>&lt;ViewStub
    android:<span class="property">id</span>=<span class="string">"@+id/stub_view"</span>
    android:inflatedId=<span class="string">"@+id/panel_stub"</span>
    android:layout=<span class="string">"@layout/progress_overlay"</span>
    android:layout_width=<span class="string">"fill_parent"</span>
    android:layout_height=<span class="string">"wrap_content"</span>
    android:layout_gravity=<span class="string">"bottom"</span> /&gt;
</code></pre><p>当你想加载布局时，可以使用下面其中一种方法：</p>
<pre><code>((ViewStub) findViewById(R.<span class="property">id</span>.stub_view)).setVisibility(View.VISIBLE);
View importPanel = ((ViewStub) findViewById(R.<span class="property">id</span>.stub_view)).inflate()
</code></pre><h2>第六招：Merge</h2>

<p>Merge标签有什么用呢？简单粗暴点回答：干掉一个view层级。</p>
<p>Merge的作用很明显，但是也有一些使用条件的限制。有两种情况下我们可以使用Merge标签来做容器控件。第一种子视图不需要指定任何针对父视图的布局属性，就是说父容器仅仅是个容器，子视图只需要直接添加到父视图上用于显示就行。另外一种是假如需要在LinearLayout里面嵌入一个布局（或者视图），而恰恰这个布局（或者视图）的根节点也是LinearLayout，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度。而这个时候如果我们使用merge根标签就可以避免那样的问题。另外Merge只能作为XML布局的根标签使用，当Inflate以开头的布局文件时，必须指定一个父ViewGroup，并且必须设定attachToRoot为true。<br>举个简单的例子吧：</p>
<pre><code>&lt;RelativeLayout 
<span class="label">xmlns:</span>android=<span class="string">"http://schemas.android.com/apk/res/android"</span> 
<span class="label">xmlns:</span>tools=<span class="string">"http://schemas.android.com/tools"</span> 
<span class="label">android:</span>layout_width=<span class="string">"match_parent"</span> 
<span class="label">android:</span>layout_height=<span class="string">"match_parent"</span> &gt; 
&lt;TextView 
<span class="label">android:</span>layout_width=<span class="string">"wrap_content"</span>  
<span class="label">android:</span>layout_height=<span class="string">"wrap_content"</span> 
<span class="label">android:</span>text=<span class="string">"merge标签使用"</span> /&gt;
&lt;/RelativeLayout&gt;
</code></pre><p>把上面这个XML加载到页面中，布局层级是RelativeLayout-TextView。但是采用下面的方式，把RelativeLayout提换成merge，RelativeLayout这一层级就被干掉了。</p>
<pre><code>&lt;merge
<span class="label">xmlns:</span>android=<span class="string">"http://schemas.android.com/apk/res/android"</span> 
<span class="label">xmlns:</span>tools=<span class="string">"http://schemas.android.com/tools"</span> 
<span class="label">android:</span>layout_width=<span class="string">"match_parent"</span> 
<span class="label">android:</span>layout_height=<span class="string">"match_parent"</span> &gt;
&lt;TextView  
<span class="label">android:</span>layout_width=<span class="string">"wrap_content"</span> 
<span class="label">android:</span>layout_height=<span class="string">"wrap_content"</span> 
 android:text=<span class="string">"merge标签使用"</span> /&gt;
&lt;/merge&gt;
</code></pre><h2>第七招：善用draw9patch</h2>

<p>给ImageView加一个边框，你肯定遇到过这种需求，通常在ImageView后面设置一张背景图，露出边框便完美解决问题，此时这个ImageView，设置了两层drawable，底下一层仅仅是为了作为图片的边框而已。但是两层drawable的重叠区域去绘制了两次，导致overdraw。<br>优化方案： 将背景drawable制作成draw9patch，并且将和前景重叠的部分设置为透明。由于Android的2D渲染器会优化draw9patch中的透明区域，从而优化了这次overdraw。 但是背景图片必须制作成draw9patch才行，因为Android 2D渲染器只对draw9patch有这个优化，否则，一张普通的Png，就算你把中间的部分设置成透明，也不会减少这次overdraw。</p>
<h2>第八招：慎用Alpha</h2>

<p>假如对一个View做Alpha转化，需要先将View绘制出来，然后做Alpha转化，最后将转换后的效果绘制在界面上。通俗点说，做Alpha转化就需要对当前View绘制两遍，可想而知，绘制效率会大打折扣，耗时会翻倍，所以Alpha还是慎用。</p>
<p>如果一定做Alpha转化的话，可以采用缓存的方式。</p>
<pre><code>view.setLayerType(LAYER_TYPE_HARDWARE)<span class="comment">;</span>
doSmoeThing()<span class="comment">;</span>
view.setLayerType(LAYER_TYPE_NONE)<span class="comment">;</span>
</code></pre><p>通过setLayerType方式可以将当前界面缓存在GPU中，这样不需要每次绘制原始界面，但是GPU内存是相当宝贵的，所以用完要马上释放掉。</p>
<h2>第九招：避免“OverDesign”</h2>

<p>overdraw会给APP带来不好的体验，overdraw产生的原因无外乎：复杂的Layout层级，重叠的View，重叠的背景这几种。开发人员无节制的View堆砌，究其根本无非是产品无节制的需求设计。有道是“由俭入奢易，由奢入俭难”，很多APP披着过度设计的华丽外衣，却忘了简单易用才是王道的本质，纷繁复杂的设计并不会给用户带来好的体验，反而会让用户有压迫感，产品本身也有可能因此变得卡顿。当然，一切抛开业务谈优化都是空中楼阁，这就需要产品设计也要有一个权衡，在复杂的业务逻辑与简单易用的界面展现中做一个平衡，而不是一味的OverDesign。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>什么是Overdraw？</h2>

<p>Overdraw就是过度绘制，是指在一帧的时间内（16.67ms）像素被绘制了多次，理论上一个像素每次只绘制一次是最优的，但是由于重叠的布局导致一些像素会被多次绘制，而每次绘制都会对应到CPU的一组绘图命令和GPU的一些操作，当这个操作耗时超过16.67ms时，就会出现掉帧现象，也就是我们所说的卡顿，所以对重叠不可见元素的重复绘制会产生额外的开销，需要尽量减少Overdraw的发生。</p>
<p>Android提供了测量Overdraw的选项，在开发者选项－调试GPU过度绘制（Show GPU Overdraw），打开选项就可以看到当前页面Overdraw的状态，就可以观察屏幕的绘制状态。该工具会使用三种不同的颜色绘制屏幕，来指示overdraw发生在哪里以及程度如何，其中：</p>
<p>没有颜色： 意味着没有overdraw。像素只画了一次。</p>
<p>蓝色： 意味着overdraw 1倍。像素绘制了两次。大片的蓝色还是可以接受的（若整个窗口是蓝色的，可以摆脱一层）。</p>
<p>绿色： 意味着overdraw 2倍。像素绘制了三次。中等大小的绿色区域是可以接受的但你应该尝试优化、减少它们。</p>
<p>浅红： 意味着overdraw 3倍。像素绘制了四次，小范围可以接受。</p>
<p>暗红： 意味着overdraw 4倍。像素绘制了五次或者更多。这是错误的，要修复它们。</p>
<p><img src="http://jbcdn2.b0.upaiyun.com/2015/12/1f79c3f75b4b42bd4b2140ff7d14ee73.jpg" alt=""></p>
<p>那么我们怎么来消灭overdraw呢？总的原则就是：尽量避免重叠不可见元素的绘制，基于这个原则，我们大概可以想出以下几招： </p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 性能优化之--使用线程池处理异步任务]]></title>
    <link href="http://hanhailong.com/2015/12/27/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    <id>http://hanhailong.com/2015/12/27/Android-性能优化之-使用线程池处理异步任务/</id>
    <published>2015-12-27T08:41:23.000Z</published>
    <updated>2015-12-27T12:10:00.000Z</updated>
    <content type="html"><![CDATA[<p>说到线程，我想大家都不陌生，因为在开发时候或多或少都会用到线程，而通常创建线程有两种方式：</p>
<ol>
<li>继承自Thread类</li>
<li>实现Runnable接口</li>
</ol>
<p>虽说这两种方式都可以创建出一个线程，不过它们之间还是有一点区别的，主要区别在于在多线程访问同一资源的情况下，用Runnable接口创建的线程可以处理同一资源，而用Thread类创建的线程则各自独立处理，各自拥有自己的资源。</p>
<p>所以，在Java中大多数多线程程序都是通过实现Runnable来完成的，而对于Android来说也不例外，当涉及到需要开启线程去完成某件事时，我们都会这样写：</p>
<pre><code><span class="tag">new</span> <span class="tag">Thread</span>(new <span class="function">Runnable</span>() {
    <span class="variable">@Override</span>
    public void <span class="function">run</span>() {
        <span class="comment">//do sth .</span>
    }
})<span class="class">.start</span>();
</code></pre><p>这段代码创建了一个线程并执行，它在任务结束后GC会自动回收该线程，一切看起来如此美妙，是的，它在线程并发不多的程序中确实不错，而假如这个程序有很多地方需要开启大量线程来处理任务，那么如果还是用上述的方式去创建线程处理的话，那么将导致系统的性能表现的非常糟糕，更别说在内存有限的移动设备上，主要的影响如下：</p>
<ol>
<li>线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失</li>
<li>大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM</li>
<li>大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿</li>
</ol>
<p>而针对上述所描述的问题，解决的办法归根到底就是：重用已有的线程，从而减少线程的创建。<br>所以这就涉及到线程池（ExecutorService）的概念了，线程池的基本作用就是进行线程的复用，下面将具体介绍线程池的使用</p>
<a id="more"></a>
<h2>ExecutorService</h2><br>通过上述分析，我们知道了通过new Thread().start()方式创建线程去处理任务的弊端，而为了解决这些问题，Java为我们提供了ExecutorService线程池来优化和管理线程的使用<br><br><h4>使用线程池管理线程的优点</h4><br><br>1. 线程的创建和销毁由线程池维护，一个线程在完成任务后并不会立即销毁，而是由后续的任务复用这个线程，从而减少线程的创建和销毁，节约系统的开销<br>2. 线程池旨在线程的复用，这就可以节约我们用以往的方式创建线程和销毁所消耗的时间，减少线程频繁调度的开销，从而节约系统资源，提高系统吞吐量<br>3. 在执行大量异步任务时提高了性能<br>4. Java内置的一套ExecutorService线程池相关的api，可以更方便的控制线程的最大并发数、线程的定时任务、单线程的顺序执行等<br><br><h2>ExecutorService简介</h2><br>通常来说我们说到线程池第一时间想到的就是它：<em>ExecutorService</em>，它是一个接口，其实如果要从真正意义上来说，它可以叫做线程池的服务，因为它提供了众多接口api来控制线程池中的线程，而真正意义上的线程池就是：<em>ThreadPoolExecutor</em>，它实现了<em>ExecutorService</em>接口，并封装了一系列的api使得它具有线程池的特性，其中包括工作队列、核心线程数、最大线程数等。<br><br><h4>线程池：ThreadPoolExecutor</h4><br>既然线程池就是ThreadPoolExecutor，所以我们要创建一个线程池只需要new ThreadPoolExecutor(…);就可以创建一个线程池，而如果这样创建线程池的话，我们需要配置一堆东西，非常麻烦，我们可以看一下它的构造方法就知道了：<br><br>    public ThreadPoolExecutor(int corePoolSize,<br>                                  int maximumPoolSize,<br>                                  long keepAliveTime,<br>                                  TimeUnit unit,<br>                                  BlockingQueue workQueue,<br>                                  ThreadFactory threadFactory,<br>                                  RejectedExecutionHandler handler) {…}<br><br><br>所以，官方也不推荐使用这种方法来创建线程池，而是推荐使用Executors的工厂方法来创建线程池，Executors类是官方提供的一个工厂类，它里面封装好了众多功能不一样的线程池，从而使得我们创建线程池非常的简便，主要提供了如下五种功能不一样的线程池：<br><br>1. <strong>newFixedThreadPool() ：</strong><br><br>    作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。<br>    栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按FIFO方式处理任务队列中的任务。<br>2. <strong>newCachedThreadPool() ：</strong><br><br>    作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。<br>    栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。<br><br>3. <strong>newSingleThreadExecutor() ：</strong><br><br>    作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。<br><br>4. <strong>newScheduledThreadPool() ：</strong><br><br>    作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。<br><br>5. <strong>newSingleThreadScheduledExecutor() ：</strong><br><br>    作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为1，而上面的可以指定线程池的大小。<br><br>好了，写了一堆来介绍这五种线程池的作用，接下来就是获取这五种线程池，通过Executors的工厂方法来获取：<br><br>        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);<br>        ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();<br>        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();<br>        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);<br>        ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor();<br><br>我们可以看到通过Executors的工厂方法来创建线程池极其简便，其实它的内部还是通过new ThreadPoolExecutor(…)的方式创建线程池的，我们看一下这些工厂方法的内部实现：<br><br>        public static ExecutorService newFixedThreadPool(int nThreads) {<br>            return new ThreadPoolExecutor(nThreads, nThreads,<br>                                          0L, TimeUnit.MILLISECONDS,<br>                                          new LinkedBlockingQueue());<br>        }<br>        public static ExecutorService newSingleThreadExecutor() {<br>            return new FinalizableDelegatedExecutorService<br>                (new ThreadPoolExecutor(1, 1,<br>                                        0L, TimeUnit.MILLISECONDS,<br>                                        new LinkedBlockingQueue()));<br>        }<br>        public static ExecutorService newCachedThreadPool() {<br>            return new ThreadPoolExecutor(0, Integer.MAX_VALUE,<br>                                          60L, TimeUnit.SECONDS,<br>                                          new SynchronousQueue());<br>        }<br><br>我们可以清楚的看到这些方法的内部实现都是通过创建一个ThreadPoolExecutor对象来创建的，正所谓万变不离其宗，所以我们要了解线程池还是得了解ThreadPoolExecutor这个线程池类，其中由于和定时任务相关的线程池比较特殊（newScheduledThreadPool()、newSingleThreadScheduledExecutor()），它们创建的线程池内部实现是由ScheduledThreadPoolExecutor这个类实现的，而ScheduledThreadPoolExecutor是继承于ThreadPoolExecutor扩展而成的，所以本质还是一样的，只不过多封装了一些定时任务相关的api，所以我们主要就是要了解ThreadPoolExecutor，从构造方法开始：<br><br>    public ThreadPoolExecutor(int corePoolSize,<br>                                  int maximumPoolSize,<br>                                  long keepAliveTime,<br>                                  TimeUnit unit,<br>                                  BlockingQueue workQueue,<br>                                  ThreadFactory threadFactory,<br>                                  RejectedExecutionHandler handler) {//…}<br><br>我们可以看到它构造方法的参数比较多，有七个，下面一一来说明这些参数的作用：<br><br><em> <strong>corePoolSize</strong>：线程池中的核心线程数量
</em> <strong>maximumPoolSize</strong>: 线程池中的最大线程数量<br><em> <strong>keepAliveTime</strong>: 这个就是上面说到的“保持活动时间“，上面只是大概说明了一下它的作用，不过它起作用必须在一个前提下，就是当线程池中的线程数量超过了corePoolSize时，它表示多余的空闲线程的存活时间，即：多余的空闲线程在超过keepAliveTime时间内没有任务的话则被销毁。而这个主要应用在缓存线程池中
</em> <strong>unit</strong>：它是一个枚举类型，表示keepAliveTime的单位，常用的如：TimeUnit.SECONDS（秒）、TimeUnit.MILLISECONDS（毫秒）<br><em> <strong>workQueue</strong>: 任务队列，主要用来存储已经提交但未被执行的任务，不同的线程池采用的排队策略不一样，稍后再讲
</em> <strong>threadFactory</strong>:线程工厂，用来创建线程池中的线程，通常用默认的即可<br><em> <strong>handler</strong>: 通常叫做拒绝策略，1、在线程池已经关闭的情况下 2、任务太多导致最大线程数和任务队列已经饱和，无法再接收新的任务 。在上面两种情况下，只要满足其中一种时，在使用execute()来提交新的任务时将会拒绝，而默认的拒绝策略是抛一个RejectedExecutionException异常<br><br>上面的参数理解起来都比较简单，不过workQueue这个任务队列却要再次说明一下，它是一个BlockingQueue对象，而泛型则限定它是用来存放Runnable对象的，刚刚上面讲了，不同的线程池它的任务队列实现肯定是不一样的，所以，保证不同线程池有着不同的功能的核心就是这个workQueue的实现了，细心的会发现在刚刚的用来创建线程池的工厂方法中，针对不同的线程池传入的workQueue也不一样，下面我总结一下这五种线程池分别用的是什么

</em>BlockingQueue*:<br><br>1. newFixedThreadPool()—&gt;LinkedBlockingQueue<br>2. newSingleThreadExecutor()—&gt;LinkedBlockingQueue<br>3. newCachedThreadPool()—&gt;SynchronousQueue<br>4. newScheduledThreadPool()—&gt;DelayedWorkQueue<br>5. newSingleThreadScheduledExecutor()—&gt;DelayedWorkQueue<br><br>这些队列分别表示：<br><br>    LinkedBlockingQueue：无界的队列<br>    SynchronousQueue：直接提交的队列<br>    DelayedWorkQueue：等待队列<br><br>当然实现了BlockingQueue接口的队列还有：ArrayBlockingQueue（有界的队列）、PriorityBlockingQueue（优先级队列）。这些队列的详细作用就不多介绍了。<br><br><h2>线程池ThreadPoolExecutor的使用</h2>

<p>使用线程池，其中涉及到一个极其重要的方法，即：</p>
<pre><code><span class="function"><span class="title">execute</span><span class="params">(Runnable command)</span></span>
</code></pre><p>该方法意为执行给定的任务，该任务处理可能在新的线程、已入池的线程或者正调用的线程，这由ThreadPoolExecutor的实现决定。</p>
<h4>newFixedThreadPool</h4>

<p>创建一个固定线程数量的线程池，示例为：</p>
<pre><code>ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="number">10</span>; i++) {
        final <span class="keyword">int</span> index = i;
        fixedThreadPool.execute(<span class="keyword">new</span> Runnable() {
             @<span class="function">Override
             <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                 String threadName = Thread.currentThread().getName();
                 Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span>+threadName+<span class="string">",正在执行第"</span> + index + <span class="string">"个任务"</span>);
                 <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">2000</span>);
                 } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                 }
             }
         });
     }
</code></pre><p>上述代码，我们创建了一个线程数为3的固定线程数量的线程池，同理该线程池支持的线程最大并发数也是3，而我模拟了10个任务让它处理，执行的情况则是首先执行前三个任务，后面7个则依次进入任务队列进行等待，执行完前三个任务后，再通过FIFO的方式从任务队列中取任务执行，直到最后任务都执行完毕。</p>
<p>为了体现出线程的复用，我特地在Log中加上了当前线程的名称，效果为：</p>
<p><img src="http://img.blog.csdn.net/20151116182357008" alt=""></p>
<h4>newSingleThreadExecutor</h4>

<p>创建一个只有一个线程的线程池，每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待线程处理完再依次处理任务队列中的任务，示例为：</p>
<pre><code>ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="number">10</span>; i++) {
            final <span class="keyword">int</span> index = i;
            singleThreadPool.execute(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    String threadName = Thread.currentThread().getName();
                    Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span>+threadName+<span class="string">",正在执行第"</span> + index + <span class="string">"个任务"</span>);
                    <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">1000</span>);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
</code></pre><p>代码还是差不多，只不过改了线程池的实现方式，效果我想大家都知道，即依次一个一个的处理任务，而且都是复用一个线程，效果为：</p>
<p><img src="http://img.blog.csdn.net/20151116182627850" alt=""></p>
<p>其实我们通过newSingleThreadExecutor()和newFixedThreadPool()的方法发现，创建一个singleThreadExecutorPool实际上就是创建一个核心线程数和最大线程数都为1的fixedThreadPool。</p>
<h4>newCachedThreadPool</h4>

<p>创建一个可以根据实际情况调整线程池中线程的数量的线程池，示例为：</p>
<pre><code>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="number">10</span>; i++) {
            final <span class="keyword">int</span> index = i;
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">1000</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
            cachedThreadPool.execute(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    String threadName = Thread.currentThread().getName();
                    Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">",正在执行第"</span> + index + <span class="string">"个任务"</span>);
                    <span class="keyword">try</span> {
                        <span class="keyword">long</span> time = index * <span class="number">500</span>;
                        Thread.sleep(time);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
</code></pre><p>为了体现该线程池可以自动根据实现情况进行线程的重用，而不是一味的创建新的线程去处理任务，我设置了每隔1s去提交一个新任务，这个新任务执行的时间也是动态变化的，所以，效果为：</p>
<p><img src="http://img.blog.csdn.net/20151116184528454" alt=""></p>
<h4>newScheduledThreadPool</h4><br>创建一个可以定时或者周期性执行任务的线程池，示例为：<br><br>    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);<br>            //延迟2秒后执行该任务<br>            scheduledThreadPool.schedule(new Runnable() {<br>                @Override<br>                public void run() {<br><br>                }<br>            }, 2, TimeUnit.SECONDS);<br>            //延迟1秒后，每隔2秒执行一次该任务<br>            scheduledThreadPool.scheduleAtFixedRate(new Runnable() {<br>                @Override<br>                public void run() {<br><br>                }<br>            }, 1, 2, TimeUnit.SECONDS);<br><br><h4> newSingleThreadScheduledExecutor </h4>

<p>创建一个可以定时或者周期性执行任务的线程池，该线程池的线程数为1，代码示例为：</p>
<pre><code>ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor();
        <span class="comment">//延迟1秒后，每隔2秒执行一次该任务</span>
        singleThreadScheduledPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                String threadName = Thread.currentThread().getName();
                Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">",正在执行"</span>);
            }
        },<span class="number">1</span>,<span class="number">2</span>,TimeUnit.SECONDS);
</code></pre><p>实际上这个和上面的没什么太大区别，只不过是线程池内线程数量的不同，效果为：</p>
<p><img src="http://img.blog.csdn.net/20151116194526184" alt=""></p>
<p>每隔2秒就会执行一次该任务</p>
<h2>自定义线程池ThreadPoolExecutor</h2>

<p>Java内置只为我们提供了五种常用的线程池，一般来说这足够用了，不过有时候我们也可以根据需求来自定义我们自己的线程池，而要自定义不同功能的线程池，上面我们也说了线程池功能的不同归根到底还是内部的BlockingQueue实现不同，所以，我们要实现我们自己相要的线程池，就必须从BlockingQueue的实现上做手脚，而上面也说了BlockingQueue的实现类有多个，那么这次我们就选用PriorityBlockingQueue来实现一个功能是按任务的优先级来处理的线程池。</p>
<ol>
<li><p><strong>首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下：</strong></p>
<pre><code>ExecutorService priorityThreadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">3</span>,<span class="number">0L</span>,TimeUnit.SECONDS,<span class="keyword">new</span> PriorityBlockingQueue());
</code></pre></li>
<li><p><strong>然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下：</strong></p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Comparable</span> </span>{
    <span class="keyword">private</span> <span class="keyword">int</span> priority;

    <span class="function"><span class="keyword">public</span> <span class="title">PriorityRunnable</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>{
        <span class="keyword">if</span> (priority <span class="number">0</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();
        <span class="keyword">this</span>.priority = priority;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PriorityRunnable another)</span> </span>{
        <span class="keyword">int</span> my = <span class="keyword">this</span>.getPriority();
        <span class="keyword">int</span> other = another.getPriority();
        <span class="keyword">return</span> my <span class="number">1</span> : my &gt; other ? -<span class="number">1</span> : <span class="number">0</span>;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        doSth();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> priority;
    }
}
</code></pre></li>
<li><p><strong>使用我们自己的PriorityRunnable提交任务，整体代码如下：</strong></p>
<pre><code>ExecutorService priorityThreadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">3</span>, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> PriorityBlockingQueue());
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="number">10</span>; i++) {
            final <span class="keyword">int</span> priority = i;
            priorityThreadPool.execute(<span class="keyword">new</span> PriorityRunnable(priority) {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>{
                    String threadName = Thread.currentThread().getName();
                    Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">",正在执行优先级为："</span> + priority + <span class="string">"的任务"</span>);
                    <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">2000</span>);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
</code></pre></li>
</ol>
<h4>测试效果</h4>

<p>我们看下刚刚自定义的线程池是否达到了我们想要的功能，即根据任务的优先级进行优先处理任务，效果如下：</p>
<p><img src="http://img.blog.csdn.net/20151116212159326" alt=""></p>
<p>可以从执行结果中看出，由于核心线程数设置为3，刚开始时，系统有3个空闲线程，所以无须使用任务队列，而是直接运行前三个任务，而后面再提交任务时由于当前没有空闲线程所以加入任务队列中进行等待，此时，由于我们的任务队列实现是由PriorityBlockingQueue实现的，所以进行等待的任务会经过优先级判断，优先级高的放在队列前面先处理。从效果图中也可以看到后面的任务是先执行优先级高的任务，然后依次递减。</p>
<h4>优先级线程池的优点</h4>

<p>从上面我们可以得知，创建一个优先级线程池非常有用，它可以在线程池中线程数量不足或系统资源紧张时，优先处理我们想要先处理的任务，而优先级低的则放到后面再处理，这极大改善了系统默认线程池以FIFO方式处理任务的不灵活</p>
<h2>扩展线程池ThreadPoolExecutor</h2>

<p>除了内置的功能外，ThreadPoolExecutor也向外提供了三个接口供我们自己扩展满足我们需求的线程池，这三个接口分别是：</p>
<pre><code><span class="function"><span class="title">beforeExecute</span><span class="params">()</span></span> – 任务执行前执行的方法
<span class="function"><span class="title">afterExecute</span><span class="params">()</span></span> -任务执行结束后执行的方法
<span class="function"><span class="title">terminated</span><span class="params">()</span></span> -线程池关闭后执行的方法
</code></pre><p>这三个方法在ThreadPoolExecutor内部都没有实现</p>
<p>前面两个方法我们可以在ThreadPoolExecutor内部的runWorker()方法中找到，而runWorker()是ThreadPoolExecutor的内部类Worker实现的方法，Worker它实现了Runnable接口，也正是线程池内处理任务的工作线程，而Worker.runWorker()方法则是处理我们所提交的任务的方法，它会同时被多个线程访问，所以我们看runWorker()方法的实现，由于涉及到多个线程的异步调用，必然是需要使用锁来处理，而这里使用的是Lock来实现的，我们来看看runWorker()方法内主要实现：</p>
<p><img src="http://img.blog.csdn.net/20151117141139792" alt=""></p>
<p>可以看到在task.run()之前和之后分别调用了beforeExecute和afterExecute方法，并传入了我们的任务Runnable对象</p>
<p>而terminated()则是在关闭线程池的方法中调用，而关闭线程池有两个方法，我贴其中一个：</p>
<p><img src="http://img.blog.csdn.net/20151117141553421" alt=""></p>
<p>所以，我们要扩展线程池，只需要重写这三个方法，并实现我们自己的功能即可，这三个方法分别都会在任务执行前调用、任务执行完成后调用、线程池关闭后调用。<br>这里我验证一下，继承自ThreadPoolExecutor 并实现那三个方法：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue workQueue)</span> </span>{
        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>{
        <span class="keyword">super</span>.beforeExecute(t, r);
        String threadName = t.getName();
        Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">"准备执行任务！"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>{
        <span class="keyword">super</span>.afterExecute(r, t);
        String threadName = Thread.currentThread().getName();
        Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">"任务执行结束！"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.terminated();
        Log.v(<span class="string">"zxy"</span>, <span class="string">"线程池结束！"</span>);
    }
}
</code></pre><p>而运行后的结果则是，这正符合刚刚说的：</p>
<pre><code><span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">51.184</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程：pool-<span class="number">6</span>-thread-<span class="number">1</span>准备执行任务！
<span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">51.184</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程：pool-<span class="number">6</span>-thread-<span class="number">1</span>正在执行任务！
<span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">53.184</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程：pool-<span class="number">6</span>-thread-<span class="number">1</span>任务执行结束！
<span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">58.896</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程池结束！
</code></pre><p>所以，在上面我们的优先级线程池的代码上，我们再扩展一个具有暂停功能的优先级线程池，代码如下：<br>具有暂时功能的线程池：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PausableThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>{
    <span class="keyword">private</span> <span class="keyword">boolean</span> isPaused;
    <span class="keyword">private</span> ReentrantLock pauseLock = <span class="keyword">new</span> ReentrantLock();
    <span class="keyword">private</span> Condition unpaused = pauseLock.newCondition();

    <span class="function"><span class="keyword">public</span> <span class="title">PausableThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue workQueue)</span> </span>{
        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>{
        <span class="keyword">super</span>.beforeExecute(t, r);
        pauseLock.lock();
        <span class="keyword">try</span> {
            <span class="keyword">while</span> (isPaused) unpaused.await();
        } <span class="keyword">catch</span> (InterruptedException ie) {
            t.interrupt();
        } <span class="keyword">finally</span> {
            pauseLock.unlock();
        }

    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>{
        pauseLock.lock();
        <span class="keyword">try</span> {
            isPaused = <span class="keyword">true</span>;
        } <span class="keyword">finally</span> {
            pauseLock.unlock();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>{
        pauseLock.lock();
        <span class="keyword">try</span> {
            isPaused = <span class="keyword">false</span>;
            unpaused.signalAll();
        } <span class="keyword">finally</span> {
            pauseLock.unlock();
        }
    }
}
</code></pre><p>然后结合上面的优先级线程池的实现，创建具有暂停功能的优先级线程池：</p>
<pre><code>PausableThreadPoolExecutor pausableThreadPoolExecutor = <span class="keyword">new</span> PausableThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> PriorityBlockingQueue());
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="number">100</span>; i++) {
            final <span class="keyword">int</span> priority = i;
            pausableThreadPoolExecutor.execute(<span class="keyword">new</span> PriorityRunnable(priority) {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>{
                    runOnUiThread(<span class="keyword">new</span> Runnable() {
                        @<span class="function">Override
                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                            textView.setText(priority + <span class="string">""</span>);
                        }
                    });
                    <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">1000</span>);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
</code></pre><p>这里我为了演示效果，把这个线程池设为只有一个线程，然后直接在TextView中显示当前执行的任务的优先级，然后设置个开关，控制线程池的暂停与开始：</p>
<pre><code><span class="keyword">if</span> (isPause) {
    pausableThreadPoolExecutor.resume<span class="literal">()</span>;
    isPause = <span class="literal">false</span>;
} <span class="keyword">else</span> {
    pausableThreadPoolExecutor.pause<span class="literal">()</span>;
    isPause = <span class="literal">true</span>;
}
</code></pre><p>效果为：</p>
<p><img src="http://img.blog.csdn.net/20151117144914201" alt=""></p>
<p>从效果上来看，该线程池和优先级线程一样，而且还多了一个暂停与开始的功能</p>
<h2>优化线程池ThreadPoolExecutor</h2>

<p>虽说线程池极大改善了系统的性能，不过创建线程池也是需要资源的，所以线程池内线程数量的大小也会影响系统的性能，大了反而浪费资源，小了反而影响系统的吞吐量，所以我们创建线程池需要把握一个度才能合理的发挥它的优点，通常来说我们要考虑的因素有CPU的数量、内存的大小、并发请求的数量等因素，按需调整。</p>
<p><em>通常核心线程数可以设为CPU数量+1，而最大线程数可以设为CPU的数量\</em>2+1*</p>
<p>获取CPU数量的方法为：</p>
<pre><code><span class="tag">Runtime</span><span class="class">.getRuntime</span>()<span class="class">.availableProcessors</span>();
</code></pre><h2>shutdown()和shutdownNow()的区别</h2>

<p>关于线程池的停止，ExecutorService为我们提供了两个方法：shutdown和shutdownNow，这两个方法各有不同，可以根据实际需求方便的运用，如下：</p>
<ol>
<li>shutdown()方法在终止前允许执行以前提交的任务。</li>
<li>shutdownNow()方法则是阻止正在任务队列中等待任务的启动并试图停止当前正在执行的任务。</li>
</ol>
<h2>关于AsyncTask的实现</h2>

<p>大家都知道AsyncTask内部实现其实就是Thread+Handler。其中Handler是为了处理线程之间的通信，而这个Thread到底是指什么呢？通过AsyncTask源码可以得知，其实这个Thread是线程池，AsyncTask内部实现了两个线程池，分别是：串行线程池和固定线程数量的线程池。而这个固定线程数量则是通过CPU的数量决定的。</p>
<p>在默认情况下，我们大都通过AsyncTask::execute()来执行任务的，<br>，而execute()内部则是调用executeOnExecutor(sDefaultExecutor, params)方法执行的，第一个参数就是指定处理该任务的线程池，而默认情况下AsyncTask是传入串行线程池（在这里不讲版本的变化），也就是任务只能单个的按顺序执行，而我们要是想让AsyncTask并行的处理任务，大家都知道调用AsyncTask::executeOnExecutor(sDefaultExecutor, params)方法传入这个参数即可：AsyncTask.THREAD_POOL_EXECUTOR。<br>而这个参数的意义在于为任务指定了一个固定线程数量的线程池去处理，从而达到了并行处理的功能，我们可以在源码中看到AsyncTask.THREAD_POOL_EXECUTOR这个参数就是一个固定线程数量的线程池：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR
            = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,
                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>说到线程，我想大家都不陌生，因为在开发时候或多或少都会用到线程，而通常创建线程有两种方式：</p>
<ol>
<li>继承自Thread类</li>
<li>实现Runnable接口</li>
</ol>
<p>虽说这两种方式都可以创建出一个线程，不过它们之间还是有一点区别的，主要区别在于在多线程访问同一资源的情况下，用Runnable接口创建的线程可以处理同一资源，而用Thread类创建的线程则各自独立处理，各自拥有自己的资源。</p>
<p>所以，在Java中大多数多线程程序都是通过实现Runnable来完成的，而对于Android来说也不例外，当涉及到需要开启线程去完成某件事时，我们都会这样写：</p>
<pre><code><span class="tag">new</span> <span class="tag">Thread</span>(new <span class="function">Runnable</span>() {
    <span class="variable">@Override</span>
    public void <span class="function">run</span>() {
        <span class="comment">//do sth .</span>
    }
})<span class="class">.start</span>();
</code></pre><p>这段代码创建了一个线程并执行，它在任务结束后GC会自动回收该线程，一切看起来如此美妙，是的，它在线程并发不多的程序中确实不错，而假如这个程序有很多地方需要开启大量线程来处理任务，那么如果还是用上述的方式去创建线程处理的话，那么将导致系统的性能表现的非常糟糕，更别说在内存有限的移动设备上，主要的影响如下：</p>
<ol>
<li>线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失</li>
<li>大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM</li>
<li>大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿</li>
</ol>
<p>而针对上述所描述的问题，解决的办法归根到底就是：重用已有的线程，从而减少线程的创建。<br>所以这就涉及到线程池（ExecutorService）的概念了，线程池的基本作用就是进行线程的复用，下面将具体介绍线程池的使用</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之常见的内存泄漏]]></title>
    <link href="http://hanhailong.com/2015/12/27/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://hanhailong.com/2015/12/27/Android性能优化之常见的内存泄漏/</id>
    <published>2015-12-27T05:12:02.000Z</published>
    <updated>2015-12-27T05:41:37.000Z</updated>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>对于内存泄漏，我想大家在开发中肯定都遇到过，只不过内存泄漏对我们来说并不是可见的，因为它是在堆中活动，而要想检测程序中是否有内存泄漏的产生，通常我们可以借助LeakCanary、MAT等工具来检测应用程序是否存在内存泄漏，MAT是一款强大的内存分析工具，功能繁多而复杂，而LeakCanary则是由Square开源的一款轻量第三方内存泄漏检测工具，当它检测到程序中有内存泄漏的产生时，它将以最直观的方式告诉我们该内存泄漏是由谁产生的和该内存泄漏导致谁泄漏了而不能回收，供我们复查。</p>
<p>最近腾讯bugly也推出了三篇关于Android内存泄漏调优的文章：</p>
<ol>
<li><a href="http://bugly.qq.com/blog/?p=832" target="_blank" rel="external">内存泄露从入门到精通三部曲之基础知识篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=872" target="_blank" rel="external">内存泄露从入门到精通三部曲之排查方法篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=884" target="_blank" rel="external">内存泄露从入门到精通三部曲之常见原因与用户实践</a></li>
</ol>
<p>Realm同样给出了性能优化文章：</p>
<p><a href="https://realm.io/cn/news/droidcon-farber-improving-android-app-performance/" target="_blank" rel="external">10条提升Android性能的建议</a></p>
<a id="more"></a>
<h2>内存泄漏</h2>

<h4>为什么会产生内存泄漏？</h4>

<p>当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p>
<h4>内存泄漏对程序的影响？</h4>

<p>内存泄漏是造成应用程序OOM的主要原因之一！我们知道Android系统为每个应用程序分配的内存有限，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就造成了内存溢出而导致应用Crash。</p>
<h2>Android中常见的内存泄漏汇总</h2>

<h4>单例造成的内存泄漏</h4>

<p>单例模式非常受开发者的喜爱，不过使用的不恰当的话也会造成内存泄漏，由于单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。</p>
<p>如下这个典例：</p>
<pre><code>public class AppManager {
   <span class="keyword"> private</span><span class="keyword"> static</span> AppManager instance;
   <span class="keyword"> private</span> Context context;
   <span class="keyword"> private</span><span class="function"> AppManager(</span>Context context<span class="function">)</span> {
        this.context = context;
    }
   <span class="keyword"> public</span><span class="keyword"> static</span> AppManager<span class="function"> getInstance(</span>Context             context<span class="function">)</span> {
       <span class="instruction"> if </span>(instance != null<span class="function">)</span> {
           <span class="instruction"> instance </span>=<span class="instruction"> new </span>AppManager(context<span class="function">)</span>;
        }
       <span class="instruction"> return </span>instance;
    }
}
</code></pre><p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要： </p>
<ol>
<li>传入的是Application的Context：这将没有任何问题，因为单例的生命周期和Application的一样长</li>
<li>传入的是Activity的Context：当这个Context所对应的Activity退出时，由于该Context和Activity的生命周期一样长（Activity间接继承于Context），所以当前Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用。</li>
</ol>
<p>所以正确的单例应该修改为下面这种方式：</p>
<pre><code>public class AppManager {
   <span class="keyword"> private</span><span class="keyword"> static</span> AppManager instance;
   <span class="keyword"> private</span> Context context;
   <span class="keyword"> private</span><span class="function"> AppManager(</span>Context context<span class="function">)</span> {
        this.context =<span class="function"> context.getApplicationContext(</span><span class="function">)</span>;
    }
   <span class="keyword"> public</span><span class="keyword"> static</span> AppManager<span class="function"> getInstance(</span>Context context<span class="function">)</span> {
       <span class="instruction"> if </span>(instance != null<span class="function">)</span> {
           <span class="instruction"> instance </span>=<span class="instruction"> new </span>AppManager(context<span class="function">)</span>;
        }
       <span class="instruction"> return </span>instance;
    }
}
</code></pre><p>这样不管传入什么Context最终将使用Application的Context，而单例的生命周期和应用的一样长，这样就防止了内存泄漏</p>
<h4>非静态内部类创建静态实例造成的内存泄漏</h4>

<p>有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
    <span class="keyword">private</span> static <span class="type">TestResource</span> mResource = <span class="literal">null</span>;
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        <span class="keyword">if</span>(mResource == <span class="literal">null</span>){
            mResource = <span class="keyword">new</span> <span class="type">TestResource</span>();
        }
        <span class="comment">//...</span>
    }
    <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> {</span>
    <span class="comment">//...</span>
    }
}
</code></pre><p>这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而又使用了该非静态内部类创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为：<br>将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请使用ApplicationContext</p>
<h4>Handler造成的内存泄漏</h4>

<p>Handler的使用造成的内存泄漏问题应该说最为常见了，平时在处理网络任务或者封装一些请求回调等api都应该会借助Handler来处理，对于Handler的使用代码编写一不规范即有可能造成内存泄漏，如下示例：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
<span class="keyword">private</span> <span class="type">Handler</span> mHandler = <span class="keyword">new</span> <span class="type">Handler</span>() {
    <span class="annotation">@Override</span>
    public void handleMessage(<span class="type">Message</span> msg) {
    <span class="comment">//...</span>
    }
};
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        loadData();
    }
    <span class="keyword">private</span> void loadData(){
        <span class="comment">//...request</span>
        <span class="type">Message</span> message = <span class="type">Message</span>.obtain();
        mHandler.sendMessage(message);
    }
}
</code></pre><p>这种创建Handler的方式会造成内存泄漏，由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏，所以另外一种做法为：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
    <span class="keyword">private</span> <span class="type">MyHandler</span> mHandler = <span class="keyword">new</span> <span class="type">MyHandler</span>(<span class="keyword">this</span>);
    <span class="keyword">private</span> <span class="type">TextView</span> mTextView ;
    <span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Handler</span> {</span>
        <span class="keyword">private</span> <span class="type">WeakReference</span>&lt;<span class="type">Context</span>&gt; reference;
        public <span class="type">MyHandler</span>(<span class="type">Context</span> context) {
        reference = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;&gt;(context);
        }
        <span class="annotation">@Override</span>
        public void handleMessage(<span class="type">Message</span> msg) {
            <span class="type">MainActivity</span> activity = (<span class="type">MainActivity</span>) reference.get();
            <span class="keyword">if</span>(activity != <span class="literal">null</span>){
            activity.mTextView.setText(<span class="string">""</span>);
            }
        }
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        mTextView = (<span class="type">TextView</span>)findViewById(<span class="type">R</span>.id.textview);
        loadData();
    }

    <span class="keyword">private</span> void loadData() {
        <span class="comment">//...request</span>
        <span class="type">Message</span> message = <span class="type">Message</span>.obtain();
        mHandler.sendMessage(message);
    }
}
</code></pre><p>创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息，更准确的做法如下：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
    <span class="keyword">private</span> <span class="type">MyHandler</span> mHandler = <span class="keyword">new</span> <span class="type">MyHandler</span>(<span class="keyword">this</span>);
    <span class="keyword">private</span> <span class="type">TextView</span> mTextView ;
    <span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Handler</span> {</span>
        <span class="keyword">private</span> <span class="type">WeakReference</span>&lt;<span class="type">Context</span>&gt; reference;
        public <span class="type">MyHandler</span>(<span class="type">Context</span> context) {
        reference = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;&gt;(context);
        }
        <span class="annotation">@Override</span>
        public void handleMessage(<span class="type">Message</span> msg) {
            <span class="type">MainActivity</span> activity = (<span class="type">MainActivity</span>) reference.get();
            <span class="keyword">if</span>(activity != <span class="literal">null</span>){
            activity.mTextView.setText(<span class="string">""</span>);
            }
        }
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        mTextView = (<span class="type">TextView</span>)findViewById(<span class="type">R</span>.id.textview);
        loadData();
    }

    <span class="keyword">private</span> void loadData() {
        <span class="comment">//...request</span>
        <span class="type">Message</span> message = <span class="type">Message</span>.obtain();
        mHandler.sendMessage(message);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onDestroy() {
        <span class="keyword">super</span>.onDestroy();
        mHandler.removeCallbacksAndMessages(<span class="literal">null</span>);
    }
}
</code></pre><p>使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages();来移除指定的Runnable和Message。</p>
<h4>线程造成的内存泄漏</h4>

<p>对于线程造成的内存泄漏，也是平时比较常见的，异步任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成，<br>那么将导致Activity的内存资源无法回收，造成内存泄漏。正确的做法还是使用静态内部类的方式，如下：</p>
<pre><code><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">Void</span>&gt; </span>{
    <span class="keyword">private</span> WeakReference&lt;Context&gt; weakReference;

    <span class="function"><span class="keyword">public</span> <span class="title">MyAsyncTask</span><span class="params">(Context context)</span> </span>{
        weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>{
        SystemClock.sleep(<span class="number">10000</span>);
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Void aVoid)</span> </span>{
        <span class="keyword">super</span>.onPostExecute(aVoid);
        MainActivity activity = (MainActivity) weakReference.get();
        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) {
        <span class="comment">//...</span>
        }
    }
}
<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        SystemClock.sleep(<span class="number">10000</span>);
    }
}
<span class="comment">//——————</span>
<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();
<span class="keyword">new</span> MyAsyncTask(<span class="keyword">this</span>).execute();
</code></pre><p>这样就避免了Activity的内存资源泄漏，当然在Activity销毁时候也应该取消相应的任务AsyncTask::cancel()，避免任务在后台执行浪费资源。</p>
<h4>资源未关闭造成的内存泄漏</h4>

<p>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>
<h4>一些建议</h4>

<ol>
<li>对于生命周期比Activity长的对象如果需要应该使用ApplicationContext</li>
<li>对于需要在静态内部类中使用非静态外部成员变量（如：Context、View )，可以在静态内部类中使用弱引用来引用外部类的变量来避免内存泄漏</li>
<li>对于不再需要使用的对象，显示的将其赋值为null，比如使用完Bitmap后先调用recycle()，再赋为null</li>
<li>保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期</li>
<li><p>对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏：</p>
<ol>
<li>将内部类改为静态内部类</li>
<li>静态内部类中使用弱引用来引用外部类的成员变量</li>
</ol>
</li>
<li><p>在涉及到Context时先考虑ApplicationContext，当然它并不是万能的，对于有些地方则必须使用Activity的Context，对于Application，Service，Activity三者的Context的应用场景如下：</p>
</li>
</ol>
<p><img src="http://img.blog.csdn.net/20151123144226349" alt=""></p>
<p><strong>其中：</strong>NO1表示Application和Service可以启动一个Activity，不过需要创建一个新的task任务队列。而对于Dialog而言，只有在Activity中才能创建</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>前言</h2>

<p>对于内存泄漏，我想大家在开发中肯定都遇到过，只不过内存泄漏对我们来说并不是可见的，因为它是在堆中活动，而要想检测程序中是否有内存泄漏的产生，通常我们可以借助LeakCanary、MAT等工具来检测应用程序是否存在内存泄漏，MAT是一款强大的内存分析工具，功能繁多而复杂，而LeakCanary则是由Square开源的一款轻量第三方内存泄漏检测工具，当它检测到程序中有内存泄漏的产生时，它将以最直观的方式告诉我们该内存泄漏是由谁产生的和该内存泄漏导致谁泄漏了而不能回收，供我们复查。</p>
<p>最近腾讯bugly也推出了三篇关于Android内存泄漏调优的文章：</p>
<ol>
<li><a href="http://bugly.qq.com/blog/?p=832">内存泄露从入门到精通三部曲之基础知识篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=872">内存泄露从入门到精通三部曲之排查方法篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=884">内存泄露从入门到精通三部曲之常见原因与用户实践</a></li>
</ol>
<p>Realm同样给出了性能优化文章：</p>
<p><a href="https://realm.io/cn/news/droidcon-farber-improving-android-app-performance/">10条提升Android性能的建议</a></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sublime Text自动开启换行Word Wrap]]></title>
    <link href="http://hanhailong.com/2015/11/24/Sublime-Text%E8%87%AA%E5%8A%A8%E5%BC%80%E5%90%AF%E6%8D%A2%E8%A1%8CWord-Wrap/"/>
    <id>http://hanhailong.com/2015/11/24/Sublime-Text自动开启换行Word-Wrap/</id>
    <published>2015-11-24T10:02:27.000Z</published>
    <updated>2015-11-24T10:22:38.000Z</updated>
    <content type="html"><![CDATA[<p>Sublime Text，绝对是神器中的神器，之前在windows电脑上一直都是用nodepad++。mac上也没找到太好的编辑工具，之前曾用过破解版的<em>UltraEdit</em>，但是自从第一次用了Sublime Text后，就彻底的把它打入冷宫了！！</p>
<p>下面讲讲如何开启Sublime Text的自动换行功能，默认情况下是不开启的。当然你也可以点击导航栏上View-&gt;Word Wrap开启，不过对我们程序猿来说，还是太麻烦了。这里从根本上解决自动换行的问题。</p>
<p>解决方案：<br>    我这里用的是mac版本的，windows同理</p>
<pre><code>Preferences-&gt;Setting - <span class="built_ins">User</span>
</code></pre><p>在打开的<em>Preferences.sublime-settings</em>文件里面，你将会看到类似下面的内容：</p>
<pre><code>{
    "<span class="attribute">ignored_packages</span>":
    <span class="value">[
        <span class="string">"Markdown"</span>,
        <span class="string">"Vintage"</span>
    ]
</span>}
</code></pre><p>很明显，这是一个json格式的配置文件，在后面直接追加</p>
<pre><code>{ "<span class="attribute">word_wrap</span>" : <span class="value"><span class="literal">true</span> </span>}
</code></pre><p>修改之后的文件内容为：</p>
<pre><code>{
    "<span class="attribute">ignored_packages</span>":
    <span class="value">[
        <span class="string">"Markdown"</span>,
        <span class="string">"Vintage"</span>
    ]</span>,
    "<span class="attribute">word_wrap</span>":<span class="value"><span class="literal">true</span>
</span>}
</code></pre><p>重启Sublime Text后，你将会发现文字、代码超过一行后会自动换行！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Sublime Text，绝对是神器中的神器，之前在windows电脑上一直都是用nodepad++。mac上也没找到太好的编辑工具，之前曾用过破解版的<em>UltraEdit</em>，但是自从第一次用了Sublime Text后，就彻底的把它打入冷宫了！！</p>
<]]>
    </summary>
    
      <category term="Sublime Text" scheme="http://hanhailong.com/tags/Sublime-Text/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-小米桌面图标显示角标数]]></title>
    <link href="http://hanhailong.com/2015/11/23/Android-%E5%B0%8F%E7%B1%B3%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA%E8%A7%92%E6%A0%87%E6%95%B0/"/>
    <id>http://hanhailong.com/2015/11/23/Android-小米桌面图标显示角标数/</id>
    <published>2015-11-23T07:07:11.000Z</published>
    <updated>2015-11-23T10:02:09.000Z</updated>
    <content type="html"><![CDATA[<h3>基本介绍</h3>

<p>最近有群里问：怎样在小米手机桌面的图标上显示角标数，我看了下我的红米note手机，果然有的第三方app图标上显示角标数，尤其是微信和QQ。这让我立马想到了：小米是不是对通知栏做了手脚。立马我查了相关文档并做了相关的测试，发现果然如我猜测的：MIUI系统对通知栏做了手脚。它目前有两种情况：</p>
<ol>
<li>默认情况<br> 当第三方app向通知栏发送一条通知（一般不带进度条并且用户可以删除的通知），那么此时app icon的角标数就会显示1。<br> 这个时候app显示的角标数和通知栏里app发送的通知数是对应的，即向通知栏发多少条通知就会显示多少角标数。</li>
</ol>
<a id="more"></a>
<ol>
<li><p>定义角标数量<br> 如果想让app在通知栏里只显示一条通知，但角标数是多个怎么办呢？</p>
<p> 原理是通过反射拿到<em>Notification</em>的私有属性<em>extraNotification</em>，重点就是这个<em>extraNotification</em>,MIUI系统对这个重定义了，这个类在MIUI系统里是<em>android.app.MiuiNotification</em>这个类，这个类里面有个私有属性<em>messageCount</em>,我们只要改变这个<em>messageCount</em>值就能显示的改变app icon的角标数了。如下图所示：</p>
</li>
</ol>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/miui_notification.png?raw=true" alt="miuinotification">    </p>
<p>这里给出代码示例：</p>
<pre><code><span class="type">NotificationCompat</span>.<span class="type">Builder</span> builder = new <span class="type">NotificationCompat</span>.<span class="type">Builder</span>(this)
            .setSmallIcon(R.mipmap.ic_launcher)
            .setContentTitle(<span class="string">"小米角标"</span>)
            .setContentText(<span class="string">"miui桌面角标消息"</span>);

    <span class="type">NotificationManagerCompat</span> managerCompat = <span class="type">NotificationManagerCompat</span>.<span class="keyword">from</span>(this);

    <span class="type">Notification</span> notification = builder.build();
    <span class="keyword">try</span> {
        <span class="type">Field</span> field = notification.getClass().getDeclaredField(<span class="string">"extraNotification"</span>);

        <span class="type">Object</span> extraNotification = field.get(notification);

        <span class="type">Method</span> <span class="keyword">method</span> = extraNotification.getClass().getDeclaredMethod(<span class="string">"setMessageCount"</span>, <span class="type">int</span>.class);

        <span class="keyword">method</span>.invoke(extraNotification, <span class="number">10</span>);
    } catch (<span class="type">Exception</span> e) {
          e.printStackTrace();
    }

    managerCompat.notify(<span class="number">0</span>, notification);
</code></pre><p>上面的数字10就是要显示的角标数，我们看下结果：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/miui_app_icon_count.png?raw=true" alt="app-icon"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3>基本介绍</h3>

<p>最近有群里问：怎样在小米手机桌面的图标上显示角标数，我看了下我的红米note手机，果然有的第三方app图标上显示角标数，尤其是微信和QQ。这让我立马想到了：小米是不是对通知栏做了手脚。立马我查了相关文档并做了相关的测试，发现果然如我猜测的：MIUI系统对通知栏做了手脚。它目前有两种情况：</p>
<ol>
<li>默认情况<br> 当第三方app向通知栏发送一条通知（一般不带进度条并且用户可以删除的通知），那么此时app icon的角标数就会显示1。<br> 这个时候app显示的角标数和通知栏里app发送的通知数是对应的，即向通知栏发多少条通知就会显示多少角标数。</li>
</ol>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-部分作品鉴赏]]></title>
    <link href="http://hanhailong.com/2015/11/04/Android-%E9%83%A8%E5%88%86%E4%BD%9C%E5%93%81%E9%89%B4%E8%B5%8F/"/>
    <id>http://hanhailong.com/2015/11/04/Android-部分作品鉴赏/</id>
    <published>2015-11-04T15:32:50.000Z</published>
    <updated>2015-11-04T15:56:09.000Z</updated>
    <content type="html"><![CDATA[<p>时间过得真快，马上快毕业四年了，这里整理了下我做过的部分App，当然还有一些其他的App，不是外包就是没有纪念意义，这里就不列举了！</p>
<a id="more"></a>
<h3>51拉勾</h3>

<p><a href="http://www.wandoujia.com/apps/com.ydcy.lago.app" target="_blank" rel="external">51拉钩</a>是我做过的第二个商业Android客户端App，承载了我很多记忆，现在还记得当初和小伙伴们加班到晚上11点、12点甚至凌晨两三点的情景（岁月不饶人啊~~~）！！！</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-1.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-2.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-3.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-4.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-5.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-6.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-7.png?raw=true" alt="家庭首页"></p>
<h3>51听听</h3>

<p><a href="http://www.wandoujia.com/apps/com.ydcy.ting.app" target="_blank" rel="external">51听听</a>是继51拉钩之后的又一个商业App，这个App比较有意思，里面包括大量童话、唐诗三百首等儿童教育方面的故事！！！</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-1.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-2.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-3.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-4.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-5.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-6.png?raw=true" alt="51听"></p>
<h3>发镖</h3>

<p><a href="http://www.wandoujia.com/apps/com.cubead.appclient" target="_blank" rel="external">发镖</a>这是我加入北京博雅立方做过的唯一的一款App，包括IOS版本，这个App以前叫营销掌中宝，是国内首家最专业的营销推广平台，服务类目包括微信营销、百度营销、建站推广等多产品类目。</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-1.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-2.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-3.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-4.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-5.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-6.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-7.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-8.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-9.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-10.png?raw=true" alt="发镖"></p>
<h3>极客学院</h3>

<p><a href="http://www.jikexueyuan.com/app/" target="_blank" rel="external">极客学院</a>，中国最大的IT职业在线教育平台！！</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-1.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-2.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-3.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-4.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-5.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-6.png?raw=true" alt="jike"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>时间过得真快，马上快毕业四年了，这里整理了下我做过的部分App，当然还有一些其他的App，不是外包就是没有纪念意义，这里就不列举了！</p>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://hanhailong.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android版本-编译VLC]]></title>
    <link href="http://hanhailong.com/2015/10/27/Android%E7%89%88%E6%9C%AC-%E7%BC%96%E8%AF%91VLC/"/>
    <id>http://hanhailong.com/2015/10/27/Android版本-编译VLC/</id>
    <published>2015-10-27T13:54:31.000Z</published>
    <updated>2015-11-05T16:06:59.000Z</updated>
    <content type="html"><![CDATA[<h2>简述</h2>

<p>最近公司项目<a href="http://www.jikexueyuan.com/app/" target="_blank" rel="external">极客学院</a>在线播放器要加一个需求：支持播放倍数加速、支持字幕；之前用的是一个第三方的开源库<a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="external">ijkplayer</a>，这个库也非常的给力，它对ffmpeg做了很好的封装，不过不支持加速减速播放，所以弃用改成<a href="https://wiki.videolan.org/AndroidCompile" target="_blank" rel="external">VLC-Android</a>，IOS的在这<a href="https://wiki.videolan.org/IOSCompile" target="_blank" rel="external">VLC-IOS</a>.</p>
<a id="more"></a>
<p>这里记录下编译Android版本的过程和遇到的错误：</p>
<p>总体来说是比较顺利的，按照官方的wiki文档一步一步走下来，基本上没有遇到大问题，遇到唯一的问题是<a href="http://download.csdn.net/detail/hanhailong726188/9218615" target="_blank" rel="external">xz-5.0.3.tar.bz2</a>和<a href="http://download.csdn.net/detail/hanhailong726188/9218631" target="_blank" rel="external">protobuf-2.6.1.tar.gz</a>这两个库文件没有下载些来（因为被墙了），我单独下载安装的，这里我把这两个文件放到CSDN上了，有需要的自行下载！！</p>
<h2>编译过程</h2>

<p>编译的第一步肯定是需要下载一些必要的工具，如果你的系统是Linux，你可以通过api-get来安装：</p>
<pre><code><span class="label">sudo</span> apt-<span class="preprocessor">get</span> install automake ant autopoint cmake <span class="keyword">build-essential </span>libtool \
     patch pkg-config protobuf-compiler ragel <span class="keyword">subversion </span>unzip git
</code></pre><p>我这里用的是Mac Ox，所以采用<a href="http://brew.sh/" target="_blank" rel="external">HomeBrew</a>来安装，首先需要执行命令：</p>
<pre><code><span class="keyword">brew </span>install automake ant autopoint cmake <span class="keyword">build-essential </span>libtool \
     patch pkg-config protobuf-compiler ragel <span class="keyword">subversion </span>unzip git
</code></pre><p>然后等待上面的工具安装完成，安装完成后开始执行下一步</p>
<p>这里假设你已经装好<a href="http://developer.android.com/sdk/index.html" target="_blank" rel="external">Android SDK</a>和<a href="http://developer.android.com/tools/sdk/ndk/index.html" target="_blank" rel="external">Android NDK</a></p>
<h4>配置环境变量</h4>

<p>1.cd命令到当前用户目录下，打开.bash_profile文件：</p>
<pre><code><span class="title">cd</span> <span class="regexp">~
open</span> .bash_profile
</code></pre><p>如果没有.bash_profile，请touch新建一个.bash_profile</p>
<pre><code><span class="tag">touch</span> <span class="class">.bash_profile</span>
</code></pre><p>打开.bash_profile文件后，在文件里面输入</p>
<pre><code>export ANDROID_SDK=/Users/HanHailong/Library/Android/sdk
export ANDROID_NDK=/Users/HanHailong/NDK/android-ndk-r10e
export PATH=<span class="variable">$PATH</span>:<span class="variable">$ANDROID</span>_SDK/platform-tools:<span class="variable">$ANDROID</span>_SDK/tools
</code></pre><p>ANDROID_SDK和ANDROID_NDK后面的换成你自己对应的路径。</p>
<h4>克隆代码</h4>

<pre><code>git clone <span class="string">git:</span><span class="comment">//git.videolan.org/vlc-ports/android.git</span>
</code></pre><p></p><h5>编译工程</h5><br>将项目clone下来后就开始编译项目了，<br>cd命令到你clone下来的工程里面，执行命令：<p></p>
<pre><code>./compile.<span class="keyword">sh</span>
</code></pre><p>然后VLC会自动执行一长系列的下载、编译工作，这里需要等老长时间，如果你有vpn，最好开启vpn，因为一些用到的文件被墙了！！我这里就遇到坑了，<a href="http://download.csdn.net/detail/hanhailong726188/9218615" target="_blank" rel="external">xz-5.0.3.tar.bz2</a>和<a href="http://download.csdn.net/detail/hanhailong726188/9218631" target="_blank" rel="external">protobuf-2.6.1.tar.gz</a>下载失败，而导致VLC编译失败，没办法，只能将上面两个文件单独下载下来.</p>
<ol>
<li><p>解压并安装protobuf</p>
<p> 一步一步执行下面如下命令：</p>
<pre><code>tar -zxf protobuf-<span class="number">2.6</span><span class="number">.1</span>.tar.gz
cd protobuf-<span class="number">2.6</span><span class="number">.1</span>
./configure
make install
</code></pre></li>
</ol>
<ol>
<li><p>解压并安装xz</p>
<p> 一步一步执行下面如下命令：</p>
<pre><code>tar -zxf xz-<span class="number">5.0</span><span class="number">.3</span>.tar.bz2
cd xz-<span class="number">5.0</span><span class="number">.3</span>
./configure
make install
</code></pre></li>
</ol>
<p>执行完了后，继续回到VLC工程目录下执行命令：</p>
<pre><code>./compile.<span class="keyword">sh</span>
</code></pre><p>之后，VLC会继续执行下载、编译库文件，稍微等一段时间，快得几分钟，慢的十几分钟！！看编译成功后的截图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_android.png?raw=true" alt="VLC"></p>
<h4>编译结果</h4>

<p>编译成功后，会在<font color="red">vlc-android/build/outputs/apk</font>目录下生成编译后的apk包：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_apk.png?raw=true" alt="apk"></p>
<p>我们将其安装到真机上，效果图还是蛮不错的：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_1.png?raw=true" alt="image1"><br><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_2.png?raw=true" alt="image2"><br><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_3.png?raw=true" alt="image3"></p>
<p>VLC很强大，支持字幕，支持锁定屏幕，支持跳转到某个具体时间，支持0.25-4倍的慢放、快放、支持亮度调节、支持音量调节、支持快进、支持直播等特性，是做在线视频播放的绝佳选择之一！！！！</p>
<p>上面两个<a href="http://download.csdn.net/detail/hanhailong726188/9218615" target="_blank" rel="external">xz-5.0.3.tar.bz2</a>和<a href="http://download.csdn.net/detail/hanhailong726188/9218631" target="_blank" rel="external">protobuf-2.6.1.tar.gz</a>可以在这里下载！</p>
<p>最后，附上我编译好的项目<a href="https://github.com/hanhailong/VCL-Android" target="_blank" rel="external">VLC-Android</a>，这里我只编译了四种so包（armeabi-v7a、armeabi、x86、mips），有需要的朋友自行下载。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>简述</h2>

<p>最近公司项目<a href="http://www.jikexueyuan.com/app/">极客学院</a>在线播放器要加一个需求：支持播放倍数加速、支持字幕；之前用的是一个第三方的开源库<a href="https://github.com/Bilibili/ijkplayer">ijkplayer</a>，这个库也非常的给力，它对ffmpeg做了很好的封装，不过不支持加速减速播放，所以弃用改成<a href="https://wiki.videolan.org/AndroidCompile">VLC-Android</a>，IOS的在这<a href="https://wiki.videolan.org/IOSCompile">VLC-IOS</a>.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不错的IOS学习博客网站-IOS122]]></title>
    <link href="http://hanhailong.com/2015/10/22/%E4%B8%8D%E9%94%99%E7%9A%84IOS%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99-IOS122/"/>
    <id>http://hanhailong.com/2015/10/22/不错的IOS学习博客网站-IOS122/</id>
    <published>2015-10-22T08:58:51.000Z</published>
    <updated>2015-10-22T09:07:09.000Z</updated>
    <content type="html"><![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第四篇，只不过<a href="http://www.ios122.com/" target="_blank" rel="external">IOS122</a>只讲解IOS技术。</p>
<p>当我第一次打开这个博客的时候，我被里面的第三库资源震惊了，没想到作者整理了这么多的第三库资源。最重要的是，里面的博文质量非常高，绝对是IOS学习技术的最佳去处！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第四篇，只不过<a href="http://www.ios122.com/" targe]]>
    </summary>
    
      <category term="技术博客" scheme="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
