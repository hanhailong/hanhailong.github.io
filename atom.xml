<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[韩海龙的博客]]></title>
  <subtitle><![CDATA[学习总结 思考感悟 知识管理 代码分享]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://hanhailong.com/"/>
  <updated>2016-01-22T02:22:57.000Z</updated>
  <id>http://hanhailong.com/</id>
  
  <author>
    <name><![CDATA[韩海龙]]></name>
    <email><![CDATA[hanhailong.cool@163.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android小知识总结]]></title>
    <link href="http://hanhailong.com/2016/01/14/Android%E5%B0%8F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://hanhailong.com/2016/01/14/Android小知识总结/</id>
    <published>2016-01-14T15:00:27.000Z</published>
    <updated>2016-01-22T02:22:57.000Z</updated>
    <content type="html"><![CDATA[<h2>onCreate中计算View的高度</h2>

<p>可以借助getViewTreeObserver().addOnGlobalLayoutListener()来获得宽度或者高度，示例代码如下：</p>
<pre><code>mWebView.getViewTreeObserver().addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() {
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>{
                mWebView.getWidth();
                mWebView.getHeight();
                <span class="comment">//防止调用多次</span>
                mWebView.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);
            }
        });
</code></pre><h2>PopupWindow计算高度</h2>

<p>PopupWindow在初始化创建好后，我想知道它的高度和宽度，可以这样计算：</p>
<pre><code><span class="tag">popupWindow</span><span class="class">.getContentView</span>()<span class="class">.measure</span>(0, 0);
<span class="tag">popupWindow</span><span class="class">.getContentView</span>()<span class="class">.getMeasuredWidth</span>();
<span class="tag">popupWindow</span><span class="class">.getContentView</span>()<span class="class">.getMeasuredHeight</span>();
</code></pre><a id="more"></a>
<h2>Theme.NoDisplay</h2>

<p>在Android中想进行一些无界面的处理又不适合使用service时，此时可以在项目的AndroidManifest.xml文件中相应的Activity标签中添加这样一行：</p>
<pre><code><span class="symbol">android:</span>theme=”<span class="variable">@android</span><span class="symbol">:style/Theme</span>.<span class="constant">NoDisplay</span>
</code></pre><h2>activity父级activity的重建</h2>

<p>当我们从其他App跳转到我们应用内部时，可能我们跳转到的不是应用的第一层级页面而是深层次的页面，这时候我们需要在关闭应用内部页面时，对高层的页面进行重建。</p>
<ol>
<li><p>为activity指定父级activity</p>
<pre><code><span class="tag">&lt;<span class="title">application</span>&gt;</span> 
    <span class="comment">&lt;!-- 首层activity --&gt;</span>
    <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">"com.example.Mainactivity"</span>/&gt;</span> 
     <span class="comment">&lt;!-- 第二层级activity --&gt;</span>
     <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">"com.example.SecondeActivity"</span> <span class="attribute">android:parentActivityName</span>=<span class="value">"com.example.Mainactivity"</span> &gt;</span> 
         <span class="comment">&lt;!-- 父activity的meta-data，用来支持4.0以下版本 --&gt;</span>
         <span class="tag">&lt;<span class="title">meta-data</span> <span class="attribute">android:name</span>=<span class="value">"android.support.PARENT_ACTIVITY"</span> <span class="attribute">android:value</span>=<span class="value">"com.example.Mainactivity"</span> /&gt;</span>
     <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>
<span class="tag">&lt;/<span class="title">application</span>&gt;</span>
</code></pre></li>
<li><p>二级页面返回时，重建任务栈</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>{ 
    <span class="comment">// 获得指向父级activity的intent，NavUtils在support v4 包中 </span>
    Intent upIntent = NavUtils.getParentActivityIntent(<span class="keyword">this</span>); 
    <span class="comment">// 判断是否需要重建任务栈 </span>
    <span class="keyword">if</span> (NavUtils.shouldUpRecreateTask(<span class="keyword">this</span>, upIntent)) {
         <span class="comment">// 这个activity不是这个app任务的一部分, 所以当向上导航时创建</span>
         <span class="comment">// 用合成后退栈(synthesized back stack)创建一个新任务。</span>
          TaskStackBuilder.create(<span class="keyword">this</span>)
         <span class="comment">// 添加这个activity的所有父activity到后退栈中</span>
          .addNextIntentWithParentStack(upIntent)
           <span class="comment">// 向上导航到最近的一个父activity</span>
           .startActivities();
     } <span class="keyword">else</span> {
         <span class="comment">// 这个activity是这个app任务的一部分, 所以</span>
         <span class="comment">// 向上导航至逻辑父activity.</span>
         NavUtils.navigateUpTo(<span class="keyword">this</span>, upIntent);
     }
     <span class="keyword">super</span>.onBackPressed();
}
</code></pre></li>
</ol>
<h2>兼容低版本修改图片的tintColor</h2>

<pre><code><span class="tag">drawable</span><span class="class">.setColorFilter</span>(<span class="tag">Color</span><span class="class">.RED</span>,<span class="tag">PorterDuff</span><span class="class">.Mode</span><span class="class">.SRC_IN</span>);
</code></pre><h2>使用dumpsys命令查看系统信息</h2>

<p>dumpsys命令很强大，可以查看当前系统的信息，用的还比较多，dumpsys常用命令如下：</p>
<pre><code>dumpsys     <span class="string">[options]</span>
             meminfo 显示内存信息
             cpuinfo 显示cpu信息
             account 显示accounts信息
             activity 显示所有的activities信息
             window 显示键盘、窗口信息
             wifi 显示wifi信息
</code></pre><p>例如：查看某个程序内部内存信息</p>
<pre><code>adb <span class="built_in">shell</span> dumpsys meminfo 包名 <span class="operator">or</span> pid    
</code></pre><p>再或者查看当前打开app的页面信息，这个很有用</p>
<pre><code>adb <span class="keyword">shell</span> dumpsys <span class="keyword">window</span> windows | grep -<span class="keyword">E</span> 'mCurrentFocus'    
</code></pre><p>结果类似如下：</p>
<pre><code>mCurrentFocus=Window{<span class="number">43469</span>d60 u0 <span class="keyword">com</span>.jikexueyuan.geekacademy.debug/<span class="keyword">com</span>.jikexueyuan.geekacademy.ui.activity.ActivityHomeV3}
</code></pre><h2>待续…</h2>
]]></content>
    <summary type="html">
    <![CDATA[<h2>onCreate中计算View的高度</h2>

<p>可以借助getViewTreeObserver().addOnGlobalLayoutListener()来获得宽度或者高度，示例代码如下：</p>
<pre><code>mWebView.getViewTreeObserver().addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() {
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>{
                mWebView.getWidth();
                mWebView.getHeight();
                <span class="comment">//防止调用多次</span>
                mWebView.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);
            }
        });
</code></pre><h2>PopupWindow计算高度</h2>

<p>PopupWindow在初始化创建好后，我想知道它的高度和宽度，可以这样计算：</p>
<pre><code><span class="tag">popupWindow</span><span class="class">.getContentView</span>()<span class="class">.measure</span>(0, 0);
<span class="tag">popupWindow</span><span class="class">.getContentView</span>()<span class="class">.getMeasuredWidth</span>();
<span class="tag">popupWindow</span><span class="class">.getContentView</span>()<span class="class">.getMeasuredHeight</span>();
</code></pre>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IOS开发小技巧]]></title>
    <link href="http://hanhailong.com/2016/01/12/IOS%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://hanhailong.com/2016/01/12/IOS开发小技巧/</id>
    <published>2016-01-12T08:05:17.000Z</published>
    <updated>2016-01-24T15:05:44.000Z</updated>
    <content type="html"><![CDATA[<h2>IOS配置某个圆角大小</h2>

<p>iOS开发中各种圆角也随处可见,最简单给控件添加圆角的方式就是给视图的layer设置corner属性了:</p>
<pre><code><span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span><span class="variable">.cornerRadius</span> = <span class="number">5.</span>f;  
<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span><span class="variable">.masksToBounds</span> = <span class="literal">YES</span>;  
</code></pre><p>这种方式无法配置圆角数量(只能添加view的四个角全为圆角),无法配置某个圆角大小.</p>
<p>这个问题我们可以用<em>UIBezierPath</em>来完美解决，示例代码如下：</p>
<pre><code><span class="built_in">UIBezierPath</span> *maskPath = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span> byRoundingCorners:<span class="built_in">UIRectCornerTopLeft</span> | <span class="built_in">UIRectCornerBottomLeft</span> cornerRadii:<span class="built_in">CGSizeMake</span>(<span class="number">20</span>, <span class="number">0</span>)];

<span class="built_in">CAShapeLayer</span> *maskLayer = [[<span class="built_in">CAShapeLayer</span> alloc] init];

maskLayer<span class="variable">.frame</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span>;

maskLayer<span class="variable">.path</span> = maskPath<span class="variable">.CGPath</span>;

<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span><span class="variable">.mask</span> = maskLayer;

<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span><span class="variable">.cornerRadius</span> = <span class="number">5.</span>f;
<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span><span class="variable">.masksToBounds</span> = <span class="literal">YES</span>;
</code></pre><p>想要配置某个角为圆角的话,只需要指定对应的<em>UIRectCorner</em>即可，<em>UIRectCorner</em>有五个值：</p>
<pre><code><span class="built_in">UIRectCornerAllCorners</span> 全角
<span class="built_in">UIRectCornerTopLeft</span>    左上角
<span class="built_in">UIRectCornerTopRight</span>   右上角
<span class="built_in">UIRectCornerBottomLeft</span> 左下角
<span class="built_in">UIRectCornerBottomRight</span> 右下角
</code></pre><h2>UITableView分割线顶到头</h2>

<p>我们在使用tableview时会发现分割线的左边会短一些，通常可以使用setSeparatorInset:UIEdgeInsetsZero 来解决。但是升级到XCode6之后，在iOS8里发现没有效果。下面给出解决办法：</p>
<ol>
<li><p>第一步</p>
<p>  if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) {</p>
<pre><code>[<span class="literal">self</span>.<span class="built_in">table</span>View <span class="built_in">set</span>SeparatorInset:UIEdgeInsetsZero];
</code></pre><p>  }</p>
<p>  if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) {</p>
<pre><code>[<span class="literal">self</span>.<span class="built_in">table</span>View <span class="built_in">set</span>LayoutMargins:UIEdgeInsetsZero];
</code></pre><p>  }</p>
</li>
</ol>
<ol>
<li><p>第二步</p>
<pre><code><span class="tag">-</span> (void)<span class="tag">tableView</span>:(UITableView *)<span class="tag">tableView</span> <span class="tag">willDisplayCell</span>:(UITableViewCell *)<span class="tag">cell</span> <span class="tag">forRowAtIndexPath</span>:(NSIndexPath *)<span class="tag">indexPath</span>{
    <span class="tag">if</span> ([cell <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="attribute">setSeparatorInset</span>:)]) {
        <span class="attr_selector">[cell setSeparatorInset:UIEdgeInsetsZero]</span>;
    }
    <span class="tag">if</span> ([cell <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="attribute">setLayoutMargins</span>:)]) {
        <span class="attr_selector">[cell setLayoutMargins:UIEdgeInsetsZero]</span>;
    }
}
</code></pre></li>
</ol>
<p></p><h3>持续更新中…<h3><p></p>
</h3></h3>]]></content>
    <summary type="html">
    <![CDATA[<h2>IOS配置某个圆角大小</h2>

<p>iOS开发中各种圆角也随处可见,最简单给控件添加圆角的方式就是给视图的layer设置corner属性了:</p>
<pre><code><span class="keyword">self</span><span class="v]]>
    </summary>
    
      <category term="IOS" scheme="http://hanhailong.com/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java小知识总结]]></title>
    <link href="http://hanhailong.com/2016/01/11/Java%E5%B0%8F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://hanhailong.com/2016/01/11/Java小知识总结/</id>
    <published>2016-01-11T09:41:10.000Z</published>
    <updated>2016-01-11T10:07:01.000Z</updated>
    <content type="html"><![CDATA[<h2>编译时、运行时</h2>

<p><strong>编译时</strong>顾名思义就是正在编译的时候.那啥叫编译呢?就是编译器帮你把源代码翻译成机器能识别的代码。例如：Java编译器把写的java文件编译成jvm能识别的class字节码文件。</p>
<p>而在编译的时候会涉及到一些比如常量折叠等技术，这个以后细讲！</p>
<p><strong>运行时</strong>就是代码跑起来了.被装载到内存中去了.(你的代码保存在磁盘上没装入内存之前是个死家伙.只有跑到内存中才变成活的).而运行时类型检查就与前面讲的编译时类型检查(或者静态类型检查)不一样.不是简单的扫描代码.而是在内存中做些操作,做些判断.</p>
<h2>下面的代码片段中，行A和行B所标识的代码有什么区别呢？</h2>

<pre><code><span class="keyword">public</span> <span class="keyword">class</span> ConstantFolding {

    <span class="keyword">static</span> final  <span class="keyword">int</span> number1 = <span class="number">5</span>;

    <span class="keyword">static</span> final  <span class="keyword">int</span> number2 = <span class="number">6</span>;

    <span class="keyword">static</span> <span class="keyword">int</span> number3 = <span class="number">5</span>;

    <span class="keyword">static</span> <span class="keyword">int</span> number4= <span class="number">6</span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[ ] args)</span> </span>{

          <span class="keyword">int</span> product1 = number1 * number2;         <span class="comment">//line A</span>

          <span class="keyword">int</span> product2 = number3 * number4;         <span class="comment">//line B</span>

    }
}
</code></pre><p>在行A的代码中，product的值是在编译期计算的，行B则是在运行时计算的。如果你使用Java反编译器（例如，jd-gui）来反编译ConstantFolding.class文件的话，那么你就会从下面的结果里得到答案。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> ConstantFolding
{
  <span class="keyword">static</span> final <span class="keyword">int</span> number1 = <span class="number">5</span>;
  <span class="keyword">static</span> final <span class="keyword">int</span> number2 = <span class="number">6</span>;
  <span class="keyword">static</span> <span class="keyword">int</span> number3 = <span class="number">5</span>;
  <span class="keyword">static</span> <span class="keyword">int</span> number4 = <span class="number">6</span>;

  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[ ] args)</span>
  </span>{
      <span class="keyword">int</span> product1 = <span class="number">30</span>;
      <span class="keyword">int</span> product2 = number3 * number4;
  }
}
</code></pre><p>常量折叠是一种Java编译器使用的优化技术。由于final变量的值不会改变，因此就可以对它们优化。Java反编译器和javap命令都是查看编译后的代码（例如，字节码）的利器。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>编译时、运行时</h2>

<p><strong>编译时</strong>顾名思义就是正在编译的时候.那啥叫编译呢?就是编译器帮你把源代码翻译成机器能识别的代码。例如：Java编译器把写的java文件编译成jvm能识别的class字节码文件。</p>
<p>而在编译的时候]]>
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
      <category term="Java" scheme="http://hanhailong.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android进阶之ProGuard代码混淆]]></title>
    <link href="http://hanhailong.com/2015/12/28/Android%E8%BF%9B%E9%98%B6%E4%B9%8BProGuard%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    <id>http://hanhailong.com/2015/12/28/Android进阶之ProGuard代码混淆/</id>
    <published>2015-12-28T13:35:41.000Z</published>
    <updated>2015-12-28T14:32:50.000Z</updated>
    <content type="html"><![CDATA[<h2>简介</h2>

<p><a href="http://developer.android.com/intl/zh-cn/tools/help/proguard.html" target="_blank" rel="external">Proguard</a>工具通过移除无用的代码以及使用语义隐晦的名称来重命名类、字段和方法，从而达到压缩、优化和混淆代码的目的。最终您将获得一个较小的 .apk 文件，此文件更难于进行反向工程。由于 ProGuard 会使应用更难于进行反向工程，因此当应用使用对安全性要求极高的功能时（例如，当您向应用授予许可时），您必须使用此工具。</p>
<p>ProGuard 已集成到 Android 构建系统，所以您无需手动调用此工具。只有当您在发布模式下构建应用时，ProGuard 才会运行，因此当您在调试模式下构建应用时，就无需处理混淆后的代码。是否运行 ProGuard 完全由您决定，但我们强烈建议您运行该工具。</p>
<p>本文介绍如何启用和配置 ProGuard，以及如何使用 retrace 工具解码混淆后的堆栈跟踪信息。</p>
<a id="more"></a>
<h2>开启Proguard</h2>

<ol>
<li><p>Ant、Eclipse构建</p>
<pre><code>&lt;project_root&gt;/project<span class="class">.properties</span> 文件中设置 proguard<span class="class">.config</span> 属性。该路径可以是绝对路径，也可以是项目根目录的相对路径。

proguard.config=proguard.cfg
</code></pre></li>
<li><p>AndroidStudio-Gradle构建</p>
<pre><code><span class="title">android</span> {
    <span class="title">buildTypes</span> {
        <span class="title">release</span> {
            <span class="title">minifyEnabled</span> <span class="built_in">true</span>
            proguardFile getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>)
        }
    }

    productFlavors {
        <span class="title">flavor1</span> {
        }
        <span class="title">flavor2</span> {
            <span class="title">proguardFile</span> <span class="string">'some-other-rules.txt'</span>
        }
    }
}
</code></pre></li>
</ol>
<p>提示:</p>
<p>getDefaultProguardFile()可以返回这两个文件的绝对路径。<br>proguardFile 可以配置多个混淆文件</p>
<h2>配置Proguard</h2>

<p>在某些情况下，<em>proguard.cfg或proguard-android.txt</em> 文件中的默认配置足以满足您的需求。不过，在很多情况下，ProGuard 很难做出正确分析，因此可能会移除它认为无用而实际上您的应用却需要的代码。部分示例如下：</p>
<ul>
<li>一个只在 AndroidManifest.xml 文件中引用的类</li>
<li>一个通过 JNI 调用的方法</li>
<li>动态引用的字段和方法</li>
</ul>
<p>默认的 <em>proguard.cfg或proguard-android.txt</em> 文件旨在涵盖一般的使用情形，但您可能会遇到异常情况，例如 ClassNotFoundException（此异常情况会在 ProGuard 删除您的应用调用的整个类时发生）。</p>
<p>您可以通过在 <em>proguard.cfg或proguard-android.txt</em> 文件中添加一个 <font color="red">-keep</font> 行，来修复因 ProGuard 在删除代码而造成的错误。例如：</p>
<pre><code>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> <span class="inheritance">&lt;<span class="parent">MyClass</span></span>&gt;</span></span>
</code></pre><p>在使用 -keep 选项时，您既有许多选择也有不少需要注意的方面，因此我们强烈建议您阅读 <a href="https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/introduction.html" target="_blank" rel="external">ProGuard</a> 手册，详细了解如何自定义您的配置文件。该手册中的“Keep 选项概述”和“示例”部分尤其有用；问题排查部分则概述了在 ProGuard 删除代码后您可能会遇到的其他常见问题。</p>
<p>下面给出一个常用的默认配置命令：</p>
<pre><code>-include {fileame}  从给定的文件中读取配置参数
-libraryjars libs/xxxx.jar 指定库jar包
-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Activity</span> 保留类不被删除
-<span class="title">keep</span> <span class="title">class</span> <span class="title">className</span>$<span class="title">InnerName</span></span>{ 保留内部类的属性和方法
    <span class="keyword">public</span> &lt;fields&gt;;
    <span class="keyword">public</span> &lt;methods&gt;;
}
-keepclassmembers <span class="class"><span class="keyword">class</span> * <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>{ 保留类的成员
    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.io.ObjectStreamField[] serialPersistentFields;
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream)</span></span>;
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream)</span></span>;
    java.lang.<span class="function">Object <span class="title">writeReplace</span><span class="params">()</span></span>;
    java.lang.<span class="function">Object <span class="title">readResolve</span><span class="params">()</span></span>;
}
-dontshrink 不压缩输入的类文件
-dontoptimize 不优化输入的类文件
-keepattributes *Annotation* 保留Annotation
-dontwarn xxx.xxx.** 不检查引用
</code></pre><h2>Proguard产生的文件</h2>

<p>当混淆后的代码输出堆栈跟踪信息时，方法名称会被混淆，即便仍能进行调试，难度也会很大。幸运的是，ProGuard 在每次运行时都会输出以下文件：</p>
<ol>
<li><p>dump.txt</p>
<p> 描述 .apk 文件中所有类文件的内部结构</p>
</li>
<li><p>mapping.txt</p>
<p> 列出原始与混淆后的类、方法和字段名称之间的对应关系。</p>
<p> Windows 上的 retrace.bat 脚本以及 Linux 或 Mac OS X 上的 retrace.sh 脚本可以将混淆后的堆栈跟踪信息转换成可读文件，此文件位于 <sdk_root>/tools/proguard/ 目录中。执行 retrace 工具的语法如下：</sdk_root></p>
<pre><code>retrace.bat|retrace.sh [-verbose] mapping.txt <span class="annotation">[&lt;stacktrace_file&gt;]</span>
</code></pre><p> 例如：</p>
<pre><code>retrace<span class="class">.bat</span> -verbose mapping<span class="class">.txt</span> obfuscated_trace.txt
</code></pre><p> 建议发布时应保留mapping.txt文件。</p>
</li>
<li><p>seeds.txt</p>
<p> 列出未混淆的类和成员</p>
</li>
<li><p>usage.txt</p>
<p> 列出从 .apk 删除的代码</p>
</li>
</ol>
<p></p><h2>@Keep注解来防止混淆</h2><p></p>
<p>写到这，你是不是发现了一个问题：非常的麻烦、一点都不灵活，而且通过-keep的方式防止混淆那种有共同特征的类、属性或方式非常有用，但是没有共同特征的呢？</p>
<p>这里介绍一种比较新颖、轻快的方法，通过@Keep注解来灵活的防止混淆，用起来非常的灵活、快捷、方便，怎样用呢？像普通的注解一样，如下：</p>
<pre><code><span class="comment">//防止混淆类</span>
<span class="variable">@Keep</span>
public class Person {}

<span class="comment">//防止混淆变量</span>
<span class="variable">@Keep</span>
public String name;

<span class="comment">//防止混淆方法</span>
<span class="variable">@Keep</span>
public int <span class="function">getAge</span>(){}
</code></pre><p>但是当你加上上面的注解后，发现@Keep并没有起作用，该混淆的还是混淆了，这是为什么呢？</p>
<p>原因目前Gradle还不支持@Keep混淆，Google只是定义好了一个这种注解，并没有实现它，也就是说@Keep目前只是一个空壳。这里我们来手动开启它，让它支持防止混淆，在你的<em>proguard.cfg或proguard-android.txt</em>配置文件里面加入以下代码：</p>
<pre><code>#手动启用support keep注解
-<span class="ruby">dontskipnonpubliclibraryclassmembers
</span>-<span class="ruby">printconfiguration
</span>-<span class="ruby">keep,allowobfuscation <span class="variable">@interface</span> android.support.annotation.<span class="constant">Keep</span>
</span>-<span class="ruby">keep <span class="variable">@android</span>.support.annotation.<span class="constant">Keep</span> <span class="class"><span class="keyword">class</span> *</span>
</span>-<span class="ruby">keepclassmembers <span class="class"><span class="keyword">class</span> * {</span>
</span>    @android.support.annotation.Keep *;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2>简介</h2>

<p><a href="http://developer.android.com/intl/zh-cn/tools/help/proguard.html">Proguard</a>工具通过移除无用的代码以及使用语义隐晦的名称来重命名类、字段和方法，从而达到压缩、优化和混淆代码的目的。最终您将获得一个较小的 .apk 文件，此文件更难于进行反向工程。由于 ProGuard 会使应用更难于进行反向工程，因此当应用使用对安全性要求极高的功能时（例如，当您向应用授予许可时），您必须使用此工具。</p>
<p>ProGuard 已集成到 Android 构建系统，所以您无需手动调用此工具。只有当您在发布模式下构建应用时，ProGuard 才会运行，因此当您在调试模式下构建应用时，就无需处理混淆后的代码。是否运行 ProGuard 完全由您决定，但我们强烈建议您运行该工具。</p>
<p>本文介绍如何启用和配置 ProGuard，以及如何使用 retrace 工具解码混淆后的堆栈跟踪信息。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之如何避免Overdraw]]></title>
    <link href="http://hanhailong.com/2015/12/27/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DOverdraw/"/>
    <id>http://hanhailong.com/2015/12/27/Android性能优化之如何避免Overdraw/</id>
    <published>2015-12-27T12:14:37.000Z</published>
    <updated>2015-12-27T13:04:19.000Z</updated>
    <content type="html"><![CDATA[<h2>什么是Overdraw？</h2>

<p>Overdraw就是过度绘制，是指在一帧的时间内（16.67ms）像素被绘制了多次，理论上一个像素每次只绘制一次是最优的，但是由于重叠的布局导致一些像素会被多次绘制，而每次绘制都会对应到CPU的一组绘图命令和GPU的一些操作，当这个操作耗时超过16.67ms时，就会出现掉帧现象，也就是我们所说的卡顿，所以对重叠不可见元素的重复绘制会产生额外的开销，需要尽量减少Overdraw的发生。</p>
<p>Android提供了测量Overdraw的选项，在开发者选项－调试GPU过度绘制（Show GPU Overdraw），打开选项就可以看到当前页面Overdraw的状态，就可以观察屏幕的绘制状态。该工具会使用三种不同的颜色绘制屏幕，来指示overdraw发生在哪里以及程度如何，其中：</p>
<p>没有颜色： 意味着没有overdraw。像素只画了一次。</p>
<p>蓝色： 意味着overdraw 1倍。像素绘制了两次。大片的蓝色还是可以接受的（若整个窗口是蓝色的，可以摆脱一层）。</p>
<p>绿色： 意味着overdraw 2倍。像素绘制了三次。中等大小的绿色区域是可以接受的但你应该尝试优化、减少它们。</p>
<p>浅红： 意味着overdraw 3倍。像素绘制了四次，小范围可以接受。</p>
<p>暗红： 意味着overdraw 4倍。像素绘制了五次或者更多。这是错误的，要修复它们。</p>
<p><img src="http://jbcdn2.b0.upaiyun.com/2015/12/1f79c3f75b4b42bd4b2140ff7d14ee73.jpg" alt=""></p>
<p>那么我们怎么来消灭overdraw呢？总的原则就是：尽量避免重叠不可见元素的绘制，基于这个原则，我们大概可以想出以下几招： </p>
<a id="more"></a>
<h2>第一招：合理选择控件容器</h2>

<p>既然overdraw是因为重复绘制了同一片区域的像素点，那我们首先想到的是解决布局问题。Android提供的Layout控件主要包括LinearLayout、TableLayout、FrameLayout、RelativeLayout。俗话说条条大路通罗马，同一个界面我们可以使用不同的容器控件来表达，但是各个容器控件描述界面的复杂度是不一样的。一般来说LinearLayout最易，RelativeLayout较复杂。但是尺有所短，寸有所长，LinearLayout只能用来描述一个方向上连续排列的控件，而RelativeLayout几乎可以用于描述任意复杂度的界面。但是我又要说但是了，表达能力越强的容器控件，性能往往略低一些，因为系统需要将更多的时间花在计算子控件的位置上。综上所述：LinearLayout易用，效率高，表达能力有限。RelativeLayout复杂，表达能力强，效率稍逊。</p>
<p>那么对于同一界面而言，作为开发者考虑是使用尽量少的、表达能力强的RelativeLayout作为容器，还是选择多个、表达能力稍弱的LinearLayout来展示。从减少overdraw的角度来看，LinearLayout会增加控件数的层级，自然是RelativeLayout更优，但是当某一界面在使用LinearLayout并不会比RelativeLayout带来更多的控件数和控件层级时，LinearLayout则是首选。所以在表达界面的时候，作为一个有前瞻性的开发者要根据实际情况来选择合适容器控件，在保证性能的同时，尽量避免overdraw。</p>
<h2>第二招：去掉window的默认背景</h2>

<p>当我们使用了Android自带的一些主题时，window会被默认添加一个纯色的背景，这个背景是被DecorView持有的。当我们的自定义布局时又添加了一张背景图或者设置背景色，那么DecorView的background此时对我们来说是无用的，但是它会产生一次Overdraw，带来绘制性能损耗。</p>
<p>去掉window的背景可以在onCreate()中setContentView()之后调用</p>
<pre><code>getWindow().setBackgroundDrawable(<span class="literal">null</span>);
</code></pre><p>或者在theme中添加</p>
<pre><code><span class="label">android:</span>windowbackground=<span class="string">"null"</span>；
</code></pre><h2>第三招：去掉其他不必要的背景</h2>

<p>有时候为了方便会先给Layout设置一个整体的背景，再给子View设置背景，这里也会造成重叠，如果子View宽度mach_parent，可以看到完全覆盖了Layout的一部分，这里就可以通过分别设置背景来减少重绘。再比如如果采用的是selector的背景，将normal状态的color设置为“@android:color/transparent”,也同样可以解决问题。这里只简单举两个例子，我们在开发过程中的一些习惯性思维定式会带来不经意的Overdraw，所以开发过程中我们为某个View或者ViewGroup设置背景的时候，先思考下是否真的有必要，或者思考下这个背景能不能分段设置在子View上，而不是图方便直接设置在根View上。</p>
<h2>第四招：ClipRect &amp; QuickReject</h2>

<p>为了解决Overdraw的问题，Android系统会通过避免绘制那些完全不可见的组件来尽量减少消耗。但是不幸的是，对于那些过于复杂的自定义的View(通常重写了onDraw方法)，Android系统无法检测在onDraw里面具体会执行什么操作，系统无法监控并自动优化，也就无法避免Overdraw了。但是我们可以通过canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。除了clipRect方法之外，我们还可以使用canvas.quickreject()来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。</p>
<h2>第五招：ViewStub</h2>

<p>ViewStub是个什么东西？一句话总结：高效占位符。<br>我们经常会遇到这样的情况，运行时动态根据条件来决定显示哪个View或布局。常用的做法是把View都写在上面，先把它们的可见性都设为View.GONE，然后在代码中动态的更改它的可见性。这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点就是，耗费资源。虽然把View的初始可见View.GONE但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。<br>推荐的做法是使用android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。</p>
<pre><code>&lt;ViewStub
    android:<span class="property">id</span>=<span class="string">"@+id/stub_view"</span>
    android:inflatedId=<span class="string">"@+id/panel_stub"</span>
    android:layout=<span class="string">"@layout/progress_overlay"</span>
    android:layout_width=<span class="string">"fill_parent"</span>
    android:layout_height=<span class="string">"wrap_content"</span>
    android:layout_gravity=<span class="string">"bottom"</span> /&gt;
</code></pre><p>当你想加载布局时，可以使用下面其中一种方法：</p>
<pre><code>((ViewStub) findViewById(R.<span class="property">id</span>.stub_view)).setVisibility(View.VISIBLE);
View importPanel = ((ViewStub) findViewById(R.<span class="property">id</span>.stub_view)).inflate()
</code></pre><h2>第六招：Merge</h2>

<p>Merge标签有什么用呢？简单粗暴点回答：干掉一个view层级。</p>
<p>Merge的作用很明显，但是也有一些使用条件的限制。有两种情况下我们可以使用Merge标签来做容器控件。第一种子视图不需要指定任何针对父视图的布局属性，就是说父容器仅仅是个容器，子视图只需要直接添加到父视图上用于显示就行。另外一种是假如需要在LinearLayout里面嵌入一个布局（或者视图），而恰恰这个布局（或者视图）的根节点也是LinearLayout，这样就多了一层没有用的嵌套，无疑这样只会拖慢程序速度。而这个时候如果我们使用merge根标签就可以避免那样的问题。另外Merge只能作为XML布局的根标签使用，当Inflate以开头的布局文件时，必须指定一个父ViewGroup，并且必须设定attachToRoot为true。<br>举个简单的例子吧：</p>
<pre><code>&lt;RelativeLayout 
<span class="label">xmlns:</span>android=<span class="string">"http://schemas.android.com/apk/res/android"</span> 
<span class="label">xmlns:</span>tools=<span class="string">"http://schemas.android.com/tools"</span> 
<span class="label">android:</span>layout_width=<span class="string">"match_parent"</span> 
<span class="label">android:</span>layout_height=<span class="string">"match_parent"</span> &gt; 
&lt;TextView 
<span class="label">android:</span>layout_width=<span class="string">"wrap_content"</span>  
<span class="label">android:</span>layout_height=<span class="string">"wrap_content"</span> 
<span class="label">android:</span>text=<span class="string">"merge标签使用"</span> /&gt;
&lt;/RelativeLayout&gt;
</code></pre><p>把上面这个XML加载到页面中，布局层级是RelativeLayout-TextView。但是采用下面的方式，把RelativeLayout提换成merge，RelativeLayout这一层级就被干掉了。</p>
<pre><code>&lt;merge
<span class="label">xmlns:</span>android=<span class="string">"http://schemas.android.com/apk/res/android"</span> 
<span class="label">xmlns:</span>tools=<span class="string">"http://schemas.android.com/tools"</span> 
<span class="label">android:</span>layout_width=<span class="string">"match_parent"</span> 
<span class="label">android:</span>layout_height=<span class="string">"match_parent"</span> &gt;
&lt;TextView  
<span class="label">android:</span>layout_width=<span class="string">"wrap_content"</span> 
<span class="label">android:</span>layout_height=<span class="string">"wrap_content"</span> 
 android:text=<span class="string">"merge标签使用"</span> /&gt;
&lt;/merge&gt;
</code></pre><h2>第七招：善用draw9patch</h2>

<p>给ImageView加一个边框，你肯定遇到过这种需求，通常在ImageView后面设置一张背景图，露出边框便完美解决问题，此时这个ImageView，设置了两层drawable，底下一层仅仅是为了作为图片的边框而已。但是两层drawable的重叠区域去绘制了两次，导致overdraw。<br>优化方案： 将背景drawable制作成draw9patch，并且将和前景重叠的部分设置为透明。由于Android的2D渲染器会优化draw9patch中的透明区域，从而优化了这次overdraw。 但是背景图片必须制作成draw9patch才行，因为Android 2D渲染器只对draw9patch有这个优化，否则，一张普通的Png，就算你把中间的部分设置成透明，也不会减少这次overdraw。</p>
<h2>第八招：慎用Alpha</h2>

<p>假如对一个View做Alpha转化，需要先将View绘制出来，然后做Alpha转化，最后将转换后的效果绘制在界面上。通俗点说，做Alpha转化就需要对当前View绘制两遍，可想而知，绘制效率会大打折扣，耗时会翻倍，所以Alpha还是慎用。</p>
<p>如果一定做Alpha转化的话，可以采用缓存的方式。</p>
<pre><code>view.setLayerType(LAYER_TYPE_HARDWARE)<span class="comment">;</span>
doSmoeThing()<span class="comment">;</span>
view.setLayerType(LAYER_TYPE_NONE)<span class="comment">;</span>
</code></pre><p>通过setLayerType方式可以将当前界面缓存在GPU中，这样不需要每次绘制原始界面，但是GPU内存是相当宝贵的，所以用完要马上释放掉。</p>
<h2>第九招：避免“OverDesign”</h2>

<p>overdraw会给APP带来不好的体验，overdraw产生的原因无外乎：复杂的Layout层级，重叠的View，重叠的背景这几种。开发人员无节制的View堆砌，究其根本无非是产品无节制的需求设计。有道是“由俭入奢易，由奢入俭难”，很多APP披着过度设计的华丽外衣，却忘了简单易用才是王道的本质，纷繁复杂的设计并不会给用户带来好的体验，反而会让用户有压迫感，产品本身也有可能因此变得卡顿。当然，一切抛开业务谈优化都是空中楼阁，这就需要产品设计也要有一个权衡，在复杂的业务逻辑与简单易用的界面展现中做一个平衡，而不是一味的OverDesign。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>什么是Overdraw？</h2>

<p>Overdraw就是过度绘制，是指在一帧的时间内（16.67ms）像素被绘制了多次，理论上一个像素每次只绘制一次是最优的，但是由于重叠的布局导致一些像素会被多次绘制，而每次绘制都会对应到CPU的一组绘图命令和GPU的一些操作，当这个操作耗时超过16.67ms时，就会出现掉帧现象，也就是我们所说的卡顿，所以对重叠不可见元素的重复绘制会产生额外的开销，需要尽量减少Overdraw的发生。</p>
<p>Android提供了测量Overdraw的选项，在开发者选项－调试GPU过度绘制（Show GPU Overdraw），打开选项就可以看到当前页面Overdraw的状态，就可以观察屏幕的绘制状态。该工具会使用三种不同的颜色绘制屏幕，来指示overdraw发生在哪里以及程度如何，其中：</p>
<p>没有颜色： 意味着没有overdraw。像素只画了一次。</p>
<p>蓝色： 意味着overdraw 1倍。像素绘制了两次。大片的蓝色还是可以接受的（若整个窗口是蓝色的，可以摆脱一层）。</p>
<p>绿色： 意味着overdraw 2倍。像素绘制了三次。中等大小的绿色区域是可以接受的但你应该尝试优化、减少它们。</p>
<p>浅红： 意味着overdraw 3倍。像素绘制了四次，小范围可以接受。</p>
<p>暗红： 意味着overdraw 4倍。像素绘制了五次或者更多。这是错误的，要修复它们。</p>
<p><img src="http://jbcdn2.b0.upaiyun.com/2015/12/1f79c3f75b4b42bd4b2140ff7d14ee73.jpg" alt=""></p>
<p>那么我们怎么来消灭overdraw呢？总的原则就是：尽量避免重叠不可见元素的绘制，基于这个原则，我们大概可以想出以下几招： </p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 性能优化之--使用线程池处理异步任务]]></title>
    <link href="http://hanhailong.com/2015/12/27/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    <id>http://hanhailong.com/2015/12/27/Android-性能优化之-使用线程池处理异步任务/</id>
    <published>2015-12-27T08:41:23.000Z</published>
    <updated>2015-12-27T12:10:00.000Z</updated>
    <content type="html"><![CDATA[<p>说到线程，我想大家都不陌生，因为在开发时候或多或少都会用到线程，而通常创建线程有两种方式：</p>
<ol>
<li>继承自Thread类</li>
<li>实现Runnable接口</li>
</ol>
<p>虽说这两种方式都可以创建出一个线程，不过它们之间还是有一点区别的，主要区别在于在多线程访问同一资源的情况下，用Runnable接口创建的线程可以处理同一资源，而用Thread类创建的线程则各自独立处理，各自拥有自己的资源。</p>
<p>所以，在Java中大多数多线程程序都是通过实现Runnable来完成的，而对于Android来说也不例外，当涉及到需要开启线程去完成某件事时，我们都会这样写：</p>
<pre><code><span class="tag">new</span> <span class="tag">Thread</span>(new <span class="function">Runnable</span>() {
    <span class="variable">@Override</span>
    public void <span class="function">run</span>() {
        <span class="comment">//do sth .</span>
    }
})<span class="class">.start</span>();
</code></pre><p>这段代码创建了一个线程并执行，它在任务结束后GC会自动回收该线程，一切看起来如此美妙，是的，它在线程并发不多的程序中确实不错，而假如这个程序有很多地方需要开启大量线程来处理任务，那么如果还是用上述的方式去创建线程处理的话，那么将导致系统的性能表现的非常糟糕，更别说在内存有限的移动设备上，主要的影响如下：</p>
<ol>
<li>线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失</li>
<li>大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM</li>
<li>大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿</li>
</ol>
<p>而针对上述所描述的问题，解决的办法归根到底就是：重用已有的线程，从而减少线程的创建。<br>所以这就涉及到线程池（ExecutorService）的概念了，线程池的基本作用就是进行线程的复用，下面将具体介绍线程池的使用</p>
<a id="more"></a>
<h2>ExecutorService</h2><br>通过上述分析，我们知道了通过new Thread().start()方式创建线程去处理任务的弊端，而为了解决这些问题，Java为我们提供了ExecutorService线程池来优化和管理线程的使用<br><br><h4>使用线程池管理线程的优点</h4><br><br>1. 线程的创建和销毁由线程池维护，一个线程在完成任务后并不会立即销毁，而是由后续的任务复用这个线程，从而减少线程的创建和销毁，节约系统的开销<br>2. 线程池旨在线程的复用，这就可以节约我们用以往的方式创建线程和销毁所消耗的时间，减少线程频繁调度的开销，从而节约系统资源，提高系统吞吐量<br>3. 在执行大量异步任务时提高了性能<br>4. Java内置的一套ExecutorService线程池相关的api，可以更方便的控制线程的最大并发数、线程的定时任务、单线程的顺序执行等<br><br><h2>ExecutorService简介</h2><br>通常来说我们说到线程池第一时间想到的就是它：<em>ExecutorService</em>，它是一个接口，其实如果要从真正意义上来说，它可以叫做线程池的服务，因为它提供了众多接口api来控制线程池中的线程，而真正意义上的线程池就是：<em>ThreadPoolExecutor</em>，它实现了<em>ExecutorService</em>接口，并封装了一系列的api使得它具有线程池的特性，其中包括工作队列、核心线程数、最大线程数等。<br><br><h4>线程池：ThreadPoolExecutor</h4><br>既然线程池就是ThreadPoolExecutor，所以我们要创建一个线程池只需要new ThreadPoolExecutor(…);就可以创建一个线程池，而如果这样创建线程池的话，我们需要配置一堆东西，非常麻烦，我们可以看一下它的构造方法就知道了：<br><br>    public ThreadPoolExecutor(int corePoolSize,<br>                                  int maximumPoolSize,<br>                                  long keepAliveTime,<br>                                  TimeUnit unit,<br>                                  BlockingQueue workQueue,<br>                                  ThreadFactory threadFactory,<br>                                  RejectedExecutionHandler handler) {…}<br><br><br>所以，官方也不推荐使用这种方法来创建线程池，而是推荐使用Executors的工厂方法来创建线程池，Executors类是官方提供的一个工厂类，它里面封装好了众多功能不一样的线程池，从而使得我们创建线程池非常的简便，主要提供了如下五种功能不一样的线程池：<br><br>1. <strong>newFixedThreadPool() ：</strong><br><br>    作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。<br>    栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按FIFO方式处理任务队列中的任务。<br>2. <strong>newCachedThreadPool() ：</strong><br><br>    作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。<br>    栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。<br><br>3. <strong>newSingleThreadExecutor() ：</strong><br><br>    作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。<br><br>4. <strong>newScheduledThreadPool() ：</strong><br><br>    作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。<br><br>5. <strong>newSingleThreadScheduledExecutor() ：</strong><br><br>    作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为1，而上面的可以指定线程池的大小。<br><br>好了，写了一堆来介绍这五种线程池的作用，接下来就是获取这五种线程池，通过Executors的工厂方法来获取：<br><br>        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);<br>        ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();<br>        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();<br>        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);<br>        ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor();<br><br>我们可以看到通过Executors的工厂方法来创建线程池极其简便，其实它的内部还是通过new ThreadPoolExecutor(…)的方式创建线程池的，我们看一下这些工厂方法的内部实现：<br><br>        public static ExecutorService newFixedThreadPool(int nThreads) {<br>            return new ThreadPoolExecutor(nThreads, nThreads,<br>                                          0L, TimeUnit.MILLISECONDS,<br>                                          new LinkedBlockingQueue());<br>        }<br>        public static ExecutorService newSingleThreadExecutor() {<br>            return new FinalizableDelegatedExecutorService<br>                (new ThreadPoolExecutor(1, 1,<br>                                        0L, TimeUnit.MILLISECONDS,<br>                                        new LinkedBlockingQueue()));<br>        }<br>        public static ExecutorService newCachedThreadPool() {<br>            return new ThreadPoolExecutor(0, Integer.MAX_VALUE,<br>                                          60L, TimeUnit.SECONDS,<br>                                          new SynchronousQueue());<br>        }<br><br>我们可以清楚的看到这些方法的内部实现都是通过创建一个ThreadPoolExecutor对象来创建的，正所谓万变不离其宗，所以我们要了解线程池还是得了解ThreadPoolExecutor这个线程池类，其中由于和定时任务相关的线程池比较特殊（newScheduledThreadPool()、newSingleThreadScheduledExecutor()），它们创建的线程池内部实现是由ScheduledThreadPoolExecutor这个类实现的，而ScheduledThreadPoolExecutor是继承于ThreadPoolExecutor扩展而成的，所以本质还是一样的，只不过多封装了一些定时任务相关的api，所以我们主要就是要了解ThreadPoolExecutor，从构造方法开始：<br><br>    public ThreadPoolExecutor(int corePoolSize,<br>                                  int maximumPoolSize,<br>                                  long keepAliveTime,<br>                                  TimeUnit unit,<br>                                  BlockingQueue workQueue,<br>                                  ThreadFactory threadFactory,<br>                                  RejectedExecutionHandler handler) {//…}<br><br>我们可以看到它构造方法的参数比较多，有七个，下面一一来说明这些参数的作用：<br><br><em> <strong>corePoolSize</strong>：线程池中的核心线程数量
</em> <strong>maximumPoolSize</strong>: 线程池中的最大线程数量<br><em> <strong>keepAliveTime</strong>: 这个就是上面说到的“保持活动时间“，上面只是大概说明了一下它的作用，不过它起作用必须在一个前提下，就是当线程池中的线程数量超过了corePoolSize时，它表示多余的空闲线程的存活时间，即：多余的空闲线程在超过keepAliveTime时间内没有任务的话则被销毁。而这个主要应用在缓存线程池中
</em> <strong>unit</strong>：它是一个枚举类型，表示keepAliveTime的单位，常用的如：TimeUnit.SECONDS（秒）、TimeUnit.MILLISECONDS（毫秒）<br><em> <strong>workQueue</strong>: 任务队列，主要用来存储已经提交但未被执行的任务，不同的线程池采用的排队策略不一样，稍后再讲
</em> <strong>threadFactory</strong>:线程工厂，用来创建线程池中的线程，通常用默认的即可<br><em> <strong>handler</strong>: 通常叫做拒绝策略，1、在线程池已经关闭的情况下 2、任务太多导致最大线程数和任务队列已经饱和，无法再接收新的任务 。在上面两种情况下，只要满足其中一种时，在使用execute()来提交新的任务时将会拒绝，而默认的拒绝策略是抛一个RejectedExecutionException异常<br><br>上面的参数理解起来都比较简单，不过workQueue这个任务队列却要再次说明一下，它是一个BlockingQueue对象，而泛型则限定它是用来存放Runnable对象的，刚刚上面讲了，不同的线程池它的任务队列实现肯定是不一样的，所以，保证不同线程池有着不同的功能的核心就是这个workQueue的实现了，细心的会发现在刚刚的用来创建线程池的工厂方法中，针对不同的线程池传入的workQueue也不一样，下面我总结一下这五种线程池分别用的是什么

</em>BlockingQueue*:<br><br>1. newFixedThreadPool()—&gt;LinkedBlockingQueue<br>2. newSingleThreadExecutor()—&gt;LinkedBlockingQueue<br>3. newCachedThreadPool()—&gt;SynchronousQueue<br>4. newScheduledThreadPool()—&gt;DelayedWorkQueue<br>5. newSingleThreadScheduledExecutor()—&gt;DelayedWorkQueue<br><br>这些队列分别表示：<br><br>    LinkedBlockingQueue：无界的队列<br>    SynchronousQueue：直接提交的队列<br>    DelayedWorkQueue：等待队列<br><br>当然实现了BlockingQueue接口的队列还有：ArrayBlockingQueue（有界的队列）、PriorityBlockingQueue（优先级队列）。这些队列的详细作用就不多介绍了。<br><br><h2>线程池ThreadPoolExecutor的使用</h2>

<p>使用线程池，其中涉及到一个极其重要的方法，即：</p>
<pre><code><span class="function"><span class="title">execute</span><span class="params">(Runnable command)</span></span>
</code></pre><p>该方法意为执行给定的任务，该任务处理可能在新的线程、已入池的线程或者正调用的线程，这由ThreadPoolExecutor的实现决定。</p>
<h4>newFixedThreadPool</h4>

<p>创建一个固定线程数量的线程池，示例为：</p>
<pre><code>ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="number">10</span>; i++) {
        final <span class="keyword">int</span> index = i;
        fixedThreadPool.execute(<span class="keyword">new</span> Runnable() {
             @<span class="function">Override
             <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                 String threadName = Thread.currentThread().getName();
                 Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span>+threadName+<span class="string">",正在执行第"</span> + index + <span class="string">"个任务"</span>);
                 <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">2000</span>);
                 } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                 }
             }
         });
     }
</code></pre><p>上述代码，我们创建了一个线程数为3的固定线程数量的线程池，同理该线程池支持的线程最大并发数也是3，而我模拟了10个任务让它处理，执行的情况则是首先执行前三个任务，后面7个则依次进入任务队列进行等待，执行完前三个任务后，再通过FIFO的方式从任务队列中取任务执行，直到最后任务都执行完毕。</p>
<p>为了体现出线程的复用，我特地在Log中加上了当前线程的名称，效果为：</p>
<p><img src="http://img.blog.csdn.net/20151116182357008" alt=""></p>
<h4>newSingleThreadExecutor</h4>

<p>创建一个只有一个线程的线程池，每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待线程处理完再依次处理任务队列中的任务，示例为：</p>
<pre><code>ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="number">10</span>; i++) {
            final <span class="keyword">int</span> index = i;
            singleThreadPool.execute(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    String threadName = Thread.currentThread().getName();
                    Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span>+threadName+<span class="string">",正在执行第"</span> + index + <span class="string">"个任务"</span>);
                    <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">1000</span>);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
</code></pre><p>代码还是差不多，只不过改了线程池的实现方式，效果我想大家都知道，即依次一个一个的处理任务，而且都是复用一个线程，效果为：</p>
<p><img src="http://img.blog.csdn.net/20151116182627850" alt=""></p>
<p>其实我们通过newSingleThreadExecutor()和newFixedThreadPool()的方法发现，创建一个singleThreadExecutorPool实际上就是创建一个核心线程数和最大线程数都为1的fixedThreadPool。</p>
<h4>newCachedThreadPool</h4>

<p>创建一个可以根据实际情况调整线程池中线程的数量的线程池，示例为：</p>
<pre><code>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="number">10</span>; i++) {
            final <span class="keyword">int</span> index = i;
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">1000</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
            cachedThreadPool.execute(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    String threadName = Thread.currentThread().getName();
                    Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">",正在执行第"</span> + index + <span class="string">"个任务"</span>);
                    <span class="keyword">try</span> {
                        <span class="keyword">long</span> time = index * <span class="number">500</span>;
                        Thread.sleep(time);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
</code></pre><p>为了体现该线程池可以自动根据实现情况进行线程的重用，而不是一味的创建新的线程去处理任务，我设置了每隔1s去提交一个新任务，这个新任务执行的时间也是动态变化的，所以，效果为：</p>
<p><img src="http://img.blog.csdn.net/20151116184528454" alt=""></p>
<h4>newScheduledThreadPool</h4><br>创建一个可以定时或者周期性执行任务的线程池，示例为：<br><br>    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);<br>            //延迟2秒后执行该任务<br>            scheduledThreadPool.schedule(new Runnable() {<br>                @Override<br>                public void run() {<br><br>                }<br>            }, 2, TimeUnit.SECONDS);<br>            //延迟1秒后，每隔2秒执行一次该任务<br>            scheduledThreadPool.scheduleAtFixedRate(new Runnable() {<br>                @Override<br>                public void run() {<br><br>                }<br>            }, 1, 2, TimeUnit.SECONDS);<br><br><h4> newSingleThreadScheduledExecutor </h4>

<p>创建一个可以定时或者周期性执行任务的线程池，该线程池的线程数为1，代码示例为：</p>
<pre><code>ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor();
        <span class="comment">//延迟1秒后，每隔2秒执行一次该任务</span>
        singleThreadScheduledPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                String threadName = Thread.currentThread().getName();
                Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">",正在执行"</span>);
            }
        },<span class="number">1</span>,<span class="number">2</span>,TimeUnit.SECONDS);
</code></pre><p>实际上这个和上面的没什么太大区别，只不过是线程池内线程数量的不同，效果为：</p>
<p><img src="http://img.blog.csdn.net/20151116194526184" alt=""></p>
<p>每隔2秒就会执行一次该任务</p>
<h2>自定义线程池ThreadPoolExecutor</h2>

<p>Java内置只为我们提供了五种常用的线程池，一般来说这足够用了，不过有时候我们也可以根据需求来自定义我们自己的线程池，而要自定义不同功能的线程池，上面我们也说了线程池功能的不同归根到底还是内部的BlockingQueue实现不同，所以，我们要实现我们自己相要的线程池，就必须从BlockingQueue的实现上做手脚，而上面也说了BlockingQueue的实现类有多个，那么这次我们就选用PriorityBlockingQueue来实现一个功能是按任务的优先级来处理的线程池。</p>
<ol>
<li><p><strong>首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下：</strong></p>
<pre><code>ExecutorService priorityThreadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">3</span>,<span class="number">0L</span>,TimeUnit.SECONDS,<span class="keyword">new</span> PriorityBlockingQueue());
</code></pre></li>
<li><p><strong>然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下：</strong></p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Comparable</span> </span>{
    <span class="keyword">private</span> <span class="keyword">int</span> priority;

    <span class="function"><span class="keyword">public</span> <span class="title">PriorityRunnable</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>{
        <span class="keyword">if</span> (priority <span class="number">0</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();
        <span class="keyword">this</span>.priority = priority;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PriorityRunnable another)</span> </span>{
        <span class="keyword">int</span> my = <span class="keyword">this</span>.getPriority();
        <span class="keyword">int</span> other = another.getPriority();
        <span class="keyword">return</span> my <span class="number">1</span> : my &gt; other ? -<span class="number">1</span> : <span class="number">0</span>;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        doSth();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> priority;
    }
}
</code></pre></li>
<li><p><strong>使用我们自己的PriorityRunnable提交任务，整体代码如下：</strong></p>
<pre><code>ExecutorService priorityThreadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">3</span>, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> PriorityBlockingQueue());
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="number">10</span>; i++) {
            final <span class="keyword">int</span> priority = i;
            priorityThreadPool.execute(<span class="keyword">new</span> PriorityRunnable(priority) {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>{
                    String threadName = Thread.currentThread().getName();
                    Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">",正在执行优先级为："</span> + priority + <span class="string">"的任务"</span>);
                    <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">2000</span>);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
</code></pre></li>
</ol>
<h4>测试效果</h4>

<p>我们看下刚刚自定义的线程池是否达到了我们想要的功能，即根据任务的优先级进行优先处理任务，效果如下：</p>
<p><img src="http://img.blog.csdn.net/20151116212159326" alt=""></p>
<p>可以从执行结果中看出，由于核心线程数设置为3，刚开始时，系统有3个空闲线程，所以无须使用任务队列，而是直接运行前三个任务，而后面再提交任务时由于当前没有空闲线程所以加入任务队列中进行等待，此时，由于我们的任务队列实现是由PriorityBlockingQueue实现的，所以进行等待的任务会经过优先级判断，优先级高的放在队列前面先处理。从效果图中也可以看到后面的任务是先执行优先级高的任务，然后依次递减。</p>
<h4>优先级线程池的优点</h4>

<p>从上面我们可以得知，创建一个优先级线程池非常有用，它可以在线程池中线程数量不足或系统资源紧张时，优先处理我们想要先处理的任务，而优先级低的则放到后面再处理，这极大改善了系统默认线程池以FIFO方式处理任务的不灵活</p>
<h2>扩展线程池ThreadPoolExecutor</h2>

<p>除了内置的功能外，ThreadPoolExecutor也向外提供了三个接口供我们自己扩展满足我们需求的线程池，这三个接口分别是：</p>
<pre><code><span class="function"><span class="title">beforeExecute</span><span class="params">()</span></span> – 任务执行前执行的方法
<span class="function"><span class="title">afterExecute</span><span class="params">()</span></span> -任务执行结束后执行的方法
<span class="function"><span class="title">terminated</span><span class="params">()</span></span> -线程池关闭后执行的方法
</code></pre><p>这三个方法在ThreadPoolExecutor内部都没有实现</p>
<p>前面两个方法我们可以在ThreadPoolExecutor内部的runWorker()方法中找到，而runWorker()是ThreadPoolExecutor的内部类Worker实现的方法，Worker它实现了Runnable接口，也正是线程池内处理任务的工作线程，而Worker.runWorker()方法则是处理我们所提交的任务的方法，它会同时被多个线程访问，所以我们看runWorker()方法的实现，由于涉及到多个线程的异步调用，必然是需要使用锁来处理，而这里使用的是Lock来实现的，我们来看看runWorker()方法内主要实现：</p>
<p><img src="http://img.blog.csdn.net/20151117141139792" alt=""></p>
<p>可以看到在task.run()之前和之后分别调用了beforeExecute和afterExecute方法，并传入了我们的任务Runnable对象</p>
<p>而terminated()则是在关闭线程池的方法中调用，而关闭线程池有两个方法，我贴其中一个：</p>
<p><img src="http://img.blog.csdn.net/20151117141553421" alt=""></p>
<p>所以，我们要扩展线程池，只需要重写这三个方法，并实现我们自己的功能即可，这三个方法分别都会在任务执行前调用、任务执行完成后调用、线程池关闭后调用。<br>这里我验证一下，继承自ThreadPoolExecutor 并实现那三个方法：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue workQueue)</span> </span>{
        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>{
        <span class="keyword">super</span>.beforeExecute(t, r);
        String threadName = t.getName();
        Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">"准备执行任务！"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>{
        <span class="keyword">super</span>.afterExecute(r, t);
        String threadName = Thread.currentThread().getName();
        Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">"任务执行结束！"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.terminated();
        Log.v(<span class="string">"zxy"</span>, <span class="string">"线程池结束！"</span>);
    }
}
</code></pre><p>而运行后的结果则是，这正符合刚刚说的：</p>
<pre><code><span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">51.184</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程：pool-<span class="number">6</span>-thread-<span class="number">1</span>准备执行任务！
<span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">51.184</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程：pool-<span class="number">6</span>-thread-<span class="number">1</span>正在执行任务！
<span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">53.184</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程：pool-<span class="number">6</span>-thread-<span class="number">1</span>任务执行结束！
<span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">58.896</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程池结束！
</code></pre><p>所以，在上面我们的优先级线程池的代码上，我们再扩展一个具有暂停功能的优先级线程池，代码如下：<br>具有暂时功能的线程池：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PausableThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>{
    <span class="keyword">private</span> <span class="keyword">boolean</span> isPaused;
    <span class="keyword">private</span> ReentrantLock pauseLock = <span class="keyword">new</span> ReentrantLock();
    <span class="keyword">private</span> Condition unpaused = pauseLock.newCondition();

    <span class="function"><span class="keyword">public</span> <span class="title">PausableThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue workQueue)</span> </span>{
        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>{
        <span class="keyword">super</span>.beforeExecute(t, r);
        pauseLock.lock();
        <span class="keyword">try</span> {
            <span class="keyword">while</span> (isPaused) unpaused.await();
        } <span class="keyword">catch</span> (InterruptedException ie) {
            t.interrupt();
        } <span class="keyword">finally</span> {
            pauseLock.unlock();
        }

    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>{
        pauseLock.lock();
        <span class="keyword">try</span> {
            isPaused = <span class="keyword">true</span>;
        } <span class="keyword">finally</span> {
            pauseLock.unlock();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>{
        pauseLock.lock();
        <span class="keyword">try</span> {
            isPaused = <span class="keyword">false</span>;
            unpaused.signalAll();
        } <span class="keyword">finally</span> {
            pauseLock.unlock();
        }
    }
}
</code></pre><p>然后结合上面的优先级线程池的实现，创建具有暂停功能的优先级线程池：</p>
<pre><code>PausableThreadPoolExecutor pausableThreadPoolExecutor = <span class="keyword">new</span> PausableThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> PriorityBlockingQueue());
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="number">100</span>; i++) {
            final <span class="keyword">int</span> priority = i;
            pausableThreadPoolExecutor.execute(<span class="keyword">new</span> PriorityRunnable(priority) {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>{
                    runOnUiThread(<span class="keyword">new</span> Runnable() {
                        @<span class="function">Override
                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                            textView.setText(priority + <span class="string">""</span>);
                        }
                    });
                    <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">1000</span>);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
</code></pre><p>这里我为了演示效果，把这个线程池设为只有一个线程，然后直接在TextView中显示当前执行的任务的优先级，然后设置个开关，控制线程池的暂停与开始：</p>
<pre><code><span class="keyword">if</span> (isPause) {
    pausableThreadPoolExecutor.resume<span class="literal">()</span>;
    isPause = <span class="literal">false</span>;
} <span class="keyword">else</span> {
    pausableThreadPoolExecutor.pause<span class="literal">()</span>;
    isPause = <span class="literal">true</span>;
}
</code></pre><p>效果为：</p>
<p><img src="http://img.blog.csdn.net/20151117144914201" alt=""></p>
<p>从效果上来看，该线程池和优先级线程一样，而且还多了一个暂停与开始的功能</p>
<h2>优化线程池ThreadPoolExecutor</h2>

<p>虽说线程池极大改善了系统的性能，不过创建线程池也是需要资源的，所以线程池内线程数量的大小也会影响系统的性能，大了反而浪费资源，小了反而影响系统的吞吐量，所以我们创建线程池需要把握一个度才能合理的发挥它的优点，通常来说我们要考虑的因素有CPU的数量、内存的大小、并发请求的数量等因素，按需调整。</p>
<p><em>通常核心线程数可以设为CPU数量+1，而最大线程数可以设为CPU的数量\</em>2+1*</p>
<p>获取CPU数量的方法为：</p>
<pre><code><span class="tag">Runtime</span><span class="class">.getRuntime</span>()<span class="class">.availableProcessors</span>();
</code></pre><h2>shutdown()和shutdownNow()的区别</h2>

<p>关于线程池的停止，ExecutorService为我们提供了两个方法：shutdown和shutdownNow，这两个方法各有不同，可以根据实际需求方便的运用，如下：</p>
<ol>
<li>shutdown()方法在终止前允许执行以前提交的任务。</li>
<li>shutdownNow()方法则是阻止正在任务队列中等待任务的启动并试图停止当前正在执行的任务。</li>
</ol>
<h2>关于AsyncTask的实现</h2>

<p>大家都知道AsyncTask内部实现其实就是Thread+Handler。其中Handler是为了处理线程之间的通信，而这个Thread到底是指什么呢？通过AsyncTask源码可以得知，其实这个Thread是线程池，AsyncTask内部实现了两个线程池，分别是：串行线程池和固定线程数量的线程池。而这个固定线程数量则是通过CPU的数量决定的。</p>
<p>在默认情况下，我们大都通过AsyncTask::execute()来执行任务的，<br>，而execute()内部则是调用executeOnExecutor(sDefaultExecutor, params)方法执行的，第一个参数就是指定处理该任务的线程池，而默认情况下AsyncTask是传入串行线程池（在这里不讲版本的变化），也就是任务只能单个的按顺序执行，而我们要是想让AsyncTask并行的处理任务，大家都知道调用AsyncTask::executeOnExecutor(sDefaultExecutor, params)方法传入这个参数即可：AsyncTask.THREAD_POOL_EXECUTOR。<br>而这个参数的意义在于为任务指定了一个固定线程数量的线程池去处理，从而达到了并行处理的功能，我们可以在源码中看到AsyncTask.THREAD_POOL_EXECUTOR这个参数就是一个固定线程数量的线程池：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR
            = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,
                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>说到线程，我想大家都不陌生，因为在开发时候或多或少都会用到线程，而通常创建线程有两种方式：</p>
<ol>
<li>继承自Thread类</li>
<li>实现Runnable接口</li>
</ol>
<p>虽说这两种方式都可以创建出一个线程，不过它们之间还是有一点区别的，主要区别在于在多线程访问同一资源的情况下，用Runnable接口创建的线程可以处理同一资源，而用Thread类创建的线程则各自独立处理，各自拥有自己的资源。</p>
<p>所以，在Java中大多数多线程程序都是通过实现Runnable来完成的，而对于Android来说也不例外，当涉及到需要开启线程去完成某件事时，我们都会这样写：</p>
<pre><code><span class="tag">new</span> <span class="tag">Thread</span>(new <span class="function">Runnable</span>() {
    <span class="variable">@Override</span>
    public void <span class="function">run</span>() {
        <span class="comment">//do sth .</span>
    }
})<span class="class">.start</span>();
</code></pre><p>这段代码创建了一个线程并执行，它在任务结束后GC会自动回收该线程，一切看起来如此美妙，是的，它在线程并发不多的程序中确实不错，而假如这个程序有很多地方需要开启大量线程来处理任务，那么如果还是用上述的方式去创建线程处理的话，那么将导致系统的性能表现的非常糟糕，更别说在内存有限的移动设备上，主要的影响如下：</p>
<ol>
<li>线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失</li>
<li>大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM</li>
<li>大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿</li>
</ol>
<p>而针对上述所描述的问题，解决的办法归根到底就是：重用已有的线程，从而减少线程的创建。<br>所以这就涉及到线程池（ExecutorService）的概念了，线程池的基本作用就是进行线程的复用，下面将具体介绍线程池的使用</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之常见的内存泄漏]]></title>
    <link href="http://hanhailong.com/2015/12/27/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://hanhailong.com/2015/12/27/Android性能优化之常见的内存泄漏/</id>
    <published>2015-12-27T05:12:02.000Z</published>
    <updated>2015-12-27T05:41:37.000Z</updated>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>对于内存泄漏，我想大家在开发中肯定都遇到过，只不过内存泄漏对我们来说并不是可见的，因为它是在堆中活动，而要想检测程序中是否有内存泄漏的产生，通常我们可以借助LeakCanary、MAT等工具来检测应用程序是否存在内存泄漏，MAT是一款强大的内存分析工具，功能繁多而复杂，而LeakCanary则是由Square开源的一款轻量第三方内存泄漏检测工具，当它检测到程序中有内存泄漏的产生时，它将以最直观的方式告诉我们该内存泄漏是由谁产生的和该内存泄漏导致谁泄漏了而不能回收，供我们复查。</p>
<p>最近腾讯bugly也推出了三篇关于Android内存泄漏调优的文章：</p>
<ol>
<li><a href="http://bugly.qq.com/blog/?p=832" target="_blank" rel="external">内存泄露从入门到精通三部曲之基础知识篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=872" target="_blank" rel="external">内存泄露从入门到精通三部曲之排查方法篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=884" target="_blank" rel="external">内存泄露从入门到精通三部曲之常见原因与用户实践</a></li>
</ol>
<p>Realm同样给出了性能优化文章：</p>
<p><a href="https://realm.io/cn/news/droidcon-farber-improving-android-app-performance/" target="_blank" rel="external">10条提升Android性能的建议</a></p>
<a id="more"></a>
<h2>内存泄漏</h2>

<h4>为什么会产生内存泄漏？</h4>

<p>当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p>
<h4>内存泄漏对程序的影响？</h4>

<p>内存泄漏是造成应用程序OOM的主要原因之一！我们知道Android系统为每个应用程序分配的内存有限，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就造成了内存溢出而导致应用Crash。</p>
<h2>Android中常见的内存泄漏汇总</h2>

<h4>单例造成的内存泄漏</h4>

<p>单例模式非常受开发者的喜爱，不过使用的不恰当的话也会造成内存泄漏，由于单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。</p>
<p>如下这个典例：</p>
<pre><code>public class AppManager {
   <span class="keyword"> private</span><span class="keyword"> static</span> AppManager instance;
   <span class="keyword"> private</span> Context context;
   <span class="keyword"> private</span><span class="function"> AppManager(</span>Context context<span class="function">)</span> {
        this.context = context;
    }
   <span class="keyword"> public</span><span class="keyword"> static</span> AppManager<span class="function"> getInstance(</span>Context             context<span class="function">)</span> {
       <span class="instruction"> if </span>(instance != null<span class="function">)</span> {
           <span class="instruction"> instance </span>=<span class="instruction"> new </span>AppManager(context<span class="function">)</span>;
        }
       <span class="instruction"> return </span>instance;
    }
}
</code></pre><p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要： </p>
<ol>
<li>传入的是Application的Context：这将没有任何问题，因为单例的生命周期和Application的一样长</li>
<li>传入的是Activity的Context：当这个Context所对应的Activity退出时，由于该Context和Activity的生命周期一样长（Activity间接继承于Context），所以当前Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用。</li>
</ol>
<p>所以正确的单例应该修改为下面这种方式：</p>
<pre><code>public class AppManager {
   <span class="keyword"> private</span><span class="keyword"> static</span> AppManager instance;
   <span class="keyword"> private</span> Context context;
   <span class="keyword"> private</span><span class="function"> AppManager(</span>Context context<span class="function">)</span> {
        this.context =<span class="function"> context.getApplicationContext(</span><span class="function">)</span>;
    }
   <span class="keyword"> public</span><span class="keyword"> static</span> AppManager<span class="function"> getInstance(</span>Context context<span class="function">)</span> {
       <span class="instruction"> if </span>(instance != null<span class="function">)</span> {
           <span class="instruction"> instance </span>=<span class="instruction"> new </span>AppManager(context<span class="function">)</span>;
        }
       <span class="instruction"> return </span>instance;
    }
}
</code></pre><p>这样不管传入什么Context最终将使用Application的Context，而单例的生命周期和应用的一样长，这样就防止了内存泄漏</p>
<h4>非静态内部类创建静态实例造成的内存泄漏</h4>

<p>有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
    <span class="keyword">private</span> static <span class="type">TestResource</span> mResource = <span class="literal">null</span>;
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        <span class="keyword">if</span>(mResource == <span class="literal">null</span>){
            mResource = <span class="keyword">new</span> <span class="type">TestResource</span>();
        }
        <span class="comment">//...</span>
    }
    <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> {</span>
    <span class="comment">//...</span>
    }
}
</code></pre><p>这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而又使用了该非静态内部类创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为：<br>将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请使用ApplicationContext</p>
<h4>Handler造成的内存泄漏</h4>

<p>Handler的使用造成的内存泄漏问题应该说最为常见了，平时在处理网络任务或者封装一些请求回调等api都应该会借助Handler来处理，对于Handler的使用代码编写一不规范即有可能造成内存泄漏，如下示例：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
<span class="keyword">private</span> <span class="type">Handler</span> mHandler = <span class="keyword">new</span> <span class="type">Handler</span>() {
    <span class="annotation">@Override</span>
    public void handleMessage(<span class="type">Message</span> msg) {
    <span class="comment">//...</span>
    }
};
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        loadData();
    }
    <span class="keyword">private</span> void loadData(){
        <span class="comment">//...request</span>
        <span class="type">Message</span> message = <span class="type">Message</span>.obtain();
        mHandler.sendMessage(message);
    }
}
</code></pre><p>这种创建Handler的方式会造成内存泄漏，由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏，所以另外一种做法为：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
    <span class="keyword">private</span> <span class="type">MyHandler</span> mHandler = <span class="keyword">new</span> <span class="type">MyHandler</span>(<span class="keyword">this</span>);
    <span class="keyword">private</span> <span class="type">TextView</span> mTextView ;
    <span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Handler</span> {</span>
        <span class="keyword">private</span> <span class="type">WeakReference</span>&lt;<span class="type">Context</span>&gt; reference;
        public <span class="type">MyHandler</span>(<span class="type">Context</span> context) {
        reference = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;&gt;(context);
        }
        <span class="annotation">@Override</span>
        public void handleMessage(<span class="type">Message</span> msg) {
            <span class="type">MainActivity</span> activity = (<span class="type">MainActivity</span>) reference.get();
            <span class="keyword">if</span>(activity != <span class="literal">null</span>){
            activity.mTextView.setText(<span class="string">""</span>);
            }
        }
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        mTextView = (<span class="type">TextView</span>)findViewById(<span class="type">R</span>.id.textview);
        loadData();
    }

    <span class="keyword">private</span> void loadData() {
        <span class="comment">//...request</span>
        <span class="type">Message</span> message = <span class="type">Message</span>.obtain();
        mHandler.sendMessage(message);
    }
}
</code></pre><p>创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息，更准确的做法如下：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
    <span class="keyword">private</span> <span class="type">MyHandler</span> mHandler = <span class="keyword">new</span> <span class="type">MyHandler</span>(<span class="keyword">this</span>);
    <span class="keyword">private</span> <span class="type">TextView</span> mTextView ;
    <span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Handler</span> {</span>
        <span class="keyword">private</span> <span class="type">WeakReference</span>&lt;<span class="type">Context</span>&gt; reference;
        public <span class="type">MyHandler</span>(<span class="type">Context</span> context) {
        reference = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;&gt;(context);
        }
        <span class="annotation">@Override</span>
        public void handleMessage(<span class="type">Message</span> msg) {
            <span class="type">MainActivity</span> activity = (<span class="type">MainActivity</span>) reference.get();
            <span class="keyword">if</span>(activity != <span class="literal">null</span>){
            activity.mTextView.setText(<span class="string">""</span>);
            }
        }
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        mTextView = (<span class="type">TextView</span>)findViewById(<span class="type">R</span>.id.textview);
        loadData();
    }

    <span class="keyword">private</span> void loadData() {
        <span class="comment">//...request</span>
        <span class="type">Message</span> message = <span class="type">Message</span>.obtain();
        mHandler.sendMessage(message);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onDestroy() {
        <span class="keyword">super</span>.onDestroy();
        mHandler.removeCallbacksAndMessages(<span class="literal">null</span>);
    }
}
</code></pre><p>使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages();来移除指定的Runnable和Message。</p>
<h4>线程造成的内存泄漏</h4>

<p>对于线程造成的内存泄漏，也是平时比较常见的，异步任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成，<br>那么将导致Activity的内存资源无法回收，造成内存泄漏。正确的做法还是使用静态内部类的方式，如下：</p>
<pre><code><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">Void</span>&gt; </span>{
    <span class="keyword">private</span> WeakReference&lt;Context&gt; weakReference;

    <span class="function"><span class="keyword">public</span> <span class="title">MyAsyncTask</span><span class="params">(Context context)</span> </span>{
        weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>{
        SystemClock.sleep(<span class="number">10000</span>);
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Void aVoid)</span> </span>{
        <span class="keyword">super</span>.onPostExecute(aVoid);
        MainActivity activity = (MainActivity) weakReference.get();
        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) {
        <span class="comment">//...</span>
        }
    }
}
<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        SystemClock.sleep(<span class="number">10000</span>);
    }
}
<span class="comment">//——————</span>
<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();
<span class="keyword">new</span> MyAsyncTask(<span class="keyword">this</span>).execute();
</code></pre><p>这样就避免了Activity的内存资源泄漏，当然在Activity销毁时候也应该取消相应的任务AsyncTask::cancel()，避免任务在后台执行浪费资源。</p>
<h4>资源未关闭造成的内存泄漏</h4>

<p>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>
<h4>一些建议</h4>

<ol>
<li>对于生命周期比Activity长的对象如果需要应该使用ApplicationContext</li>
<li>对于需要在静态内部类中使用非静态外部成员变量（如：Context、View )，可以在静态内部类中使用弱引用来引用外部类的变量来避免内存泄漏</li>
<li>对于不再需要使用的对象，显示的将其赋值为null，比如使用完Bitmap后先调用recycle()，再赋为null</li>
<li>保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期</li>
<li><p>对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏：</p>
<ol>
<li>将内部类改为静态内部类</li>
<li>静态内部类中使用弱引用来引用外部类的成员变量</li>
</ol>
</li>
<li><p>在涉及到Context时先考虑ApplicationContext，当然它并不是万能的，对于有些地方则必须使用Activity的Context，对于Application，Service，Activity三者的Context的应用场景如下：</p>
</li>
</ol>
<p><img src="http://img.blog.csdn.net/20151123144226349" alt=""></p>
<p><strong>其中：</strong>NO1表示Application和Service可以启动一个Activity，不过需要创建一个新的task任务队列。而对于Dialog而言，只有在Activity中才能创建</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>前言</h2>

<p>对于内存泄漏，我想大家在开发中肯定都遇到过，只不过内存泄漏对我们来说并不是可见的，因为它是在堆中活动，而要想检测程序中是否有内存泄漏的产生，通常我们可以借助LeakCanary、MAT等工具来检测应用程序是否存在内存泄漏，MAT是一款强大的内存分析工具，功能繁多而复杂，而LeakCanary则是由Square开源的一款轻量第三方内存泄漏检测工具，当它检测到程序中有内存泄漏的产生时，它将以最直观的方式告诉我们该内存泄漏是由谁产生的和该内存泄漏导致谁泄漏了而不能回收，供我们复查。</p>
<p>最近腾讯bugly也推出了三篇关于Android内存泄漏调优的文章：</p>
<ol>
<li><a href="http://bugly.qq.com/blog/?p=832">内存泄露从入门到精通三部曲之基础知识篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=872">内存泄露从入门到精通三部曲之排查方法篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=884">内存泄露从入门到精通三部曲之常见原因与用户实践</a></li>
</ol>
<p>Realm同样给出了性能优化文章：</p>
<p><a href="https://realm.io/cn/news/droidcon-farber-improving-android-app-performance/">10条提升Android性能的建议</a></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sublime Text自动开启换行Word Wrap]]></title>
    <link href="http://hanhailong.com/2015/11/24/Sublime-Text%E8%87%AA%E5%8A%A8%E5%BC%80%E5%90%AF%E6%8D%A2%E8%A1%8CWord-Wrap/"/>
    <id>http://hanhailong.com/2015/11/24/Sublime-Text自动开启换行Word-Wrap/</id>
    <published>2015-11-24T10:02:27.000Z</published>
    <updated>2015-11-24T10:22:38.000Z</updated>
    <content type="html"><![CDATA[<p>Sublime Text，绝对是神器中的神器，之前在windows电脑上一直都是用nodepad++。mac上也没找到太好的编辑工具，之前曾用过破解版的<em>UltraEdit</em>，但是自从第一次用了Sublime Text后，就彻底的把它打入冷宫了！！</p>
<p>下面讲讲如何开启Sublime Text的自动换行功能，默认情况下是不开启的。当然你也可以点击导航栏上View-&gt;Word Wrap开启，不过对我们程序猿来说，还是太麻烦了。这里从根本上解决自动换行的问题。</p>
<p>解决方案：<br>    我这里用的是mac版本的，windows同理</p>
<pre><code>Preferences-&gt;Setting - <span class="built_ins">User</span>
</code></pre><p>在打开的<em>Preferences.sublime-settings</em>文件里面，你将会看到类似下面的内容：</p>
<pre><code>{
    "<span class="attribute">ignored_packages</span>":
    <span class="value">[
        <span class="string">"Markdown"</span>,
        <span class="string">"Vintage"</span>
    ]
</span>}
</code></pre><p>很明显，这是一个json格式的配置文件，在后面直接追加</p>
<pre><code>{ "<span class="attribute">word_wrap</span>" : <span class="value"><span class="literal">true</span> </span>}
</code></pre><p>修改之后的文件内容为：</p>
<pre><code>{
    "<span class="attribute">ignored_packages</span>":
    <span class="value">[
        <span class="string">"Markdown"</span>,
        <span class="string">"Vintage"</span>
    ]</span>,
    "<span class="attribute">word_wrap</span>":<span class="value"><span class="literal">true</span>
</span>}
</code></pre><p>重启Sublime Text后，你将会发现文字、代码超过一行后会自动换行！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Sublime Text，绝对是神器中的神器，之前在windows电脑上一直都是用nodepad++。mac上也没找到太好的编辑工具，之前曾用过破解版的<em>UltraEdit</em>，但是自从第一次用了Sublime Text后，就彻底的把它打入冷宫了！！</p>
<]]>
    </summary>
    
      <category term="Sublime Text" scheme="http://hanhailong.com/tags/Sublime-Text/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-小米桌面图标显示角标数]]></title>
    <link href="http://hanhailong.com/2015/11/23/Android-%E5%B0%8F%E7%B1%B3%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA%E8%A7%92%E6%A0%87%E6%95%B0/"/>
    <id>http://hanhailong.com/2015/11/23/Android-小米桌面图标显示角标数/</id>
    <published>2015-11-23T07:07:11.000Z</published>
    <updated>2015-11-23T10:02:09.000Z</updated>
    <content type="html"><![CDATA[<h3>基本介绍</h3>

<p>最近有群里问：怎样在小米手机桌面的图标上显示角标数，我看了下我的红米note手机，果然有的第三方app图标上显示角标数，尤其是微信和QQ。这让我立马想到了：小米是不是对通知栏做了手脚。立马我查了相关文档并做了相关的测试，发现果然如我猜测的：MIUI系统对通知栏做了手脚。它目前有两种情况：</p>
<ol>
<li>默认情况<br> 当第三方app向通知栏发送一条通知（一般不带进度条并且用户可以删除的通知），那么此时app icon的角标数就会显示1。<br> 这个时候app显示的角标数和通知栏里app发送的通知数是对应的，即向通知栏发多少条通知就会显示多少角标数。</li>
</ol>
<a id="more"></a>
<ol>
<li><p>定义角标数量<br> 如果想让app在通知栏里只显示一条通知，但角标数是多个怎么办呢？</p>
<p> 原理是通过反射拿到<em>Notification</em>的私有属性<em>extraNotification</em>，重点就是这个<em>extraNotification</em>,MIUI系统对这个重定义了，这个类在MIUI系统里是<em>android.app.MiuiNotification</em>这个类，这个类里面有个私有属性<em>messageCount</em>,我们只要改变这个<em>messageCount</em>值就能显示的改变app icon的角标数了。如下图所示：</p>
</li>
</ol>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/miui_notification.png?raw=true" alt="miuinotification">    </p>
<p>这里给出代码示例：</p>
<pre><code><span class="type">NotificationCompat</span>.<span class="type">Builder</span> builder = new <span class="type">NotificationCompat</span>.<span class="type">Builder</span>(this)
            .setSmallIcon(R.mipmap.ic_launcher)
            .setContentTitle(<span class="string">"小米角标"</span>)
            .setContentText(<span class="string">"miui桌面角标消息"</span>);

    <span class="type">NotificationManagerCompat</span> managerCompat = <span class="type">NotificationManagerCompat</span>.<span class="keyword">from</span>(this);

    <span class="type">Notification</span> notification = builder.build();
    <span class="keyword">try</span> {
        <span class="type">Field</span> field = notification.getClass().getDeclaredField(<span class="string">"extraNotification"</span>);

        <span class="type">Object</span> extraNotification = field.get(notification);

        <span class="type">Method</span> <span class="keyword">method</span> = extraNotification.getClass().getDeclaredMethod(<span class="string">"setMessageCount"</span>, <span class="type">int</span>.class);

        <span class="keyword">method</span>.invoke(extraNotification, <span class="number">10</span>);
    } catch (<span class="type">Exception</span> e) {
          e.printStackTrace();
    }

    managerCompat.notify(<span class="number">0</span>, notification);
</code></pre><p>上面的数字10就是要显示的角标数，我们看下结果：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/miui_app_icon_count.png?raw=true" alt="app-icon"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3>基本介绍</h3>

<p>最近有群里问：怎样在小米手机桌面的图标上显示角标数，我看了下我的红米note手机，果然有的第三方app图标上显示角标数，尤其是微信和QQ。这让我立马想到了：小米是不是对通知栏做了手脚。立马我查了相关文档并做了相关的测试，发现果然如我猜测的：MIUI系统对通知栏做了手脚。它目前有两种情况：</p>
<ol>
<li>默认情况<br> 当第三方app向通知栏发送一条通知（一般不带进度条并且用户可以删除的通知），那么此时app icon的角标数就会显示1。<br> 这个时候app显示的角标数和通知栏里app发送的通知数是对应的，即向通知栏发多少条通知就会显示多少角标数。</li>
</ol>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-部分作品鉴赏]]></title>
    <link href="http://hanhailong.com/2015/11/04/Android-%E9%83%A8%E5%88%86%E4%BD%9C%E5%93%81%E9%89%B4%E8%B5%8F/"/>
    <id>http://hanhailong.com/2015/11/04/Android-部分作品鉴赏/</id>
    <published>2015-11-04T15:32:50.000Z</published>
    <updated>2015-11-04T15:56:09.000Z</updated>
    <content type="html"><![CDATA[<p>时间过得真快，马上快毕业四年了，这里整理了下我做过的部分App，当然还有一些其他的App，不是外包就是没有纪念意义，这里就不列举了！</p>
<a id="more"></a>
<h3>51拉勾</h3>

<p><a href="http://www.wandoujia.com/apps/com.ydcy.lago.app" target="_blank" rel="external">51拉钩</a>是我做过的第二个商业Android客户端App，承载了我很多记忆，现在还记得当初和小伙伴们加班到晚上11点、12点甚至凌晨两三点的情景（岁月不饶人啊~~~）！！！</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-1.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-2.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-3.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-4.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-5.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-6.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-7.png?raw=true" alt="家庭首页"></p>
<h3>51听听</h3>

<p><a href="http://www.wandoujia.com/apps/com.ydcy.ting.app" target="_blank" rel="external">51听听</a>是继51拉钩之后的又一个商业App，这个App比较有意思，里面包括大量童话、唐诗三百首等儿童教育方面的故事！！！</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-1.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-2.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-3.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-4.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-5.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-6.png?raw=true" alt="51听"></p>
<h3>发镖</h3>

<p><a href="http://www.wandoujia.com/apps/com.cubead.appclient" target="_blank" rel="external">发镖</a>这是我加入北京博雅立方做过的唯一的一款App，包括IOS版本，这个App以前叫营销掌中宝，是国内首家最专业的营销推广平台，服务类目包括微信营销、百度营销、建站推广等多产品类目。</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-1.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-2.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-3.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-4.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-5.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-6.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-7.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-8.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-9.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-10.png?raw=true" alt="发镖"></p>
<h3>极客学院</h3>

<p><a href="http://www.jikexueyuan.com/app/" target="_blank" rel="external">极客学院</a>，中国最大的IT职业在线教育平台！！</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-1.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-2.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-3.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-4.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-5.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-6.png?raw=true" alt="jike"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>时间过得真快，马上快毕业四年了，这里整理了下我做过的部分App，当然还有一些其他的App，不是外包就是没有纪念意义，这里就不列举了！</p>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://hanhailong.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android版本-编译VLC]]></title>
    <link href="http://hanhailong.com/2015/10/27/Android%E7%89%88%E6%9C%AC-%E7%BC%96%E8%AF%91VLC/"/>
    <id>http://hanhailong.com/2015/10/27/Android版本-编译VLC/</id>
    <published>2015-10-27T13:54:31.000Z</published>
    <updated>2015-11-05T16:06:59.000Z</updated>
    <content type="html"><![CDATA[<h2>简述</h2>

<p>最近公司项目<a href="http://www.jikexueyuan.com/app/" target="_blank" rel="external">极客学院</a>在线播放器要加一个需求：支持播放倍数加速、支持字幕；之前用的是一个第三方的开源库<a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="external">ijkplayer</a>，这个库也非常的给力，它对ffmpeg做了很好的封装，不过不支持加速减速播放，所以弃用改成<a href="https://wiki.videolan.org/AndroidCompile" target="_blank" rel="external">VLC-Android</a>，IOS的在这<a href="https://wiki.videolan.org/IOSCompile" target="_blank" rel="external">VLC-IOS</a>.</p>
<a id="more"></a>
<p>这里记录下编译Android版本的过程和遇到的错误：</p>
<p>总体来说是比较顺利的，按照官方的wiki文档一步一步走下来，基本上没有遇到大问题，遇到唯一的问题是<a href="http://download.csdn.net/detail/hanhailong726188/9218615" target="_blank" rel="external">xz-5.0.3.tar.bz2</a>和<a href="http://download.csdn.net/detail/hanhailong726188/9218631" target="_blank" rel="external">protobuf-2.6.1.tar.gz</a>这两个库文件没有下载些来（因为被墙了），我单独下载安装的，这里我把这两个文件放到CSDN上了，有需要的自行下载！！</p>
<h2>编译过程</h2>

<p>编译的第一步肯定是需要下载一些必要的工具，如果你的系统是Linux，你可以通过api-get来安装：</p>
<pre><code><span class="label">sudo</span> apt-<span class="preprocessor">get</span> install automake ant autopoint cmake <span class="keyword">build-essential </span>libtool \
     patch pkg-config protobuf-compiler ragel <span class="keyword">subversion </span>unzip git
</code></pre><p>我这里用的是Mac Ox，所以采用<a href="http://brew.sh/" target="_blank" rel="external">HomeBrew</a>来安装，首先需要执行命令：</p>
<pre><code><span class="keyword">brew </span>install automake ant autopoint cmake <span class="keyword">build-essential </span>libtool \
     patch pkg-config protobuf-compiler ragel <span class="keyword">subversion </span>unzip git
</code></pre><p>然后等待上面的工具安装完成，安装完成后开始执行下一步</p>
<p>这里假设你已经装好<a href="http://developer.android.com/sdk/index.html" target="_blank" rel="external">Android SDK</a>和<a href="http://developer.android.com/tools/sdk/ndk/index.html" target="_blank" rel="external">Android NDK</a></p>
<h4>配置环境变量</h4>

<p>1.cd命令到当前用户目录下，打开.bash_profile文件：</p>
<pre><code><span class="title">cd</span> <span class="regexp">~
open</span> .bash_profile
</code></pre><p>如果没有.bash_profile，请touch新建一个.bash_profile</p>
<pre><code><span class="tag">touch</span> <span class="class">.bash_profile</span>
</code></pre><p>打开.bash_profile文件后，在文件里面输入</p>
<pre><code>export ANDROID_SDK=/Users/HanHailong/Library/Android/sdk
export ANDROID_NDK=/Users/HanHailong/NDK/android-ndk-r10e
export PATH=<span class="variable">$PATH</span>:<span class="variable">$ANDROID</span>_SDK/platform-tools:<span class="variable">$ANDROID</span>_SDK/tools
</code></pre><p>ANDROID_SDK和ANDROID_NDK后面的换成你自己对应的路径。</p>
<h4>克隆代码</h4>

<pre><code>git clone <span class="string">git:</span><span class="comment">//git.videolan.org/vlc-ports/android.git</span>
</code></pre><p></p><h5>编译工程</h5><br>将项目clone下来后就开始编译项目了，<br>cd命令到你clone下来的工程里面，执行命令：<p></p>
<pre><code>./compile.<span class="keyword">sh</span>
</code></pre><p>然后VLC会自动执行一长系列的下载、编译工作，这里需要等老长时间，如果你有vpn，最好开启vpn，因为一些用到的文件被墙了！！我这里就遇到坑了，<a href="http://download.csdn.net/detail/hanhailong726188/9218615" target="_blank" rel="external">xz-5.0.3.tar.bz2</a>和<a href="http://download.csdn.net/detail/hanhailong726188/9218631" target="_blank" rel="external">protobuf-2.6.1.tar.gz</a>下载失败，而导致VLC编译失败，没办法，只能将上面两个文件单独下载下来.</p>
<ol>
<li><p>解压并安装protobuf</p>
<p> 一步一步执行下面如下命令：</p>
<pre><code>tar -zxf protobuf-<span class="number">2.6</span><span class="number">.1</span>.tar.gz
cd protobuf-<span class="number">2.6</span><span class="number">.1</span>
./configure
make install
</code></pre></li>
</ol>
<ol>
<li><p>解压并安装xz</p>
<p> 一步一步执行下面如下命令：</p>
<pre><code>tar -zxf xz-<span class="number">5.0</span><span class="number">.3</span>.tar.bz2
cd xz-<span class="number">5.0</span><span class="number">.3</span>
./configure
make install
</code></pre></li>
</ol>
<p>执行完了后，继续回到VLC工程目录下执行命令：</p>
<pre><code>./compile.<span class="keyword">sh</span>
</code></pre><p>之后，VLC会继续执行下载、编译库文件，稍微等一段时间，快得几分钟，慢的十几分钟！！看编译成功后的截图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_android.png?raw=true" alt="VLC"></p>
<h4>编译结果</h4>

<p>编译成功后，会在<font color="red">vlc-android/build/outputs/apk</font>目录下生成编译后的apk包：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_apk.png?raw=true" alt="apk"></p>
<p>我们将其安装到真机上，效果图还是蛮不错的：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_1.png?raw=true" alt="image1"><br><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_2.png?raw=true" alt="image2"><br><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_3.png?raw=true" alt="image3"></p>
<p>VLC很强大，支持字幕，支持锁定屏幕，支持跳转到某个具体时间，支持0.25-4倍的慢放、快放、支持亮度调节、支持音量调节、支持快进、支持直播等特性，是做在线视频播放的绝佳选择之一！！！！</p>
<p>上面两个<a href="http://download.csdn.net/detail/hanhailong726188/9218615" target="_blank" rel="external">xz-5.0.3.tar.bz2</a>和<a href="http://download.csdn.net/detail/hanhailong726188/9218631" target="_blank" rel="external">protobuf-2.6.1.tar.gz</a>可以在这里下载！</p>
<p>最后，附上我编译好的项目<a href="https://github.com/hanhailong/VCL-Android" target="_blank" rel="external">VLC-Android</a>，这里我只编译了四种so包（armeabi-v7a、armeabi、x86、mips），有需要的朋友自行下载。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>简述</h2>

<p>最近公司项目<a href="http://www.jikexueyuan.com/app/">极客学院</a>在线播放器要加一个需求：支持播放倍数加速、支持字幕；之前用的是一个第三方的开源库<a href="https://github.com/Bilibili/ijkplayer">ijkplayer</a>，这个库也非常的给力，它对ffmpeg做了很好的封装，不过不支持加速减速播放，所以弃用改成<a href="https://wiki.videolan.org/AndroidCompile">VLC-Android</a>，IOS的在这<a href="https://wiki.videolan.org/IOSCompile">VLC-IOS</a>.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不错的IOS学习博客网站-IOS122]]></title>
    <link href="http://hanhailong.com/2015/10/22/%E4%B8%8D%E9%94%99%E7%9A%84IOS%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99-IOS122/"/>
    <id>http://hanhailong.com/2015/10/22/不错的IOS学习博客网站-IOS122/</id>
    <published>2015-10-22T08:58:51.000Z</published>
    <updated>2015-10-22T09:07:09.000Z</updated>
    <content type="html"><![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第四篇，只不过<a href="http://www.ios122.com/" target="_blank" rel="external">IOS122</a>只讲解IOS技术。</p>
<p>当我第一次打开这个博客的时候，我被里面的第三库资源震惊了，没想到作者整理了这么多的第三库资源。最重要的是，里面的博文质量非常高，绝对是IOS学习技术的最佳去处！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第四篇，只不过<a href="http://www.ios122.com/" targe]]>
    </summary>
    
      <category term="技术博客" scheme="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[cocoapods安装失败-bad response Not Found 404 (http://ruby.taobao.org/latest_specs.4.8.gz]]></title>
    <link href="http://hanhailong.com/2015/10/22/cocoapods%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5-bad-response-Not-Found-404-http-ruby-taobao-org-latest-specs-4-8-gz/"/>
    <id>http://hanhailong.com/2015/10/22/cocoapods安装失败-bad-response-Not-Found-404-http-ruby-taobao-org-latest-specs-4-8-gz/</id>
    <published>2015-10-22T05:37:34.000Z</published>
    <updated>2015-10-22T06:17:49.000Z</updated>
    <content type="html"><![CDATA[<p>最近把MAC系统升级到了最新版本-10.11（OS X EI Capitan），发现之前装的<a href="https://github.com/CocoaPods/CocoaPods" target="_blank" rel="external">CocoaPods</a>不能用了，只好重新装了。执行如下命令：</p>
<pre><code>sudo gem <span class="keyword">install</span> cocoapods
</code></pre><p>发现报如下错误：<br><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/pod_error.png?raw=true" alt="image"></p>
<a id="more"></a>
<p>我之前就是用的淘宝的镜像<a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a>，我们在浏览器上输入：<a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a>，链接自动重定向到了<a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a>，淘宝镜像也给了提示：</p>
<p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/taobao_tips.png?raw=true" alt="image"></p>
<p>好吧，那我们只能删掉http的，改成https的，执行命令：</p>
<pre><code>gem sources --remove <span class="string">http:</span><span class="comment">//ruby.taobao.org/</span>
gem sources -a <span class="string">https:</span><span class="comment">//ruby.taobao.org/</span>
</code></pre><p>改掉之后我们继续使用命令查看我们改之后的ruby镜像：</p>
<pre><code>gem sources <span class="operator">-l</span>
</code></pre><p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/pod_new.png?raw=true" alt="image"></p>
<p>我们继续安装cocoapods，执行命令：</p>
<pre><code>sudo gem <span class="keyword">install</span> cocoapods
</code></pre><p>这时候会让你输入密码，输入密码完了之后就开始真正的安装cocoapods了</p>
<p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/pod_install.png?raw=true" alt="image"></p>
<p>安装完之后，执行命令：</p>
<pre><code>pod <span class="comment">--version</span>
</code></pre><p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/pod_version.png?raw=true" alt="image"></p>
<p>出现版本0.39.0之后，就说明安装成功了！！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近把MAC系统升级到了最新版本-10.11（OS X EI Capitan），发现之前装的<a href="https://github.com/CocoaPods/CocoaPods">CocoaPods</a>不能用了，只好重新装了。执行如下命令：</p>
<pre><code>sudo gem <span class="keyword">install</span> cocoapods
</code></pre><p>发现报如下错误：<br><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/pod_error.png?raw=true" alt="image"></p>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://hanhailong.com/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-教你自作一个简单而又实用的流式Tag标签布局]]></title>
    <link href="http://hanhailong.com/2015/10/20/Android-%E6%95%99%E4%BD%A0%E8%87%AA%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%80%8C%E5%8F%88%E5%AE%9E%E7%94%A8%E7%9A%84%E6%B5%81%E5%BC%8FTag%E6%A0%87%E7%AD%BE%E5%B8%83%E5%B1%80/"/>
    <id>http://hanhailong.com/2015/10/20/Android-教你自作一个简单而又实用的流式Tag标签布局/</id>
    <published>2015-10-20T10:26:19.000Z</published>
    <updated>2015-10-20T13:44:35.000Z</updated>
    <content type="html"><![CDATA[<p>在这一章节，我们继续学习Android自定义控件。这里要自定义的是Android里面的一个常用控件-Android流式Tag布局，这里我们命名为：<a href="https://github.com/hanhailong/FlowTag/blob/master/library/src/main/java/com/hhl/library/FlowTagLayout.java" target="_blank" rel="external">FlowTagLayout</a>，我们要实现的流式布局，有如下特色：</p>
<ul>
<li>填充数据和ListView、GridView用法一样使用Adapter，更新数据直接通过adapter.notifyDataChanged来更新</li>
<li>支持点击、单选、多选三种模式：FLOW_TAG_CHECKED_NONE、FLOW_TAG_CHECKED_SINGLE、FLOW_TAG_CHECKED_MULTI</li>
</ul>
<h3>正式讲解之前先看下我们实现后的效果图：</h3>

<p> <img src="https://github.com/hanhailong/AndroidStudyResources/raw/master/screenshot/flow_tag.gif?raw=true" alt="image"></p>
<a id="more"></a>
<p>目前网上有很多的教程来写流式布局实现，我看到的版本大体上有两种，一种是继承<font color="red">ViewGroup</font>，然后重写其<font color="red">onMeasure</font>和<font color="red">onLayout</font>方法，另一种则是继承自<font color="red">RelativeLayout</font>，例如这个<a href="https://github.com/kaedea/Android-Cloud-TagView-Plus/blob/master/library/src/main/java/me/kaede/tagview/TagView.java" target="_blank" rel="external">TagView</a></p>
<p>而我们这里采用的是第一种方法，因为我感觉第一种方法简单、清晰、明了！！</p>
<p>因为我们直接继承的<em>ViewGroup</em>，所以要指定它的<em>LayoutParams</em>，这里因为只需要margin，所以我们直接返回<em>MarginLayoutParams</em>就可以了，代码如下：</p>
<pre><code><span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> MarginLayoutParams(getContext(), attrs);
    }
</code></pre><h3>onMeasure测量</h3>

<pre><code>@<span class="function">Override
    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>{
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);

        <span class="comment">//获取Padding</span>
        <span class="comment">// 获得它的父容器为它设置的测量模式和大小</span>
        <span class="keyword">int</span> sizeWidth = MeasureSpec.getSize(widthMeasureSpec);
        <span class="keyword">int</span> sizeHeight = MeasureSpec.getSize(heightMeasureSpec);
        <span class="keyword">int</span> modeWidth = MeasureSpec.getMode(widthMeasureSpec);
        <span class="keyword">int</span> modeHeight = MeasureSpec.getMode(heightMeasureSpec);

        <span class="comment">//FlowLayout最终的宽度和高度值</span>
        <span class="keyword">int</span> resultWidth = <span class="number">0</span>;
        <span class="keyword">int</span> resultHeight = <span class="number">0</span>;

        <span class="comment">//测量时每一行的宽度</span>
        <span class="keyword">int</span> lineWidth = <span class="number">0</span>;
        <span class="comment">//测量时每一行的高度，加起来就是FlowLayout的高度</span>
        <span class="keyword">int</span> lineHeight = <span class="number">0</span>;

        <span class="comment">//遍历每个子元素</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, childCount = getChildCount(); i &lt; childCount; i++) {
            View childView = getChildAt(i);
            <span class="comment">//测量每一个子view的宽和高</span>
            measureChild(childView, widthMeasureSpec, heightMeasureSpec);

            <span class="comment">//获取到测量的宽和高</span>
            <span class="keyword">int</span> childWidth = childView.getMeasuredWidth();
            <span class="keyword">int</span> childHeight = childView.getMeasuredHeight();

            <span class="comment">//因为子View可能设置margin，这里要加上margin的距离</span>
            MarginLayoutParams mlp = (MarginLayoutParams) childView.getLayoutParams();
            <span class="keyword">int</span> realChildWidth = childWidth + mlp.leftMargin + mlp.rightMargin;
            <span class="keyword">int</span> realChildHeight = childHeight + mlp.topMargin + mlp.bottomMargin;

            <span class="comment">//如果当前一行的宽度加上要加入的子view的宽度大于父容器给的宽度，就换行</span>
            <span class="keyword">if</span> ((lineWidth + realChildWidth) &gt; sizeWidth) {
                <span class="comment">//换行</span>
                resultWidth = Math.max(lineWidth, realChildWidth);
                resultHeight += realChildHeight;
                <span class="comment">//换行了，lineWidth和lineHeight重新算</span>
                lineWidth = realChildWidth;
                lineHeight = realChildHeight;
            } <span class="keyword">else</span> {
                <span class="comment">//不换行，直接相加</span>
                lineWidth += realChildWidth;
                <span class="comment">//每一行的高度取二者最大值</span>
                lineHeight = Math.max(lineHeight, realChildHeight);
            }

            <span class="comment">//遍历到最后一个的时候，肯定走的是不换行</span>
            <span class="keyword">if</span> (i == childCount - <span class="number">1</span>) {
                resultWidth = Math.max(lineWidth, resultWidth);
                resultHeight += lineHeight;
            }

            setMeasuredDimension(modeWidth == MeasureSpec.EXACTLY ? sizeWidth : resultWidth,
                    modeHeight == MeasureSpec.EXACTLY ? sizeHeight : resultHeight);

        }

    }
</code></pre><p>代码注释的很详细，首先得到其父容器传入的测量模式和宽高的计算值，然后遍历所有的childView，使用measureChild方法对所有的childView进行测量。然后根据所有childView的测量得出的宽和高得到该ViewGroup如果设置为wrap_content时的宽和高</p>
<h3>onLayout</h3>

<pre><code>@<span class="function">Override
<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(boolean changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>{

    <span class="keyword">int</span> flowWidth = getWidth();

    <span class="keyword">int</span> childLeft = <span class="number">0</span>;
    <span class="keyword">int</span> childTop = <span class="number">0</span>;

    <span class="comment">//遍历子控件，记录每个子view的位置</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, childCount = getChildCount(); i &lt; childCount; i++) {
        View childView = getChildAt(i);

        <span class="comment">//跳过View.GONE的子View</span>
        <span class="keyword">if</span> (childView.getVisibility() == View.GONE) {
            <span class="keyword">continue</span>;
        }

        <span class="comment">//获取到测量的宽和高</span>
        <span class="keyword">int</span> childWidth = childView.getMeasuredWidth();
        <span class="keyword">int</span> childHeight = childView.getMeasuredHeight();

        <span class="comment">//因为子View可能设置margin，这里要加上margin的距离</span>
        MarginLayoutParams mlp = (MarginLayoutParams) childView.getLayoutParams();

        <span class="keyword">if</span> (childLeft + mlp.leftMargin + childWidth + mlp.rightMargin &gt; flowWidth) {
            <span class="comment">//换行处理</span>
            childTop += (mlp.topMargin + childHeight + mlp.bottomMargin);
            childLeft = <span class="number">0</span>;
        }
        <span class="comment">//布局</span>
        <span class="keyword">int</span> left = childLeft + mlp.leftMargin;
        <span class="keyword">int</span> top = childTop + mlp.topMargin;
        <span class="keyword">int</span> right = childLeft + mlp.leftMargin + childWidth;
        <span class="keyword">int</span> bottom = childTop + mlp.topMargin + childHeight;
        childView.layout(left, top, right, bottom);

        childLeft += (mlp.leftMargin + childWidth + mlp.rightMargin);
    }
}
</code></pre><p>onLayout方法就是将子View摆放到FlowTagLayout中，核心就是childView.layout(l,t,r,b)方法。</p>
<p>测量完了，布局也完了，下面就是填充数据了，我们这里采用的是Adapter模式，用法基本上和我们常用的ListView、GridView一样，用户只要写一个适配器Adapter，然后调用xxx.setAdapter方法，就把数据源绑到控件上了，而且这种做法还有个好处：子View可以是任意类型的控件</p>
<h3>填充数据和ListView、GridView用法一样使用Adapter，更新数据直接通过adapter.notifyDataChanged来更新</h3>

<p>我研究了下ListView和GridView的adapter.notifyDataChanged实现，一句话：观察者模式！首先，我们要在<em>FlowTagLayout</em>里面注册一个观察者，当我们调用adapter.notifyDataChanged的时候能通知这个观察者来刷新页面。</p>
<pre><code><span class="comment">/**
     * 像ListView、GridView一样使用FlowLayout
     *
     * <span class="doctag">@param</span> adapter
     */</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(ListAdapter adapter)</span> </span>{
        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span> &amp;&amp; mDataSetObserver != <span class="keyword">null</span>) {
            mAdapter.unregisterDataSetObserver(mDataSetObserver);
        }

        <span class="comment">//清除现有的数据</span>
        removeAllViews();
        mAdapter = adapter;

        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) {
            mDataSetObserver = <span class="keyword">new</span> AdapterDataSetObserver();
            mAdapter.registerDataSetObserver(mDataSetObserver);
        }
    }
</code></pre><p> 方法                mAdapter.registerDataSetObserver(mDataSetObserver);<br>就注册了观察者，我们继续看：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">AdapterDataSetObserver</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">DataSetObserver</span> {</span>
        <span class="annotation">@Override</span>
        public void onChanged() {
            <span class="keyword">super</span>.onChanged();
            reloadData();
        }

        <span class="annotation">@Override</span>
        public void onInvalidated() {
            <span class="keyword">super</span>.onInvalidated();
        }
    }
</code></pre><p>当我们调用adapter.notifyDataChanged方法的时候，就会执行<em>onChanged</em>这个方法，我加了一个<em>reloadData</em>方法：</p>
<pre><code><span class="comment">/**
     * 重新加载刷新数据
     */</span>
    <span class="keyword">private</span> <span class="keyword">void</span> reloadData() {
        removeAllViews();

        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; mAdapter.getCount(); i++) {
            <span class="keyword">final</span> <span class="built_in">int</span> j = i;
            mCheckedTagArray.put(i, <span class="keyword">false</span>);
            <span class="keyword">final</span> View childView = mAdapter.getView(i, <span class="keyword">null</span>, <span class="keyword">this</span>);
            addView(childView, <span class="keyword">new</span> MarginLayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
            <span class="keyword">final</span> <span class="built_in">int</span> finalI = i;
            childView.setOnClickListener(<span class="keyword">new</span> OnClickListener() {
                @Override
                <span class="keyword">public</span> <span class="keyword">void</span> onClick(View v) {
                    <span class="keyword">if</span> (mTagCheckMode == FLOW_TAG_CHECKED_NONE) {
                        <span class="keyword">if</span> (mOnTagClickListener != <span class="keyword">null</span>) {
                            mOnTagClickListener.onItemClick(FlowTagLayout.<span class="keyword">this</span>, childView, j);
                        }
                    } <span class="keyword">else</span> <span class="keyword">if</span> (mTagCheckMode == FLOW_TAG_CHECKED_SINGLE) {
                        <span class="comment">//判断状态</span>
                        <span class="keyword">if</span> (mCheckedTagArray.<span class="built_in">get</span>(j)) {
                            mCheckedTagArray.put(j, <span class="keyword">false</span>);
                            childView.setSelected(<span class="keyword">false</span>);
                            <span class="keyword">if</span> (mOnTagSelectListener != <span class="keyword">null</span>) {
                                mOnTagSelectListener.onItemSelect(FlowTagLayout.<span class="keyword">this</span>, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());
                            }
                            <span class="keyword">return</span>;
                        }

                        <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; mAdapter.getCount(); k++) {
                            mCheckedTagArray.put(k, <span class="keyword">false</span>);
                            getChildAt(k).setSelected(<span class="keyword">false</span>);
                        }
                        mCheckedTagArray.put(j, <span class="keyword">true</span>);
                        childView.setSelected(<span class="keyword">true</span>);

                        <span class="keyword">if</span> (mOnTagSelectListener != <span class="keyword">null</span>) {
                            mOnTagSelectListener.onItemSelect(FlowTagLayout.<span class="keyword">this</span>, Arrays.asList(j));
                        }
                    } <span class="keyword">else</span> <span class="keyword">if</span> (mTagCheckMode == FLOW_TAG_CHECKED_MULTI) {
                        <span class="keyword">if</span> (mCheckedTagArray.<span class="built_in">get</span>(j)) {
                            mCheckedTagArray.put(j, <span class="keyword">false</span>);
                            childView.setSelected(<span class="keyword">false</span>);
                        } <span class="keyword">else</span> {
                            mCheckedTagArray.put(j, <span class="keyword">true</span>);
                            childView.setSelected(<span class="keyword">true</span>);
                        }
                        <span class="comment">//回调</span>
                        <span class="keyword">if</span> (mOnTagSelectListener != <span class="keyword">null</span>) {
                            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();
                            <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; mAdapter.getCount(); k++) {
                                <span class="keyword">if</span> (mCheckedTagArray.<span class="built_in">get</span>(k)) {
                                    list.<span class="built_in">add</span>(k);
                                }
                            }
                            mOnTagSelectListener.onItemSelect(FlowTagLayout.<span class="keyword">this</span>, list);
                        }
                    }
                }
            });
        }
    }
</code></pre><p>这个方法的作用就是重新加载子View，先是移除所有的子View，然后从<em>Adapter</em>中获取子View，addView到FlowTagLayout中，在这个过程中，我们给每个子View添加了点击事件，点击事件里面的逻辑很简单，就是根据<em>FlowTagLayout</em>的三种模式分别处理单击、单选、多选逻辑，三种模式分别为：</p>
<pre><code><span class="comment">/**
     * FlowLayout not support checked
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLOW_TAG_CHECKED_NONE = <span class="number">0</span>;
    <span class="comment">/**
     * FlowLayout support single-select
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLOW_TAG_CHECKED_SINGLE = <span class="number">1</span>;
    <span class="comment">/**
     * FlowLayout support multi-select
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLOW_TAG_CHECKED_MULTI = <span class="number">2</span>;
</code></pre><p>为了使单击、单选、多选事件通知到Activity、Fragment，我们加入了两个监听方法：</p>
<pre><code><span class="comment">/**
 * Created by HanHailong on 15/10/20.
 */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">OnTagClickListener</span> {
    <span class="function"><span class="keyword">void</span> <span class="title">onItemClick</span>(<span class="params">FlowTagLayout parent, View view, <span class="keyword">int</span> position</span>)</span>;
}
</code></pre><p>和</p>
<pre><code><span class="comment">/**
 * Created by HanHailong on 15/10/20.
 */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">OnTagSelectListener</span> {
    <span class="function"><span class="keyword">void</span> <span class="title">onItemSelect</span>(<span class="params">FlowTagLayout parent, List&lt;Integer&gt; selectedList</span>)</span>;
}
</code></pre><p>改写的都写了，我们怎么使用呢？请继续往下看</p>
<h3>用法</h3>

<p>首先，我们先写一个适配器<em>TagAdapter</em>，写法完全和写ListView的适配器一样：</p>
<pre><code><span class="comment">/**
 * Created by HanHailong on 15/10/19.
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TagAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>{

    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;
    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; mDataList;

    <span class="function"><span class="keyword">public</span> <span class="title">TagAdapter</span><span class="params">(Context context)</span> </span>{
        <span class="keyword">this</span>.mContext = context;
        mDataList = <span class="keyword">new</span> ArrayList&lt;&gt;();
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>{
        <span class="function"><span class="keyword">return</span> mDataList.<span class="title">size</span><span class="params">()</span></span>;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">Object <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>{
        <span class="function"><span class="keyword">return</span> mDataList.<span class="title">get</span><span class="params">(position)</span></span>;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>{
        <span class="keyword">return</span> position;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>{

        View view = LayoutInflater.from(mContext).inflate(R.layout.tag_item, <span class="keyword">null</span>);

        TextView textView = (TextView) view.findViewById(R.id.tv_tag);
        T t = mDataList.get(position);

        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> String) {
            textView.setText((String) t);
        }
        <span class="keyword">return</span> view;
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onlyAddAll</span><span class="params">(List&lt;T&gt; datas)</span> </span>{
        mDataList.addAll(datas);
        notifyDataSetChanged();
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">clearAndAddAll</span><span class="params">(List&lt;T&gt; datas)</span> </span>{
        mDataList.clear();
        onlyAddAll(datas);
    }
}
</code></pre><h4>布局tag_item.xml</h4>

<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>&gt;</span>

    <span class="tag">&lt;<span class="title">TextView</span>
        <span class="attribute">android:id</span>=<span class="value">"@+id/tv_tag"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_marginLeft</span>=<span class="value">"10dp"</span>
        <span class="attribute">android:layout_marginTop</span>=<span class="value">"10dp"</span>
        <span class="attribute">android:background</span>=<span class="value">"@drawable/round_rectangle_bg"</span>
        <span class="attribute">android:paddingBottom</span>=<span class="value">"5dp"</span>
        <span class="attribute">android:paddingLeft</span>=<span class="value">"10dp"</span>
        <span class="attribute">android:paddingRight</span>=<span class="value">"10dp"</span>
        <span class="attribute">android:paddingTop</span>=<span class="value">"5dp"</span>
        <span class="attribute">android:text</span>=<span class="value">"TAG标签"</span>
        <span class="attribute">android:textColor</span>=<span class="value">"@color/normal_text_color"</span> /&gt;</span>

<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>再看我们引用<em>FlowTagLayout</em>的主布局代码：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">ScrollView</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">xmlns:app</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span>
    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>
    <span class="attribute">android:fillViewport</span>=<span class="value">"true"</span>
    <span class="attribute">app:layout_behavior</span>=<span class="value">"@string/appbar_scrolling_view_behavior"</span>
    <span class="attribute">tools:context</span>=<span class="value">".MainActivity"</span>
    <span class="attribute">tools:showIn</span>=<span class="value">"@layout/activity_main"</span>&gt;</span>

    <span class="tag">&lt;<span class="title">LinearLayout</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>
        <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
        <span class="attribute">android:paddingBottom</span>=<span class="value">"30dp"</span>&gt;</span>

        <span class="tag">&lt;<span class="title">LinearLayout</span>
            <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
            <span class="attribute">android:orientation</span>=<span class="value">"horizontal"</span>&gt;</span>

            <span class="tag">&lt;<span class="title">TextView</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_margin</span>=<span class="value">"10dp"</span>
                <span class="attribute">android:text</span>=<span class="value">"颜色\n(点击)"</span> /&gt;</span>

            <span class="tag">&lt;<span class="title">com.hhl.library.FlowTagLayout</span>
                <span class="attribute">android:id</span>=<span class="value">"@+id/color_flow_layout"</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>

        <span class="tag">&lt;<span class="title">LinearLayout</span>
            <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
            <span class="attribute">android:layout_marginTop</span>=<span class="value">"10dp"</span>
            <span class="attribute">android:orientation</span>=<span class="value">"horizontal"</span>&gt;</span>

            <span class="tag">&lt;<span class="title">TextView</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_margin</span>=<span class="value">"10dp"</span>
                <span class="attribute">android:text</span>=<span class="value">"尺寸\n(单选)"</span> /&gt;</span>

            <span class="tag">&lt;<span class="title">com.hhl.library.FlowTagLayout</span>
                <span class="attribute">android:id</span>=<span class="value">"@+id/size_flow_layout"</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>

        <span class="tag">&lt;<span class="title">LinearLayout</span>
            <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
            <span class="attribute">android:layout_marginTop</span>=<span class="value">"10dp"</span>
            <span class="attribute">android:orientation</span>=<span class="value">"horizontal"</span>&gt;</span>

            <span class="tag">&lt;<span class="title">TextView</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_margin</span>=<span class="value">"10dp"</span>
                <span class="attribute">android:text</span>=<span class="value">"移动\n(多选)"</span> /&gt;</span>

            <span class="tag">&lt;<span class="title">com.hhl.library.FlowTagLayout</span>
                <span class="attribute">android:id</span>=<span class="value">"@+id/mobile_flow_layout"</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>

    <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>

<span class="tag">&lt;/<span class="title">ScrollView</span>&gt;</span>
</code></pre><p>最后，我们看Activity里面是怎么使用的：</p>
<pre><code><span class="keyword">package</span> com.hhl.flowlayoutdemo;

<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.support.design.widget.FloatingActionButton;
<span class="keyword">import</span> android.support.design.widget.Snackbar;
<span class="keyword">import</span> android.support.v7.app.AppCompatActivity;
<span class="keyword">import</span> android.support.v7.widget.Toolbar;
<span class="keyword">import</span> android.view.Menu;
<span class="keyword">import</span> android.view.MenuItem;
<span class="keyword">import</span> android.view.View;

<span class="keyword">import</span> com.hhl.library.FlowTagLayout;
<span class="keyword">import</span> com.hhl.library.OnTagClickListener;
<span class="keyword">import</span> com.hhl.library.OnTagSelectListener;

<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.List;

<span class="keyword">public</span> class MainActivity extends AppCompatActivity {

    <span class="keyword">private</span> FlowTagLayout mColorFlowTagLayout;
    <span class="keyword">private</span> FlowTagLayout mSizeFlowTagLayout;
    <span class="keyword">private</span> FlowTagLayout mMobileFlowTagLayout;
    <span class="keyword">private</span> TagAdapter&lt;<span class="keyword">String</span>&gt; mSizeTagAdapter;
    <span class="keyword">private</span> TagAdapter&lt;<span class="keyword">String</span>&gt; mColorTagAdapter;
    <span class="keyword">private</span> TagAdapter&lt;<span class="keyword">String</span>&gt; mMobileTagAdapter;

    @Override
    <span class="keyword">protected</span> <span class="keyword">void</span> onCreate(Bundle savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
        fab.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
            @Override
            <span class="keyword">public</span> <span class="keyword">void</span> onClick(View view) {
                Snackbar.make(view, <span class="string">"Replace with your own action"</span>, Snackbar.LENGTH_LONG)
                        .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
            }
        });

        mColorFlowTagLayout = (FlowTagLayout) findViewById(R.id.color_flow_layout);
        mSizeFlowTagLayout = (FlowTagLayout) findViewById(R.id.size_flow_layout);
        mMobileFlowTagLayout = (FlowTagLayout) findViewById(R.id.mobile_flow_layout);

        <span class="comment">//颜色</span>
        mColorTagAdapter = <span class="keyword">new</span> TagAdapter&lt;&gt;(<span class="keyword">this</span>);
        mColorFlowTagLayout.setAdapter(mColorTagAdapter);
        mColorFlowTagLayout.setOnTagClickListener(<span class="keyword">new</span> OnTagClickListener() {
            @Override
            <span class="keyword">public</span> <span class="keyword">void</span> onItemClick(FlowTagLayout parent, View view, <span class="built_in">int</span> position) {
                Snackbar.make(view, <span class="string">"颜色:"</span> + parent.getAdapter().getItem(position), Snackbar.LENGTH_LONG)
                        .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
            }
        });

        <span class="comment">//尺寸</span>
        mSizeTagAdapter = <span class="keyword">new</span> TagAdapter&lt;&gt;(<span class="keyword">this</span>);
        mSizeFlowTagLayout.setTagCheckedMode(FlowTagLayout.FLOW_TAG_CHECKED_SINGLE);
        mSizeFlowTagLayout.setAdapter(mSizeTagAdapter);
        mSizeFlowTagLayout.setOnTagSelectListener(<span class="keyword">new</span> OnTagSelectListener() {
            @Override
            <span class="keyword">public</span> <span class="keyword">void</span> onItemSelect(FlowTagLayout parent, List&lt;Integer&gt; selectedList) {
                <span class="keyword">if</span> (selectedList != <span class="keyword">null</span> &amp;&amp; selectedList.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {
                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();
                    <span class="keyword">for</span> (<span class="built_in">int</span> i : selectedList) {
                        sb.<span class="built_in">append</span>(parent.getAdapter().getItem(i));
                        sb.<span class="built_in">append</span>(<span class="string">":"</span>);
                    }
                    Snackbar.make(parent, <span class="string">"移动研发:"</span> + sb.toString(), Snackbar.LENGTH_LONG)
                            .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
                }<span class="keyword">else</span>{
                    Snackbar.make(parent, <span class="string">"没有选择标签"</span>, Snackbar.LENGTH_LONG)
                            .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
                }
            }
        });

        <span class="comment">//移动研发标签</span>
        mMobileTagAdapter = <span class="keyword">new</span> TagAdapter&lt;&gt;(<span class="keyword">this</span>);
        mMobileFlowTagLayout.setTagCheckedMode(FlowTagLayout.FLOW_TAG_CHECKED_MULTI);
        mMobileFlowTagLayout.setAdapter(mMobileTagAdapter);
        mMobileFlowTagLayout.setOnTagSelectListener(<span class="keyword">new</span> OnTagSelectListener() {
            @Override
            <span class="keyword">public</span> <span class="keyword">void</span> onItemSelect(FlowTagLayout parent, List&lt;Integer&gt; selectedList) {
                <span class="keyword">if</span> (selectedList != <span class="keyword">null</span> &amp;&amp; selectedList.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {
                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();

                    <span class="keyword">for</span> (<span class="built_in">int</span> i : selectedList) {
                        sb.<span class="built_in">append</span>(parent.getAdapter().getItem(i));
                        sb.<span class="built_in">append</span>(<span class="string">":"</span>);
                    }
                    Snackbar.make(parent, <span class="string">"移动研发:"</span> + sb.toString(), Snackbar.LENGTH_LONG)
                            .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
                }<span class="keyword">else</span>{
                    Snackbar.make(parent, <span class="string">"没有选择标签"</span>, Snackbar.LENGTH_LONG)
                            .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
                }
            }
        });

        initColorData();

        initSizeData();

        initMobileData();
    }

    <span class="keyword">private</span> <span class="keyword">void</span> initMobileData() {
        List&lt;<span class="keyword">String</span>&gt; dataSource = <span class="keyword">new</span> ArrayList&lt;&gt;();
        dataSource.<span class="built_in">add</span>(<span class="string">"android"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"安卓"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"SDK源码"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"IOS"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"iPhone"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"游戏"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"fragment"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"viewcontroller"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"cocoachina"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"移动研发工程师"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"移动互联网"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"高薪+期权"</span>);
        mMobileTagAdapter.onlyAddAll(dataSource);
    }

    <span class="keyword">private</span> <span class="keyword">void</span> initColorData() {
        List&lt;<span class="keyword">String</span>&gt; dataSource = <span class="keyword">new</span> ArrayList&lt;&gt;();
        dataSource.<span class="built_in">add</span>(<span class="string">"红色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"黑色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"花边色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"深蓝色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"白色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"玫瑰红色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"紫黑紫兰色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"葡萄红色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"屎黄色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"绿色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"彩虹色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"牡丹色"</span>);
        mColorTagAdapter.onlyAddAll(dataSource);
    }

    <span class="comment">/**
     * 初始化数据
     */</span>
    <span class="keyword">private</span> <span class="keyword">void</span> initSizeData() {
        List&lt;<span class="keyword">String</span>&gt; dataSource = <span class="keyword">new</span> ArrayList&lt;&gt;();
        dataSource.<span class="built_in">add</span>(<span class="string">"28 (2.1尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"29 (2.2尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"30 (2.3尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"31 (2.4尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"32 (2.5尺)........"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"33 (2.6尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"34 (2.7尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"35 (2.8尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"36 (2.9尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"37 (3.0尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"38 (3.1尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"39 (3.2尺)........"</span>);
        mSizeTagAdapter.onlyAddAll(dataSource);
    }

    @Override
    <span class="keyword">public</span> <span class="built_in">boolean</span> onCreateOptionsMenu(Menu menu) {
        <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span>
        getMenuInflater().inflate(R.menu.menu_main, menu);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    @Override
    <span class="keyword">public</span> <span class="built_in">boolean</span> onOptionsItemSelected(MenuItem item) {
        <span class="comment">// Handle action bar item clicks here. The action bar will</span>
        <span class="comment">// automatically handle clicks on the Home/Up button, so long</span>
        <span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span>
        <span class="built_in">int</span> id = item.getItemId();

        <span class="comment">//noinspection SimplifiableIfStatement</span>
        <span class="keyword">if</span> (id == R.id.action_settings) {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }

        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);
    }
}
</code></pre><p>好了，一个简单而实用的流式标签就轻松搞定了！！</p>
<h3>TODO</h3>

<ul>
<li>添加初始化选中标签</li>
<li>添加tag样式支持（颜色、图标等等）</li>
<li>像ListView、GridView一样复用子View</li>
<li>其他…</li>
</ul>
<p>如果你觉得本篇博客对你有用，那么就留个言或者顶一个~~</p>
<p>最后，附上github源码<a href="https://github.com/hanhailong/FlowTag" target="_blank" rel="external">FlowTagLayout</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这一章节，我们继续学习Android自定义控件。这里要自定义的是Android里面的一个常用控件-Android流式Tag布局，这里我们命名为：<a href="https://github.com/hanhailong/FlowTag/blob/master/library/src/main/java/com/hhl/library/FlowTagLayout.java">FlowTagLayout</a>，我们要实现的流式布局，有如下特色：</p>
<ul>
<li>填充数据和ListView、GridView用法一样使用Adapter，更新数据直接通过adapter.notifyDataChanged来更新</li>
<li>支持点击、单选、多选三种模式：FLOW_TAG_CHECKED_NONE、FLOW_TAG_CHECKED_SINGLE、FLOW_TAG_CHECKED_MULTI</li>
</ul>
<h3>正式讲解之前先看下我们实现后的效果图：</h3>

<p> <img src="https://github.com/hanhailong/AndroidStudyResources/raw/master/screenshot/flow_tag.gif?raw=true" alt="image"></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Support Library 23.1 now available]]></title>
    <link href="http://hanhailong.com/2015/10/19/Android-Support-Library-23-1-now-available/"/>
    <id>http://hanhailong.com/2015/10/19/Android-Support-Library-23-1-now-available/</id>
    <published>2015-10-19T02:50:32.000Z</published>
    <updated>2015-10-19T03:14:48.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Support V4</strong> gets a number of important bug fixes as well as a few new features for NestedScrollView and around MediaSessionCompat.</p>
<p><strong>Media Router</strong> has gotten a design overhaul, making connecting and controlling remote devices such as Google Cast enabled devices even easier.</p>
<p><strong>RecyclerView</strong> has a significant <strong>backward incompatible</strong> change to the animation system, offering new flexibility and support for item content animations. You’ll find a SimpleItemAnimator helper class for easing the transition to the new animation system.</p>
<p><strong>AppCompat</strong> adds a new tint aware <em>Seekbar</em>, <em>ImageButton</em>, and <em>ImageView</em> and updating styling to <em>SwitchCompat</em>.</p>
<p><strong>Design</strong> improves TextInputLayout with support for character counting, the new <em>SCROLL_FLAG_SNAP</em> allows <em>AppBarLayout</em> children to snap completely on or off the screen when scrolling completes, and <em>NavigationView</em> now supports custom views for menu items.</p>
<p><strong>Percent</strong> adds support for <em>setting a custom aspect ratio</em> to both <em>PercentFrameLayout</em> and <em>PercentRelativeLayout</em>.</p>
<p><strong>Custom Tabs</strong> increases the customization available with the ability to hide the URL bar when scrolling down and change the custom action button for current custom tab session as well as the ability to receive tab shown and hidden events.</p>
<p><strong>Leanback</strong> updates <em>GuidedStepFragment</em> so it can be placed on top of existing content and adds new search completion type annotations for SearchFragment.﻿</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Support V4</strong> gets a number of important bug fixes as well as a few new features for NestedScrollView and around MediaSessi]]>
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
      <category term="Android咨询" scheme="http://hanhailong.com/tags/Android%E5%92%A8%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-一步一步教你自定义IOS样式的UISwitch]]></title>
    <link href="http://hanhailong.com/2015/10/17/Android-%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89IOS%E6%A0%B7%E5%BC%8F%E7%9A%84UISwitch/"/>
    <id>http://hanhailong.com/2015/10/17/Android-一步一步教你自定义IOS样式的UISwitch/</id>
    <published>2015-10-17T13:08:13.000Z</published>
    <updated>2015-10-18T16:59:54.000Z</updated>
    <content type="html"><![CDATA[<p>在这一章节，我们将开始在Android上做一个IOS风格的UISwitch控件。这篇文章主要涉及如下知识点：</p>
<ol>
<li>Android属性动画Animator</li>
<li>自定义手势GestureDetector</li>
<li>自定义View属性attrs</li>
</ol>
<p>首先，让我们来看一下效果图：</p>
<p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/uiswitch.gif?raw=true" alt="uiswitch"></p>
<a id="more"></a>
<h3>自定义View属性</h3>

<p>接下来，我们要先新建<font color="red">IOSSwitchView</font>类，继承自View类，重写其构造方法，代码如下：</p>
<pre><code><span class="comment">/**
 * 高仿IOS风格的UISwitchView
 * Created by HanHailong on 15/10/15.
 */</span>
public <span class="class"><span class="keyword">class</span> <span class="title">IOSSwitchView</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">View</span> {</span>
    public <span class="type">IOSSwitchView</span>(<span class="type">Context</span> context) {
        <span class="keyword">this</span>(context, <span class="literal">null</span>);
    }

    public <span class="type">IOSSwitchView</span>(<span class="type">Context</span> context, <span class="type">AttributeSet</span> attrs) {
        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);
    }

    public <span class="type">IOSSwitchView</span>(<span class="type">Context</span> context, <span class="type">AttributeSet</span> attrs, int defStyleAttr) {
        <span class="keyword">super</span>(context, attrs, defStyleAttr);
        init(context, attrs);
    }
}
</code></pre><p>然后，自定义我们需要的View属性，代码如下：</p>
<!-- IOSSwitchView -->
<pre><code><span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"IOSSwitchView"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"tintColor"</span> <span class="attribute">format</span>=<span class="value">"reference|color"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"thumbTintColor"</span> <span class="attribute">format</span>=<span class="value">"reference|color"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"strokeWidth"</span> <span class="attribute">format</span>=<span class="value">"reference|dimension"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"isOn"</span> <span class="attribute">format</span>=<span class="value">"reference|boolean"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span>
</code></pre><p>其中，<font color="red">tintColor</font>是Switch控件选中的颜色，，<font color="red">thumbTintColor</font>是里面可拖动开关扳手的颜色，，<font color="red">strokeWidth</font>是开关扳手的外边距宽度，<font color="red">isOn</font>是开关的打开状态，true是打开状态，false是关闭状态。</p>
<p>代码里怎么接收在布局里设置的属性值呢？答案：<font color="red">TypedArray</font>，我们继续看代码：</p>
<pre><code><span class="title">TypedArray</span> a = context.obtainStyledAttributes(attrs, R.styleable.IOSSwitchView);
       <span class="title">mTintColor</span> = a.getColor(R.styleable.IOSSwitchView_tintColor, Color.GREEN);
       <span class="title">mThumbTintColor</span> = a.getColor(R.styleable.IOSSwitchView_thumbTintColor, Color.WHITE);

       <span class="title">int</span> defaultStrokeWidth = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">1</span>.5f, context.getResources()
               .getDisplayMetrics());
       <span class="title">mStrokeWidth</span> = a.getDimensionPixelOffset(R.styleable.IOSSwitchView_strokeWidth, defaultStrokeWidth);
       <span class="title">isOn</span> = a.getBoolean(R.styleable.IOSSwitchView_isOn, <span class="built_in">false</span>);
</code></pre><p>上面的代码都很简单，都是自定义View常规的步骤，接下来我们再看添加动画的代码，看我们的gif效果图，你会发现，中间的开关把手在你手指点击它（此时没松手）的时候，它会有一个拉伸的动画，松手的时候，它会移动到另一侧，所以我们这里需要两个属性动画，一个是：拉伸动画，一个是移动动画。另外，因为我们这里有个背景颜色的变化：在默认关闭的情况下，背景色是灰白色的，打开的情况下是我们设置的tintColor颜色的，这里我们采用的是画了两个圆角矩形实现的，先画的tintColor颜色的圆角矩形，后画的灰白色的圆角矩形，刚开始开关关闭的时候灰白色的圆角矩形完全覆盖在上面，此时它的大小和它下面的矩形大小是一样的，之后在我们打开开关thumb的时候，灰白色的圆角矩形大小变成0，这样我们就看到tintColor颜色的圆角矩形了，这就实现了我们的背景切换。所以，这里又加了一个属性动画：灰白色圆角矩形的放大缩小动画。介绍到这里，我们总算理清了，我们要实现三个动画：一个thumb拉伸动画、一个thumb位移动画、一个灰白色圆角矩形形变动画（放大缩小动画）。这里我们添加初始化动画代码：</p>
<pre><code><span class="comment">//灰白色矩形形变动画</span>
        mInnerContentAnimator = ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="keyword">new</span> Property&lt;IOSSwitchView, Float&gt;(Float.class, <span class="string">"innerbound"</span>) {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">IOSSwitchView <span class="keyword">object</span>, Float <span class="keyword">value</span></span>) </span>{
                <span class="keyword">object</span>.setInnerContentRate(<span class="keyword">value</span>);
            }

            @<span class="function">Override
            <span class="keyword">public</span> Float <span class="title">get</span>(<span class="params">IOSSwitchView <span class="keyword">object</span></span>) </span>{
                <span class="keyword">return</span> <span class="keyword">object</span>.getInnerContentRate();
            }
        }, innerContentRate, <span class="number">1.0</span>f);
        mInnerContentAnimator.setDuration(<span class="number">300</span>);
        mInnerContentAnimator.setInterpolator(<span class="keyword">new</span> DecelerateInterpolator());

        <span class="comment">//thumb拉伸动画</span>
        mThumbExpandAnimator = ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="keyword">new</span> Property&lt;IOSSwitchView, Float&gt;(Float.class, <span class="string">"thumbExpand"</span>) {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">IOSSwitchView <span class="keyword">object</span>, Float <span class="keyword">value</span></span>) </span>{
                <span class="keyword">object</span>.setThumbExpandRate(<span class="keyword">value</span>);
            }

            @<span class="function">Override
            <span class="keyword">public</span> Float <span class="title">get</span>(<span class="params">IOSSwitchView <span class="keyword">object</span></span>) </span>{
                <span class="keyword">return</span> <span class="keyword">object</span>.getThumbExpandRate();
            }
        }, thumbExpandRate, <span class="number">1.0</span>f);
        mThumbExpandAnimator.setDuration(<span class="number">300</span>);
        mThumbExpandAnimator.setInterpolator(<span class="keyword">new</span> DecelerateInterpolator());

        <span class="comment">//thumb位移动画</span>
        mThumbMoveAnimator = ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="keyword">new</span> Property&lt;IOSSwitchView, Float&gt;(Float.class, <span class="string">"thumbMove"</span>) {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">IOSSwitchView <span class="keyword">object</span>, Float <span class="keyword">value</span></span>) </span>{
                <span class="keyword">object</span>.setThumbMoveRate(<span class="keyword">value</span>);
            }

            @<span class="function">Override
            <span class="keyword">public</span> Float <span class="title">get</span>(<span class="params">IOSSwitchView <span class="keyword">object</span></span>) </span>{
                <span class="keyword">return</span> <span class="keyword">object</span>.getThumbMoveRate();
            }
        }, thumbMoveRate, <span class="number">1.0</span>f);
        mThumbMoveAnimator.setDuration(<span class="number">300</span>);
        mThumbMoveAnimator.setInterpolator(<span class="keyword">new</span> DecelerateInterpolator());
</code></pre><p>初始化完三个属性动画后，我们下一步就该初始化滑动手势了，因为我们的<font color="red">IOSSwitchView</font>支持thumb滑动而改变打开关闭状态，所以我们要添加支持滑动手势<font color="red">GestureDetector</font>代码：</p>
<pre><code><span class="comment">//手势</span>
        mGestureDetector = <span class="keyword">new</span> GestureDetector(context, <span class="keyword">new</span> GestureDetector.SimpleOnGestureListener() {
            @<span class="function">Override
            <span class="keyword">public</span> boolean <span class="title">onDown</span><span class="params">(MotionEvent e)</span> </span>{

                <span class="keyword">if</span> (!isEnabled()) <span class="keyword">return</span> <span class="literal">false</span>;

                preIsOn = isOn;

                <span class="comment">//灰白色矩形缩小到0</span>
                mInnerContentAnimator.setFloatValues(innerContentRate, <span class="number">0.0f</span>);
                mInnerContentAnimator.start();

                <span class="comment">//thumb有个拉伸的动作</span>
                mThumbExpandAnimator.setFloatValues(thumbExpandRate, <span class="number">1.0f</span>);
                mThumbExpandAnimator.start();

                <span class="keyword">return</span> <span class="literal">true</span>;
            }

            @<span class="function">Override
            <span class="keyword">public</span> boolean <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span> </span>{
                <span class="comment">//手指抬起执行一系列的动画</span>
                isOn = thumbState;

                <span class="keyword">if</span> (preIsOn == isOn) {<span class="comment">//反转</span>
                    isOn = !isOn;
                    thumbState = !thumbState;
                }

                <span class="comment">//打开状态</span>
                <span class="keyword">if</span> (thumbState) {
                    <span class="comment">//thumb移动到右侧打开区域</span>
                    mThumbMoveAnimator.setFloatValues(thumbMoveRate, <span class="number">1.0F</span>);
                    mThumbMoveAnimator.start();

                    <span class="comment">//灰白色圆角矩形缩小到0</span>
                    mInnerContentAnimator.setFloatValues(innerContentRate, <span class="number">0.0F</span>);
                    mInnerContentAnimator.start();
                } <span class="keyword">else</span> {<span class="comment">//关闭状态</span>
                    <span class="comment">//thumb移动到左侧关闭区域</span>
                    mThumbMoveAnimator.setFloatValues(thumbMoveRate, <span class="number">0.0F</span>);
                    mThumbMoveAnimator.start();

                    <span class="comment">//灰白色圆角矩形放大到覆盖背景大小</span>
                    mInnerContentAnimator.setFloatValues(innerContentRate, <span class="number">1.0F</span>);
                    mInnerContentAnimator.start();
                }
                <span class="comment">//thumb恢复原大小</span>
                mThumbExpandAnimator.setFloatValues(thumbExpandRate, <span class="number">0.0F</span>);
                mThumbExpandAnimator.start();

                <span class="keyword">if</span> (mOnSwitchStateChangeListener != null &amp;&amp; preIsOn != isOn) {
                    mOnSwitchStateChangeListener.onStateSwitched(isOn);
                }

                <span class="keyword">return</span> <span class="literal">true</span>;
            }

            @<span class="function">Override
            <span class="keyword">public</span> boolean <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)</span> </span>{

                <span class="comment">//在打开开关的区域</span>
                <span class="keyword">if</span> (e2.getX() &gt; centerX) {
                    <span class="comment">//并且开关状态是关闭的，就执行打开开关操作</span>
                    <span class="keyword">if</span> (!thumbState) {
                        thumbState = !thumbState;

                        mThumbMoveAnimator.setFloatValues(thumbMoveRate, <span class="number">1.0F</span>);
                        mThumbMoveAnimator.start();

                        mInnerContentAnimator.setFloatValues(innerContentRate, <span class="number">0.0F</span>);
                        mInnerContentAnimator.start();
                    }
                } <span class="keyword">else</span> {<span class="comment">//在关闭区域</span>
                    <span class="comment">//开关处于打开状态</span>
                    <span class="keyword">if</span> (thumbState) {
                        thumbState = !thumbState;
                        <span class="comment">//执行关闭开关动画</span>
                        mThumbMoveAnimator.setFloatValues(thumbMoveRate, <span class="number">0.0F</span>);
                        mThumbMoveAnimator.start();
                    }
                }

                <span class="keyword">return</span> <span class="literal">true</span>;
            }

        });
        <span class="comment">//禁止长按</span>
        mGestureDetector.setIsLongpressEnabled(<span class="literal">false</span>);
</code></pre><p>因为<font color="red">OnGestureListener</font>里面的方法没必要都实现，我们这用的是它的子静态类<font color="red">SimpleOnGestureListener</font>，我们重写了里面的<font color="red">onDown</font>、<font color="red">onSingleTapUp</font>、<font color="red">onScroll</font>方法。</p>
<font color="red">onDown</font>方法的作用就是在按下控件的时候，thumb执行一个拉伸动画，灰白色圆角矩形则执行缩小到0的动画。如下图所示：<br><br><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/uiswitch-expand.gif?raw=true" alt="switch-expand"><br><br><font color="red">onSingleTapUp</font>则是单点抬起手指后执行的操作，这里执行的就是开关互斥动画和互斥逻辑，之前如果是打开的状态，就变成关闭状态，相反则反之。。。<br><br><font color="red">onScroll</font>方法则是手指滑动时的坐标大于中间X时则执行一个选中动画，相反则反之…<br><br>手势识别添加完后，我们为了保证控件有一个好的UI效果展示，一般指控件的宽度和高度保持一个比例，我们重写其<font color="red">onMeasure</font>方法，添加如下代码：<br><br>        @Override<br>        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {<br>            super.onMeasure(widthMeasureSpec, heightMeasureSpec);<br><br>            //测量宽度和高度<br>            width = MeasureSpec.getSize(widthMeasureSpec);<br>            height = MeasureSpec.getSize(heightMeasureSpec);<br><br>            //保持一定的宽高比例<br>            if ((float) height / (float) width &lt; 0.5f) {<br>                height = (int) (width <em> 0.5);<br><br>                heightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.getMode(heightMeasureSpec));<br>                widthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.getMode(widthMeasureSpec));<br>                super.setMeasuredDimension(widthMeasureSpec, heightMeasureSpec);<br>            }<br><br>            centerX = width </em> 0.5f;<br>            centerY = height <em> 0.5f;<br>            cornerRadius = centerY;<br><br>            innerContentRectF.left = mStrokeWidth;<br>            innerContentRectF.top = mStrokeWidth;<br>            innerContentRectF.right = width - mStrokeWidth;<br>            innerContentRectF.bottom = height - mStrokeWidth;<br><br>            intrinsicInnerWidth = innerContentRectF.width();<br>            intrinsicInnerHeight = innerContentRectF.height();<br><br>            thumbRectF.left = mStrokeWidth;<br>            thumbRectF.top = mStrokeWidth;<br>            thumbRectF.right = width - mStrokeWidth;<br>            thumbRectF.bottom = height - mStrokeWidth;<br><br>            intrinsicThumbWidth = thumbRectF.height();<br><br>            //thumb最大拉伸宽度<br>            thumbMaxExpandWidth = width </em> 0.7f;<br><br>            if (thumbMaxExpandWidth &gt; intrinsicThumbWidth <em> 1.25f) {<br>                thumbMaxExpandWidth = intrinsicThumbWidth </em> 1.25f;<br>            }<br>        }<br><br><br>测量完后，我们就开始执行最后一步也是最重要的一步：将控件画到画布canvas上，我们重写<font color="red">onDraw</font>方法：<br><br><br>        @Override<br>        protected void onDraw(Canvas canvas) {<br>        super.onDraw(canvas);<br><br>        float w = intrinsicInnerWidth <em> 0.5f </em> innerContentRate;<br>        float h = intrinsicInnerHeight <em> 0.5f </em> innerContentRate;<br><br>        this.innerContentRectF.left = centerX - w;<br>        this.innerContentRectF.top = centerY - h;<br>        this.innerContentRectF.right = centerX + w;<br>        this.innerContentRectF.bottom = centerY + h;<br><br>        //thumb拉伸宽度变化，其变化值从1-&gt;1.7之间<br>        w = intrinsicThumbWidth + (thumbMaxExpandWidth - intrinsicThumbWidth) <em> thumbExpandRate;<br><br>        boolean left = thumbRectF.left + thumbRectF.width() </em> 0.5f &lt; centerX;<br>        if (left) {<br>            thumbRectF.left = thumbRectF.right - w;<br>        } else {<br>            thumbRectF.right = thumbRectF.left + w;<br>        }<br><br>        float kw = thumbRectF.width();<br>        w = (float) (width - kw - (mStrokeWidth <em> 2)) </em> thumbMoveRate;<br><br>        thumbRectF.left = mStrokeWidth + w;<br>        thumbRectF.right = thumbRectF.left + kw;<br><br>        //颜色值过渡变化，从深灰白色变化到tintColor色<br>        this.colorStep = transformRGBColor(thumbMoveRate, backgroundColor, mTintColor);<br><br>        //画TintColor颜色的圆角矩形<br>        mPaint.setColor(colorStep);<br>        mPaint.setStyle(Paint.Style.FILL_AND_STROKE);<br>        drawRoundRect(0, 0, width, height, cornerRadius, canvas, mPaint);<br><br>        mPaint.setColor(foregroundColor);<br>        //画灰白色圆角矩形<br>        canvas.drawRoundRect(innerContentRectF, innerContentRectF.height() <em> 0.5f, innerContentRectF.height() </em> 0.5f, mPaint);<br><br>        //画thumb<br>        mPaint.setColor(mThumbTintColor);<br>        canvas.drawRoundRect(thumbRectF, cornerRadius, cornerRadius, mPaint);<br><br>        mPaint.setColor(0xFFCCCCCC);<br>        mPaint.setStyle(Paint.Style.STROKE);<br>        mPaint.setStrokeWidth(1);<br>        canvas.drawRoundRect(thumbRectF, cornerRadius, cornerRadius, mPaint);<br>        }<br><br><br><font color="red">onDraw</font>方法执行了四步绘制：四次绘制圆角矩形，第一次绘制背景tintColor颜色的圆角矩形，第二次绘制灰白色覆盖在上面的圆角矩形，第三次绘制thumb，第四次绘制一个空心的圆角矩形，这个是为了加深thumb和周围的颜色区分。<br><br>其中，里面有个方法<font color="red"> transformRGBColor </font>

<pre><code><span class="comment">/**
     * RGB颜色过渡变化
     *
     * @param progress
     * @param fromColor
     * @param toColor
     * @return
     */</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">transformRGBColor</span><span class="params">(<span class="keyword">float</span> progress, <span class="keyword">int</span> fromColor, <span class="keyword">int</span> toColor)</span> </span>{
        <span class="keyword">int</span> fr = (fromColor &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;
        <span class="keyword">int</span> fg = (fromColor &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;
        <span class="keyword">int</span> fb = fromColor &amp; <span class="number">0xFF</span>;

        <span class="keyword">int</span> tr = (toColor &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;
        <span class="keyword">int</span> tg = (toColor &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;
        <span class="keyword">int</span> tb = toColor &amp; <span class="number">0xFF</span>;

        <span class="keyword">int</span> rGap = (<span class="keyword">int</span>) ((<span class="keyword">float</span>) (tr - fr) * progress);
        <span class="keyword">int</span> gGap = (<span class="keyword">int</span>) ((<span class="keyword">float</span>) (tg - fg) * progress);
        <span class="keyword">int</span> bGap = (<span class="keyword">int</span>) ((<span class="keyword">float</span>) (tb - fb) * progress);

        <span class="keyword">return</span> <span class="number">0xFF000000</span> | ((fr + rGap) &lt;&lt; <span class="number">16</span>) | ((fg + gGap) &lt;&lt; <span class="number">8</span>) | (fb + bGap);
    }
</code></pre><p>为了将状态变化值传递给页面，一般指的是Activity、Fragment、View，我们需要定义一个接口：</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> SwitchView状态切换
 <span class="keyword">*</span>/
public static interface OnSwitchStateChangeListener {
    /<span class="keyword">*</span><span class="keyword">*</span>
     <span class="keyword">*</span> 是否选中
     <span class="keyword">*</span>
     <span class="keyword">*</span> <span class="comment">@param isOn</span>
     <span class="keyword">*</span>/
    public void onStateSwitched(boolean isOn);
}
</code></pre><p>里面的一些细节这里就不讲了，最后怎么使用呢？分两步：</p>
<p>第一步：布局xml</p>
<pre><code>&lt;<span class="tag">com</span><span class="class">.hhl</span><span class="class">.library</span><span class="class">.IOSSwitchView</span>
            <span class="rule"><span class="attribute">android</span>:<span class="value">id=<span class="string">"@+id/switch_view"</span>
            android:layout_width=<span class="string">"55dp"</span>
            android:layout_height=<span class="string">"35dp"</span>
            android:layout_gravity=<span class="string">"center"</span>
            app:thumbTintColor=<span class="string">"#fff"</span>
            app:tintColor=<span class="string">"#00ff00"</span> /&gt;</span></span>
</code></pre><p>第二步：代码</p>
<pre><code>mSwitchView = (IOSSwitchView) findViewById(R.id.switch_view);
        mStatusTv = (TextView) findViewById(R.id.tv_status);

        mSwitchView.setOnSwitchStateChangeListener(<span class="keyword">new</span> IOSSwitchView.OnSwitchStateChangeListener() {
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onStateSwitched</span><span class="params">(<span class="keyword">boolean</span> isOn)</span> </span>{
                <span class="keyword">if</span> (isOn) {
                    mStatusTv.setText(<span class="string">"状态：开"</span>);
                } <span class="keyword">else</span> {
                    mStatusTv.setText(<span class="string">"状态：关"</span>);
                }
            }
        });
</code></pre><p>最后，附上源码：<a href="https://github.com/hanhailong/IOSSwitchView" target="_blank" rel="external">github-IOSSwitchView</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这一章节，我们将开始在Android上做一个IOS风格的UISwitch控件。这篇文章主要涉及如下知识点：</p>
<ol>
<li>Android属性动画Animator</li>
<li>自定义手势GestureDetector</li>
<li>自定义View属性attrs</li>
</ol>
<p>首先，让我们来看一下效果图：</p>
<p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/uiswitch.gif?raw=true" alt="uiswitch"></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RxBus—通过RxJava来替换EventBus]]></title>
    <link href="http://hanhailong.com/2015/10/09/RxBus%E2%80%94%E9%80%9A%E8%BF%87RxJava%E6%9D%A5%E6%9B%BF%E6%8D%A2EventBus/"/>
    <id>http://hanhailong.com/2015/10/09/RxBus—通过RxJava来替换EventBus/</id>
    <published>2015-10-09T15:25:07.000Z</published>
    <updated>2015-10-10T02:18:49.000Z</updated>
    <content type="html"><![CDATA[<h2>前言</h2>

<p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a>有多火？看看Github上star数量就知道了，那什么是RxJava呢？</p>
<p>RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。</p>
<p>换一种说法，RxJava 是一个响应式编程框架，采用观察者设计模式。所以自然少不了 Observable 和 Subscriber 这两个东东了。</p>
<a id="more"></a>
<p>而针对Android，则有一个基于RxJava的<a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">RxAndroid</a></p>
<p>甚至Jake Wharton大神还基于RxJava写了一个针对Android平台的binding api<a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="external">RxBinding</a></p>
<p>而这篇博文讲的就是基于RxJava实现的一个Event Bus-&gt;<a href="https://github.com/hanhailong/AndroidStudyResources/blob/master/javacode/RxBus.java" target="_blank" rel="external">RxBus</a></p>
<p>懂得Android的开发者都知道，目前Android上最火的两个Event Bus库是<a href="http://square.github.io/otto/" target="_blank" rel="external">Otto</a>和Green Robot’s<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a>，两个事件总线库写的都非常不错。不过这里不是讲事件总线，而是讲如何通过RxJava来实现事件总线的效果。</p>
<p>总体来说，代码非常的简单，十几行代码就搞定了！</p>
<p>首先，我们来定义一个RxBus单例类：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> rx.Observable;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> rx.subjects.PublishSubject;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> rx.subjects.SerializedSubject;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> rx.subjects.Subject;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by HanHailong on 15/10/9.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxBus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> volatile RxBus mDefaultInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RxBus() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RxBus getDefault() &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDefaultInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            synchronized (RxBus.<span class="keyword">class</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDefaultInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mDefaultInstance = <span class="keyword">new</span> RxBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mDefaultInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject&lt;Object, Object&gt; _bus = <span class="keyword">new</span> SerializedSubject&lt;&gt;(PublishSubject.create());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> send(Object o) &#123;</span><br><span class="line">        _bus.onNext(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Observable&lt;Object&gt; toObservable() &#123;</span><br><span class="line">        <span class="keyword">return</span> _bus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码非常的简单，使用呢？则更简单了，一般来讲，事件总线，包括一个发送事件和多个接收事件。</p>
<p>先看发送事件的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">RxBus</span><span class="class">.getDefault</span>()<span class="class">.send</span>(<span class="tag">new</span> <span class="tag">TapEvent</span>());</span><br></pre></td></tr></table></figure>
<p>而在你想接收事件的地方，只需要加上下面代码就可以了：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RxBus.getDefault().toObservable().subscribe(<span class="keyword">new</span> Action1&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (event <span class="keyword">instanceof</span> TapEvent) &#123;</span><br><span class="line">                   <span class="comment">//do something</span></span><br><span class="line">                &#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(event <span class="keyword">instanceof</span> otherEvent)</span></span>&#123;</span><br><span class="line">                		<span class="comment">//do otherthing</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>这样，一个简单的Event Bus就实现了！如果你的项目已经开始使用RxJava，建议可以把<a href="http://square.github.io/otto/" target="_blank" rel="external">Otto</a>和Green Robot’s<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a>去掉了，直接使用<a href="https://github.com/hanhailong/AndroidStudyResources/blob/master/javacode/RxBus.java" target="_blank" rel="external">RxBus</a>！！</p>
<p>当然，不要忘了在build.gradle引入RxJava和RxAndroid：</p>
<pre><code><span class="keyword">compile</span> <span class="string">'io.reactivex:rxandroid:1.0.1'</span>
<span class="keyword">compile</span> <span class="string">'io.reactivex:rxjava:1.0.14'</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2>前言</h2>

<p><a href="https://github.com/ReactiveX/RxJava">RxJava</a>有多火？看看Github上star数量就知道了，那什么是RxJava呢？</p>
<p>RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。</p>
<p>换一种说法，RxJava 是一个响应式编程框架，采用观察者设计模式。所以自然少不了 Observable 和 Subscriber 这两个东东了。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
      <category term="RxAndroid" scheme="http://hanhailong.com/tags/RxAndroid/"/>
    
      <category term="RxJava" scheme="http://hanhailong.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo—添加百度统计代码]]></title>
    <link href="http://hanhailong.com/2015/10/08/Hexo%E2%80%94%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81/"/>
    <id>http://hanhailong.com/2015/10/08/Hexo—添加百度统计代码/</id>
    <published>2015-10-08T15:31:31.000Z</published>
    <updated>2015-10-08T16:05:53.000Z</updated>
    <content type="html"><![CDATA[<p>本博客采用的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">Yilia</a>主题，这里就以Yilia讲解为例，首先你要去<a href="http://tongji.baidu.com/" target="_blank" rel="external">百度统计</a>注册账号，并获取到相关的百度统计代码：</p>
<ol>
<li><p>编辑文件<font color="blue"><strong>themes/yilia/_config.yml</strong></font>，添加一行配置代码：</p>
<pre><code><span class="string">baidu_tongji:</span> <span class="literal">true</span>
</code></pre></li>
<li><p>新建文件<font color="blue"><strong>themes/yilia/layout/_partial/baidu_tongji.ejs</strong></font>，内容如下：</p>
<pre><code><span class="xml"></span>&lt;%<span class="ruby"> <span class="keyword">if</span> (theme.baidu_tongji) { </span>%&gt;<span class="xml">
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="undefined">
#申请的百度统计代码
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</span>&lt;%<span class="ruby"> } </span>%&gt;<span class="xml"></span>
</code></pre></li>
<li><p>编辑<font color="blue">themes/yilia/layout/_partial/head.ejs</font>文件，在<font color="red">&lt;/head&gt;</font>之前添加代码：</p>
<pre><code>&lt;<span class="preprocessor">%</span>- partial<span class="comment">("baidu_tongji")</span> <span class="preprocessor">%</span>&gt;
</code></pre></li>
<li><p>重新部署发布，搞定睡觉！！！</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本博客采用的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">Yilia</a>主题，这里就以Yilia讲解为例，首先你要去<a href="http:/]]>
    </summary>
    
      <category term="Hexo主题" scheme="http://hanhailong.com/tags/Hexo%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo—正确添加RSS订阅]]></title>
    <link href="http://hanhailong.com/2015/10/08/Hexo%E2%80%94%E6%AD%A3%E7%A1%AE%E6%B7%BB%E5%8A%A0RSS%E8%AE%A2%E9%98%85/"/>
    <id>http://hanhailong.com/2015/10/08/Hexo—正确添加RSS订阅/</id>
    <published>2015-10-08T13:07:13.000Z</published>
    <updated>2015-10-08T13:51:57.000Z</updated>
    <content type="html"><![CDATA[<p>看到别人的博客都有RSS订阅功能，就想着给自己的博客也添加RSS订阅功能。</p>
<p>看网上的教程，写的不是很详细，都是很简单的一句话。而我按照网上的教程愣是没整出来。真是验证了一句古话：<font color="red">尽信书不如无书</font></p>
<p>最后，终于让我整出来了，特此把完整的过程记录一下：</p>
<a id="more"></a>
<p>先看下整出来的效果图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rss.png?raw=true" alt="RSS效果图"></p>
<p>首先，先安装<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="external">hexo-generator-feed</a></p>
<pre><code>$ npm <span class="operator"><span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span>
</code></pre><p>安装完后，会在node_modules目录下生成hexo-generator-feed目录，如图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rss-feed.png?raw=true" alt="image"></p>
<p>安装完hexo-generator-feed后，将其配置到根目录的<font color="red">_config.yml</font></p>
<pre><code><span class="preprocessor"># Extensions</span>
<span class="preprocessor">## Plugins: http://hexo.io/plugins/</span>
<span class="preprocessor">#RSS订阅</span>
<span class="label">plugin:</span>
- hexo-generator-feed
<span class="preprocessor">#Feed Atom</span>
<span class="label">feed:</span>
<span class="label">type:</span> atom
<span class="label">path:</span> atom.xml
<span class="label">limit:</span> <span class="number">20</span>
</code></pre><p>其中，feed是可选项，可配可不配！</p>
<p>最后，在你当前主题下的<font color="blue">_config.yml</font>下，添加RSS订阅链接即可，这里我用的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">Yilia</a>主题，subnav下添加rss：</p>
<pre><code><span class="preprocessor"># SubNav</span>
<span class="label">subnav:</span>
<span class="label">rss:</span> <span class="string">"/atom.xml"</span>
</code></pre><p>添加之后，运行<font color="red">hexo g</font>后，就会在页面上生成RSS图标，如下图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rss-result.png?raw=true" alt="image"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>看到别人的博客都有RSS订阅功能，就想着给自己的博客也添加RSS订阅功能。</p>
<p>看网上的教程，写的不是很详细，都是很简单的一句话。而我按照网上的教程愣是没整出来。真是验证了一句古话：<font color='red'>尽信书不如无书</font></p>
<p>最后，终于让我整出来了，特此把完整的过程记录一下：</p>]]>
    
    </summary>
    
      <category term="Hexo主题" scheme="http://hanhailong.com/tags/Hexo%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不错的学习技术博客之三—泡在网上的日子]]></title>
    <link href="http://hanhailong.com/2015/10/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E4%B9%8B%E4%B8%89%E2%80%94%E6%B3%A1%E5%9C%A8%E7%BD%91%E4%B8%8A%E7%9A%84%E6%97%A5%E5%AD%90/"/>
    <id>http://hanhailong.com/2015/10/08/不错的学习技术博客之三—泡在网上的日子/</id>
    <published>2015-10-08T08:19:33.000Z</published>
    <updated>2015-10-08T08:27:38.000Z</updated>
    <content type="html"><![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第三篇，<a href="http://www.jcodecraeer.com/" target="_blank" rel="external">泡在网上的日子</a>上面的技术博客质量都非常高，文章内容非常广泛，不仅包括Android和IOS，还包括Html5/css3、JS、java、php等，甚至还包括设计模式和算法。</p>
<p>还有就是包括代码，里面的代码大部分都托管在github上面，这里做了比较详细的系统分类，总体做的非常不错，我经常去上面浏览学习！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第三篇，<a href="http://www.jcodecraeer.com/" tar]]>
    </summary>
    
      <category term="技术博客" scheme="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
