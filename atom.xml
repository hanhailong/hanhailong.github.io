<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[韩海龙的博客]]></title>
  <subtitle><![CDATA[学习总结 思考感悟 知识管理 代码分享]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://hanhailong.com/"/>
  <updated>2015-12-27T12:02:24.000Z</updated>
  <id>http://hanhailong.com/</id>
  
  <author>
    <name><![CDATA[韩海龙]]></name>
    <email><![CDATA[hanhailong.cool@163.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android 性能优化之--使用线程池处理异步任务]]></title>
    <link href="http://hanhailong.com/2015/12/27/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    <id>http://hanhailong.com/2015/12/27/Android-性能优化之-使用线程池处理异步任务/</id>
    <published>2015-12-27T08:41:23.000Z</published>
    <updated>2015-12-27T12:02:24.000Z</updated>
    <content type="html"><![CDATA[<p>说到线程，我想大家都不陌生，因为在开发时候或多或少都会用到线程，而通常创建线程有两种方式：</p>
<ol>
<li>继承自Thread类</li>
<li>实现Runnable接口</li>
</ol>
<p>虽说这两种方式都可以创建出一个线程，不过它们之间还是有一点区别的，主要区别在于在多线程访问同一资源的情况下，用Runnable接口创建的线程可以处理同一资源，而用Thread类创建的线程则各自独立处理，各自拥有自己的资源。</p>
<p>所以，在Java中大多数多线程程序都是通过实现Runnable来完成的，而对于Android来说也不例外，当涉及到需要开启线程去完成某件事时，我们都会这样写：</p>
<pre><code><span class="tag">new</span> <span class="tag">Thread</span>(new <span class="function">Runnable</span>() {
    <span class="variable">@Override</span>
    public void <span class="function">run</span>() {
        <span class="comment">//do sth .</span>
    }
})<span class="class">.start</span>();
</code></pre><p>这段代码创建了一个线程并执行，它在任务结束后GC会自动回收该线程，一切看起来如此美妙，是的，它在线程并发不多的程序中确实不错，而假如这个程序有很多地方需要开启大量线程来处理任务，那么如果还是用上述的方式去创建线程处理的话，那么将导致系统的性能表现的非常糟糕，更别说在内存有限的移动设备上，主要的影响如下：</p>
<ol>
<li>线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失</li>
<li>大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM</li>
<li>大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿</li>
</ol>
<p>而针对上述所描述的问题，解决的办法归根到底就是：重用已有的线程，从而减少线程的创建。<br>所以这就涉及到线程池（ExecutorService）的概念了，线程池的基本作用就是进行线程的复用，下面将具体介绍线程池的使用</p>
<a id="more"></a>
<h2>ExecutorService</h2><br>通过上述分析，我们知道了通过new Thread().start()方式创建线程去处理任务的弊端，而为了解决这些问题，Java为我们提供了ExecutorService线程池来优化和管理线程的使用<br><br><h4>使用线程池管理线程的优点</h4><br><br>1. 线程的创建和销毁由线程池维护，一个线程在完成任务后并不会立即销毁，而是由后续的任务复用这个线程，从而减少线程的创建和销毁，节约系统的开销<br>2. 线程池旨在线程的复用，这就可以节约我们用以往的方式创建线程和销毁所消耗的时间，减少线程频繁调度的开销，从而节约系统资源，提高系统吞吐量<br>3. 在执行大量异步任务时提高了性能<br>4. Java内置的一套ExecutorService线程池相关的api，可以更方便的控制线程的最大并发数、线程的定时任务、单线程的顺序执行等<br><br><h2>ExecutorService简介</h2><br>通常来说我们说到线程池第一时间想到的就是它：<em>ExecutorService</em>，它是一个接口，其实如果要从真正意义上来说，它可以叫做线程池的服务，因为它提供了众多接口api来控制线程池中的线程，而真正意义上的线程池就是：<em>ThreadPoolExecutor</em>，它实现了<em>ExecutorService</em>接口，并封装了一系列的api使得它具有线程池的特性，其中包括工作队列、核心线程数、最大线程数等。<br><br><h4>线程池：ThreadPoolExecutor</h4><br>既然线程池就是ThreadPoolExecutor，所以我们要创建一个线程池只需要new ThreadPoolExecutor(…);就可以创建一个线程池，而如果这样创建线程池的话，我们需要配置一堆东西，非常麻烦，我们可以看一下它的构造方法就知道了：<br><br>    public ThreadPoolExecutor(int corePoolSize,<br>                                  int maximumPoolSize,<br>                                  long keepAliveTime,<br>                                  TimeUnit unit,<br>                                  BlockingQueue workQueue,<br>                                  ThreadFactory threadFactory,<br>                                  RejectedExecutionHandler handler) {…}<br><br><br>所以，官方也不推荐使用这种方法来创建线程池，而是推荐使用Executors的工厂方法来创建线程池，Executors类是官方提供的一个工厂类，它里面封装好了众多功能不一样的线程池，从而使得我们创建线程池非常的简便，主要提供了如下五种功能不一样的线程池：<br><br>1. <strong>newFixedThreadPool() ：</strong><br><br>    作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。<br>    栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按FIFO方式处理任务队列中的任务。<br>2. <strong>newCachedThreadPool() ：</strong><br><br>    作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。<br>    栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。<br><br>3. <strong>newSingleThreadExecutor() ：</strong><br><br>    作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。<br><br>4. <strong>newScheduledThreadPool() ：</strong><br><br>    作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。<br><br>5. <strong>newSingleThreadScheduledExecutor() ：</strong><br><br>    作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为1，而上面的可以指定线程池的大小。<br><br>好了，写了一堆来介绍这五种线程池的作用，接下来就是获取这五种线程池，通过Executors的工厂方法来获取：<br><br>        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);<br>        ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();<br>        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();<br>        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);<br>        ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor();<br><br>我们可以看到通过Executors的工厂方法来创建线程池极其简便，其实它的内部还是通过new ThreadPoolExecutor(…)的方式创建线程池的，我们看一下这些工厂方法的内部实现：<br><br>        public static ExecutorService newFixedThreadPool(int nThreads) {<br>            return new ThreadPoolExecutor(nThreads, nThreads,<br>                                          0L, TimeUnit.MILLISECONDS,<br>                                          new LinkedBlockingQueue());<br>        }<br>        public static ExecutorService newSingleThreadExecutor() {<br>            return new FinalizableDelegatedExecutorService<br>                (new ThreadPoolExecutor(1, 1,<br>                                        0L, TimeUnit.MILLISECONDS,<br>                                        new LinkedBlockingQueue()));<br>        }<br>        public static ExecutorService newCachedThreadPool() {<br>            return new ThreadPoolExecutor(0, Integer.MAX_VALUE,<br>                                          60L, TimeUnit.SECONDS,<br>                                          new SynchronousQueue());<br>        }<br><br>我们可以清楚的看到这些方法的内部实现都是通过创建一个ThreadPoolExecutor对象来创建的，正所谓万变不离其宗，所以我们要了解线程池还是得了解ThreadPoolExecutor这个线程池类，其中由于和定时任务相关的线程池比较特殊（newScheduledThreadPool()、newSingleThreadScheduledExecutor()），它们创建的线程池内部实现是由ScheduledThreadPoolExecutor这个类实现的，而ScheduledThreadPoolExecutor是继承于ThreadPoolExecutor扩展而成的，所以本质还是一样的，只不过多封装了一些定时任务相关的api，所以我们主要就是要了解ThreadPoolExecutor，从构造方法开始：<br><br>    public ThreadPoolExecutor(int corePoolSize,<br>                                  int maximumPoolSize,<br>                                  long keepAliveTime,<br>                                  TimeUnit unit,<br>                                  BlockingQueue workQueue,<br>                                  ThreadFactory threadFactory,<br>                                  RejectedExecutionHandler handler) {//…}<br><br>我们可以看到它构造方法的参数比较多，有七个，下面一一来说明这些参数的作用：<br><br><em> <strong>corePoolSize</strong>：线程池中的核心线程数量
</em> <strong>maximumPoolSize</strong>: 线程池中的最大线程数量<br><em> <strong>keepAliveTime</strong>: 这个就是上面说到的“保持活动时间“，上面只是大概说明了一下它的作用，不过它起作用必须在一个前提下，就是当线程池中的线程数量超过了corePoolSize时，它表示多余的空闲线程的存活时间，即：多余的空闲线程在超过keepAliveTime时间内没有任务的话则被销毁。而这个主要应用在缓存线程池中
</em> <strong>unit</strong>：它是一个枚举类型，表示keepAliveTime的单位，常用的如：TimeUnit.SECONDS（秒）、TimeUnit.MILLISECONDS（毫秒）<br><em> <strong>workQueue</strong>: 任务队列，主要用来存储已经提交但未被执行的任务，不同的线程池采用的排队策略不一样，稍后再讲
</em> <strong>threadFactory</strong>:线程工厂，用来创建线程池中的线程，通常用默认的即可<br><em> <strong>handler</strong>: 通常叫做拒绝策略，1、在线程池已经关闭的情况下 2、任务太多导致最大线程数和任务队列已经饱和，无法再接收新的任务 。在上面两种情况下，只要满足其中一种时，在使用execute()来提交新的任务时将会拒绝，而默认的拒绝策略是抛一个RejectedExecutionException异常<br><br>上面的参数理解起来都比较简单，不过workQueue这个任务队列却要再次说明一下，它是一个BlockingQueue对象，而泛型则限定它是用来存放Runnable对象的，刚刚上面讲了，不同的线程池它的任务队列实现肯定是不一样的，所以，保证不同线程池有着不同的功能的核心就是这个workQueue的实现了，细心的会发现在刚刚的用来创建线程池的工厂方法中，针对不同的线程池传入的workQueue也不一样，下面我总结一下这五种线程池分别用的是什么

</em>BlockingQueue*:<br><br>1. newFixedThreadPool()—&gt;LinkedBlockingQueue<br>2. newSingleThreadExecutor()—&gt;LinkedBlockingQueue<br>3. newCachedThreadPool()—&gt;SynchronousQueue<br>4. newScheduledThreadPool()—&gt;DelayedWorkQueue<br>5. newSingleThreadScheduledExecutor()—&gt;DelayedWorkQueue<br><br>这些队列分别表示：<br><br>    LinkedBlockingQueue：无界的队列<br>    SynchronousQueue：直接提交的队列<br>    DelayedWorkQueue：等待队列<br><br>当然实现了BlockingQueue接口的队列还有：ArrayBlockingQueue（有界的队列）、PriorityBlockingQueue（优先级队列）。这些队列的详细作用就不多介绍了。<br><br><h2>线程池ThreadPoolExecutor的使用</h2>

<p>使用线程池，其中涉及到一个极其重要的方法，即：</p>
<pre><code><span class="function"><span class="title">execute</span><span class="params">(Runnable command)</span></span>
</code></pre><p>该方法意为执行给定的任务，该任务处理可能在新的线程、已入池的线程或者正调用的线程，这由ThreadPoolExecutor的实现决定。</p>
<h4>newFixedThreadPool</h4>

<p>创建一个固定线程数量的线程池，示例为：</p>
<pre><code>ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="number">10</span>; i++) {
        final <span class="keyword">int</span> index = i;
        fixedThreadPool.execute(<span class="keyword">new</span> Runnable() {
             @<span class="function">Override
             <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                 String threadName = Thread.currentThread().getName();
                 Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span>+threadName+<span class="string">",正在执行第"</span> + index + <span class="string">"个任务"</span>);
                 <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">2000</span>);
                 } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                 }
             }
         });
     }
</code></pre><p>上述代码，我们创建了一个线程数为3的固定线程数量的线程池，同理该线程池支持的线程最大并发数也是3，而我模拟了10个任务让它处理，执行的情况则是首先执行前三个任务，后面7个则依次进入任务队列进行等待，执行完前三个任务后，再通过FIFO的方式从任务队列中取任务执行，直到最后任务都执行完毕。</p>
<p>为了体现出线程的复用，我特地在Log中加上了当前线程的名称，效果为：</p>
<p><img src="http://img.blog.csdn.net/20151116182357008" alt=""></p>
<h4>newSingleThreadExecutor</h4>

<p>创建一个只有一个线程的线程池，每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待线程处理完再依次处理任务队列中的任务，示例为：</p>
<pre><code>ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="number">10</span>; i++) {
            final <span class="keyword">int</span> index = i;
            singleThreadPool.execute(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    String threadName = Thread.currentThread().getName();
                    Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span>+threadName+<span class="string">",正在执行第"</span> + index + <span class="string">"个任务"</span>);
                    <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">1000</span>);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
</code></pre><p>代码还是差不多，只不过改了线程池的实现方式，效果我想大家都知道，即依次一个一个的处理任务，而且都是复用一个线程，效果为：</p>
<p><img src="http://img.blog.csdn.net/20151116182627850" alt=""></p>
<p>其实我们通过newSingleThreadExecutor()和newFixedThreadPool()的方法发现，创建一个singleThreadExecutorPool实际上就是创建一个核心线程数和最大线程数都为1的fixedThreadPool。</p>
<h4>newCachedThreadPool</h4>

<p>创建一个可以根据实际情况调整线程池中线程的数量的线程池，示例为：</p>
<pre><code>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="number">10</span>; i++) {
            final <span class="keyword">int</span> index = i;
            <span class="keyword">try</span> {
                Thread.sleep(<span class="number">1000</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
            cachedThreadPool.execute(<span class="keyword">new</span> Runnable() {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    String threadName = Thread.currentThread().getName();
                    Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">",正在执行第"</span> + index + <span class="string">"个任务"</span>);
                    <span class="keyword">try</span> {
                        <span class="keyword">long</span> time = index * <span class="number">500</span>;
                        Thread.sleep(time);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
</code></pre><p>为了体现该线程池可以自动根据实现情况进行线程的重用，而不是一味的创建新的线程去处理任务，我设置了每隔1s去提交一个新任务，这个新任务执行的时间也是动态变化的，所以，效果为：</p>
<p><img src="http://img.blog.csdn.net/20151116184528454" alt=""></p>
<h4>newScheduledThreadPool</h4><br>创建一个可以定时或者周期性执行任务的线程池，示例为：<br><br>    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3);<br>            //延迟2秒后执行该任务<br>            scheduledThreadPool.schedule(new Runnable() {<br>                @Override<br>                public void run() {<br><br>                }<br>            }, 2, TimeUnit.SECONDS);<br>            //延迟1秒后，每隔2秒执行一次该任务<br>            scheduledThreadPool.scheduleAtFixedRate(new Runnable() {<br>                @Override<br>                public void run() {<br><br>                }<br>            }, 1, 2, TimeUnit.SECONDS);<br><br><h4> newSingleThreadScheduledExecutor </h4>

<p>创建一个可以定时或者周期性执行任务的线程池，该线程池的线程数为1，代码示例为：</p>
<pre><code>ScheduledExecutorService singleThreadScheduledPool = Executors.newSingleThreadScheduledExecutor();
        <span class="comment">//延迟1秒后，每隔2秒执行一次该任务</span>
        singleThreadScheduledPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                String threadName = Thread.currentThread().getName();
                Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">",正在执行"</span>);
            }
        },<span class="number">1</span>,<span class="number">2</span>,TimeUnit.SECONDS);
</code></pre><p>实际上这个和上面的没什么太大区别，只不过是线程池内线程数量的不同，效果为：</p>
<p><img src="http://img.blog.csdn.net/20151116194526184" alt=""></p>
<p>每隔2秒就会执行一次该任务</p>
<h2>自定义线程池ThreadPoolExecutor</h2>

<p>Java内置只为我们提供了五种常用的线程池，一般来说这足够用了，不过有时候我们也可以根据需求来自定义我们自己的线程池，而要自定义不同功能的线程池，上面我们也说了线程池功能的不同归根到底还是内部的BlockingQueue实现不同，所以，我们要实现我们自己相要的线程池，就必须从BlockingQueue的实现上做手脚，而上面也说了BlockingQueue的实现类有多个，那么这次我们就选用PriorityBlockingQueue来实现一个功能是按任务的优先级来处理的线程池。</p>
<ol>
<li><p><strong>首先我们创建一个基于PriorityBlockingQueue实现的线程池，为了测试方便，我这里把核心线程数量设置为3，如下：</strong></p>
<pre><code>ExecutorService priorityThreadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">3</span>,<span class="number">0L</span>,TimeUnit.SECONDS,<span class="keyword">new</span> PriorityBlockingQueue());
</code></pre></li>
<li><p><strong>然后创建一个实现Runnable接口的类，并向外提供一个抽象方法供我们实现自定义功能，并实现Comparable接口，实现这个接口主要就是进行优先级的比较，代码如下：</strong></p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Comparable</span> </span>{
    <span class="keyword">private</span> <span class="keyword">int</span> priority;

    <span class="function"><span class="keyword">public</span> <span class="title">PriorityRunnable</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>{
        <span class="keyword">if</span> (priority <span class="number">0</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();
        <span class="keyword">this</span>.priority = priority;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PriorityRunnable another)</span> </span>{
        <span class="keyword">int</span> my = <span class="keyword">this</span>.getPriority();
        <span class="keyword">int</span> other = another.getPriority();
        <span class="keyword">return</span> my <span class="number">1</span> : my &gt; other ? -<span class="number">1</span> : <span class="number">0</span>;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        doSth();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> priority;
    }
}
</code></pre></li>
<li><p><strong>使用我们自己的PriorityRunnable提交任务，整体代码如下：</strong></p>
<pre><code>ExecutorService priorityThreadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">3</span>, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> PriorityBlockingQueue());
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="number">10</span>; i++) {
            final <span class="keyword">int</span> priority = i;
            priorityThreadPool.execute(<span class="keyword">new</span> PriorityRunnable(priority) {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>{
                    String threadName = Thread.currentThread().getName();
                    Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">",正在执行优先级为："</span> + priority + <span class="string">"的任务"</span>);
                    <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">2000</span>);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
</code></pre></li>
</ol>
<h4>测试效果</h4>

<p>我们看下刚刚自定义的线程池是否达到了我们想要的功能，即根据任务的优先级进行优先处理任务，效果如下：</p>
<p><img src="http://img.blog.csdn.net/20151116212159326" alt=""></p>
<p>可以从执行结果中看出，由于核心线程数设置为3，刚开始时，系统有3个空闲线程，所以无须使用任务队列，而是直接运行前三个任务，而后面再提交任务时由于当前没有空闲线程所以加入任务队列中进行等待，此时，由于我们的任务队列实现是由PriorityBlockingQueue实现的，所以进行等待的任务会经过优先级判断，优先级高的放在队列前面先处理。从效果图中也可以看到后面的任务是先执行优先级高的任务，然后依次递减。</p>
<h4>优先级线程池的优点</h4>

<p>从上面我们可以得知，创建一个优先级线程池非常有用，它可以在线程池中线程数量不足或系统资源紧张时，优先处理我们想要先处理的任务，而优先级低的则放到后面再处理，这极大改善了系统默认线程池以FIFO方式处理任务的不灵活</p>
<h2>扩展线程池ThreadPoolExecutor</h2>

<p>除了内置的功能外，ThreadPoolExecutor也向外提供了三个接口供我们自己扩展满足我们需求的线程池，这三个接口分别是：</p>
<pre><code><span class="function"><span class="title">beforeExecute</span><span class="params">()</span></span> – 任务执行前执行的方法
<span class="function"><span class="title">afterExecute</span><span class="params">()</span></span> -任务执行结束后执行的方法
<span class="function"><span class="title">terminated</span><span class="params">()</span></span> -线程池关闭后执行的方法
</code></pre><p>这三个方法在ThreadPoolExecutor内部都没有实现</p>
<p>前面两个方法我们可以在ThreadPoolExecutor内部的runWorker()方法中找到，而runWorker()是ThreadPoolExecutor的内部类Worker实现的方法，Worker它实现了Runnable接口，也正是线程池内处理任务的工作线程，而Worker.runWorker()方法则是处理我们所提交的任务的方法，它会同时被多个线程访问，所以我们看runWorker()方法的实现，由于涉及到多个线程的异步调用，必然是需要使用锁来处理，而这里使用的是Lock来实现的，我们来看看runWorker()方法内主要实现：</p>
<p><img src="http://img.blog.csdn.net/20151117141139792" alt=""></p>
<p>可以看到在task.run()之前和之后分别调用了beforeExecute和afterExecute方法，并传入了我们的任务Runnable对象</p>
<p>而terminated()则是在关闭线程池的方法中调用，而关闭线程池有两个方法，我贴其中一个：</p>
<p><img src="http://img.blog.csdn.net/20151117141553421" alt=""></p>
<p>所以，我们要扩展线程池，只需要重写这三个方法，并实现我们自己的功能即可，这三个方法分别都会在任务执行前调用、任务执行完成后调用、线程池关闭后调用。<br>这里我验证一下，继承自ThreadPoolExecutor 并实现那三个方法：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue workQueue)</span> </span>{
        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>{
        <span class="keyword">super</span>.beforeExecute(t, r);
        String threadName = t.getName();
        Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">"准备执行任务！"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>{
        <span class="keyword">super</span>.afterExecute(r, t);
        String threadName = Thread.currentThread().getName();
        Log.v(<span class="string">"zxy"</span>, <span class="string">"线程："</span> + threadName + <span class="string">"任务执行结束！"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.terminated();
        Log.v(<span class="string">"zxy"</span>, <span class="string">"线程池结束！"</span>);
    }
}
</code></pre><p>而运行后的结果则是，这正符合刚刚说的：</p>
<pre><code><span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">51.184</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程：pool-<span class="number">6</span>-thread-<span class="number">1</span>准备执行任务！
<span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">51.184</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程：pool-<span class="number">6</span>-thread-<span class="number">1</span>正在执行任务！
<span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">53.184</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程：pool-<span class="number">6</span>-thread-<span class="number">1</span>任务执行结束！
<span class="number">11</span>-<span class="number">17</span> <span class="number">05</span>:<span class="number">47</span>:<span class="number">58.896</span> <span class="number">1602</span>-<span class="number">1619</span>/? V/zxy: 线程池结束！
</code></pre><p>所以，在上面我们的优先级线程池的代码上，我们再扩展一个具有暂停功能的优先级线程池，代码如下：<br>具有暂时功能的线程池：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PausableThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>{
    <span class="keyword">private</span> <span class="keyword">boolean</span> isPaused;
    <span class="keyword">private</span> ReentrantLock pauseLock = <span class="keyword">new</span> ReentrantLock();
    <span class="keyword">private</span> Condition unpaused = pauseLock.newCondition();

    <span class="function"><span class="keyword">public</span> <span class="title">PausableThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue workQueue)</span> </span>{
        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>{
        <span class="keyword">super</span>.beforeExecute(t, r);
        pauseLock.lock();
        <span class="keyword">try</span> {
            <span class="keyword">while</span> (isPaused) unpaused.await();
        } <span class="keyword">catch</span> (InterruptedException ie) {
            t.interrupt();
        } <span class="keyword">finally</span> {
            pauseLock.unlock();
        }

    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>{
        pauseLock.lock();
        <span class="keyword">try</span> {
            isPaused = <span class="keyword">true</span>;
        } <span class="keyword">finally</span> {
            pauseLock.unlock();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>{
        pauseLock.lock();
        <span class="keyword">try</span> {
            isPaused = <span class="keyword">false</span>;
            unpaused.signalAll();
        } <span class="keyword">finally</span> {
            pauseLock.unlock();
        }
    }
}
</code></pre><p>然后结合上面的优先级线程池的实现，创建具有暂停功能的优先级线程池：</p>
<pre><code>PausableThreadPoolExecutor pausableThreadPoolExecutor = <span class="keyword">new</span> PausableThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> PriorityBlockingQueue());
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <span class="number">100</span>; i++) {
            final <span class="keyword">int</span> priority = i;
            pausableThreadPoolExecutor.execute(<span class="keyword">new</span> PriorityRunnable(priority) {
                @<span class="function">Override
                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>{
                    runOnUiThread(<span class="keyword">new</span> Runnable() {
                        @<span class="function">Override
                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                            textView.setText(priority + <span class="string">""</span>);
                        }
                    });
                    <span class="keyword">try</span> {
                        Thread.sleep(<span class="number">1000</span>);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
</code></pre><p>这里我为了演示效果，把这个线程池设为只有一个线程，然后直接在TextView中显示当前执行的任务的优先级，然后设置个开关，控制线程池的暂停与开始：</p>
<pre><code><span class="keyword">if</span> (isPause) {
    pausableThreadPoolExecutor.resume<span class="literal">()</span>;
    isPause = <span class="literal">false</span>;
} <span class="keyword">else</span> {
    pausableThreadPoolExecutor.pause<span class="literal">()</span>;
    isPause = <span class="literal">true</span>;
}
</code></pre><p>效果为：</p>
<p><img src="http://img.blog.csdn.net/20151117144914201" alt=""></p>
<p>从效果上来看，该线程池和优先级线程一样，而且还多了一个暂停与开始的功能</p>
<h2>优化线程池ThreadPoolExecutor</h2>

<p>虽说线程池极大改善了系统的性能，不过创建线程池也是需要资源的，所以线程池内线程数量的大小也会影响系统的性能，大了反而浪费资源，小了反而影响系统的吞吐量，所以我们创建线程池需要把握一个度才能合理的发挥它的优点，通常来说我们要考虑的因素有CPU的数量、内存的大小、并发请求的数量等因素，按需调整。</p>
<p><em>通常核心线程数可以设为CPU数量+1，而最大线程数可以设为CPU的数量\</em>2+1*</p>
<p>获取CPU数量的方法为：</p>
<pre><code><span class="tag">Runtime</span><span class="class">.getRuntime</span>()<span class="class">.availableProcessors</span>();
</code></pre><h2>shutdown()和shutdownNow()的区别</h2>

<p>关于线程池的停止，ExecutorService为我们提供了两个方法：shutdown和shutdownNow，这两个方法各有不同，可以根据实际需求方便的运用，如下：</p>
<ol>
<li>shutdown()方法在终止前允许执行以前提交的任务。</li>
<li>shutdownNow()方法则是阻止正在任务队列中等待任务的启动并试图停止当前正在执行的任务。</li>
</ol>
<h2>关于AsyncTask的实现</h2>

<p>大家都知道AsyncTask内部实现其实就是Thread+Handler。其中Handler是为了处理线程之间的通信，而这个Thread到底是指什么呢？通过AsyncTask源码可以得知，其实这个Thread是线程池，AsyncTask内部实现了两个线程池，分别是：串行线程池和固定线程数量的线程池。而这个固定线程数量则是通过CPU的数量决定的。</p>
<p>在默认情况下，我们大都通过AsyncTask::execute()来执行任务的，<br>，而execute()内部则是调用executeOnExecutor(sDefaultExecutor, params)方法执行的，第一个参数就是指定处理该任务的线程池，而默认情况下AsyncTask是传入串行线程池（在这里不讲版本的变化），也就是任务只能单个的按顺序执行，而我们要是想让AsyncTask并行的处理任务，大家都知道调用AsyncTask::executeOnExecutor(sDefaultExecutor, params)方法传入这个参数即可：AsyncTask.THREAD_POOL_EXECUTOR。<br>而这个参数的意义在于为任务指定了一个固定线程数量的线程池去处理，从而达到了并行处理的功能，我们可以在源码中看到AsyncTask.THREAD_POOL_EXECUTOR这个参数就是一个固定线程数量的线程池：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR
            = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,
                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>说到线程，我想大家都不陌生，因为在开发时候或多或少都会用到线程，而通常创建线程有两种方式：</p>
<ol>
<li>继承自Thread类</li>
<li>实现Runnable接口</li>
</ol>
<p>虽说这两种方式都可以创建出一个线程，不过它们之间还是有一点区别的，主要区别在于在多线程访问同一资源的情况下，用Runnable接口创建的线程可以处理同一资源，而用Thread类创建的线程则各自独立处理，各自拥有自己的资源。</p>
<p>所以，在Java中大多数多线程程序都是通过实现Runnable来完成的，而对于Android来说也不例外，当涉及到需要开启线程去完成某件事时，我们都会这样写：</p>
<pre><code><span class="tag">new</span> <span class="tag">Thread</span>(new <span class="function">Runnable</span>() {
    <span class="variable">@Override</span>
    public void <span class="function">run</span>() {
        <span class="comment">//do sth .</span>
    }
})<span class="class">.start</span>();
</code></pre><p>这段代码创建了一个线程并执行，它在任务结束后GC会自动回收该线程，一切看起来如此美妙，是的，它在线程并发不多的程序中确实不错，而假如这个程序有很多地方需要开启大量线程来处理任务，那么如果还是用上述的方式去创建线程处理的话，那么将导致系统的性能表现的非常糟糕，更别说在内存有限的移动设备上，主要的影响如下：</p>
<ol>
<li>线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失</li>
<li>大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM</li>
<li>大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿</li>
</ol>
<p>而针对上述所描述的问题，解决的办法归根到底就是：重用已有的线程，从而减少线程的创建。<br>所以这就涉及到线程池（ExecutorService）的概念了，线程池的基本作用就是进行线程的复用，下面将具体介绍线程池的使用</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之常见的内存泄漏]]></title>
    <link href="http://hanhailong.com/2015/12/27/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://hanhailong.com/2015/12/27/Android性能优化之常见的内存泄漏/</id>
    <published>2015-12-27T05:12:02.000Z</published>
    <updated>2015-12-27T05:41:37.000Z</updated>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>对于内存泄漏，我想大家在开发中肯定都遇到过，只不过内存泄漏对我们来说并不是可见的，因为它是在堆中活动，而要想检测程序中是否有内存泄漏的产生，通常我们可以借助LeakCanary、MAT等工具来检测应用程序是否存在内存泄漏，MAT是一款强大的内存分析工具，功能繁多而复杂，而LeakCanary则是由Square开源的一款轻量第三方内存泄漏检测工具，当它检测到程序中有内存泄漏的产生时，它将以最直观的方式告诉我们该内存泄漏是由谁产生的和该内存泄漏导致谁泄漏了而不能回收，供我们复查。</p>
<p>最近腾讯bugly也推出了三篇关于Android内存泄漏调优的文章：</p>
<ol>
<li><a href="http://bugly.qq.com/blog/?p=832" target="_blank" rel="external">内存泄露从入门到精通三部曲之基础知识篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=872" target="_blank" rel="external">内存泄露从入门到精通三部曲之排查方法篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=884" target="_blank" rel="external">内存泄露从入门到精通三部曲之常见原因与用户实践</a></li>
</ol>
<p>Realm同样给出了性能优化文章：</p>
<p><a href="https://realm.io/cn/news/droidcon-farber-improving-android-app-performance/" target="_blank" rel="external">10条提升Android性能的建议</a></p>
<a id="more"></a>
<h2>内存泄漏</h2>

<h4>为什么会产生内存泄漏？</h4>

<p>当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p>
<h4>内存泄漏对程序的影响？</h4>

<p>内存泄漏是造成应用程序OOM的主要原因之一！我们知道Android系统为每个应用程序分配的内存有限，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就造成了内存溢出而导致应用Crash。</p>
<h2>Android中常见的内存泄漏汇总</h2>

<h4>单例造成的内存泄漏</h4>

<p>单例模式非常受开发者的喜爱，不过使用的不恰当的话也会造成内存泄漏，由于单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。</p>
<p>如下这个典例：</p>
<pre><code>public class AppManager {
   <span class="keyword"> private</span><span class="keyword"> static</span> AppManager instance;
   <span class="keyword"> private</span> Context context;
   <span class="keyword"> private</span><span class="function"> AppManager(</span>Context context<span class="function">)</span> {
        this.context = context;
    }
   <span class="keyword"> public</span><span class="keyword"> static</span> AppManager<span class="function"> getInstance(</span>Context             context<span class="function">)</span> {
       <span class="instruction"> if </span>(instance != null<span class="function">)</span> {
           <span class="instruction"> instance </span>=<span class="instruction"> new </span>AppManager(context<span class="function">)</span>;
        }
       <span class="instruction"> return </span>instance;
    }
}
</code></pre><p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要： </p>
<ol>
<li>传入的是Application的Context：这将没有任何问题，因为单例的生命周期和Application的一样长</li>
<li>传入的是Activity的Context：当这个Context所对应的Activity退出时，由于该Context和Activity的生命周期一样长（Activity间接继承于Context），所以当前Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用。</li>
</ol>
<p>所以正确的单例应该修改为下面这种方式：</p>
<pre><code>public class AppManager {
   <span class="keyword"> private</span><span class="keyword"> static</span> AppManager instance;
   <span class="keyword"> private</span> Context context;
   <span class="keyword"> private</span><span class="function"> AppManager(</span>Context context<span class="function">)</span> {
        this.context =<span class="function"> context.getApplicationContext(</span><span class="function">)</span>;
    }
   <span class="keyword"> public</span><span class="keyword"> static</span> AppManager<span class="function"> getInstance(</span>Context context<span class="function">)</span> {
       <span class="instruction"> if </span>(instance != null<span class="function">)</span> {
           <span class="instruction"> instance </span>=<span class="instruction"> new </span>AppManager(context<span class="function">)</span>;
        }
       <span class="instruction"> return </span>instance;
    }
}
</code></pre><p>这样不管传入什么Context最终将使用Application的Context，而单例的生命周期和应用的一样长，这样就防止了内存泄漏</p>
<h4>非静态内部类创建静态实例造成的内存泄漏</h4>

<p>有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
    <span class="keyword">private</span> static <span class="type">TestResource</span> mResource = <span class="literal">null</span>;
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        <span class="keyword">if</span>(mResource == <span class="literal">null</span>){
            mResource = <span class="keyword">new</span> <span class="type">TestResource</span>();
        }
        <span class="comment">//...</span>
    }
    <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> {</span>
    <span class="comment">//...</span>
    }
}
</code></pre><p>这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而又使用了该非静态内部类创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为：<br>将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请使用ApplicationContext</p>
<h4>Handler造成的内存泄漏</h4>

<p>Handler的使用造成的内存泄漏问题应该说最为常见了，平时在处理网络任务或者封装一些请求回调等api都应该会借助Handler来处理，对于Handler的使用代码编写一不规范即有可能造成内存泄漏，如下示例：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
<span class="keyword">private</span> <span class="type">Handler</span> mHandler = <span class="keyword">new</span> <span class="type">Handler</span>() {
    <span class="annotation">@Override</span>
    public void handleMessage(<span class="type">Message</span> msg) {
    <span class="comment">//...</span>
    }
};
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        loadData();
    }
    <span class="keyword">private</span> void loadData(){
        <span class="comment">//...request</span>
        <span class="type">Message</span> message = <span class="type">Message</span>.obtain();
        mHandler.sendMessage(message);
    }
}
</code></pre><p>这种创建Handler的方式会造成内存泄漏，由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏，所以另外一种做法为：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
    <span class="keyword">private</span> <span class="type">MyHandler</span> mHandler = <span class="keyword">new</span> <span class="type">MyHandler</span>(<span class="keyword">this</span>);
    <span class="keyword">private</span> <span class="type">TextView</span> mTextView ;
    <span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Handler</span> {</span>
        <span class="keyword">private</span> <span class="type">WeakReference</span>&lt;<span class="type">Context</span>&gt; reference;
        public <span class="type">MyHandler</span>(<span class="type">Context</span> context) {
        reference = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;&gt;(context);
        }
        <span class="annotation">@Override</span>
        public void handleMessage(<span class="type">Message</span> msg) {
            <span class="type">MainActivity</span> activity = (<span class="type">MainActivity</span>) reference.get();
            <span class="keyword">if</span>(activity != <span class="literal">null</span>){
            activity.mTextView.setText(<span class="string">""</span>);
            }
        }
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        mTextView = (<span class="type">TextView</span>)findViewById(<span class="type">R</span>.id.textview);
        loadData();
    }

    <span class="keyword">private</span> void loadData() {
        <span class="comment">//...request</span>
        <span class="type">Message</span> message = <span class="type">Message</span>.obtain();
        mHandler.sendMessage(message);
    }
}
</code></pre><p>创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息，更准确的做法如下：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
    <span class="keyword">private</span> <span class="type">MyHandler</span> mHandler = <span class="keyword">new</span> <span class="type">MyHandler</span>(<span class="keyword">this</span>);
    <span class="keyword">private</span> <span class="type">TextView</span> mTextView ;
    <span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Handler</span> {</span>
        <span class="keyword">private</span> <span class="type">WeakReference</span>&lt;<span class="type">Context</span>&gt; reference;
        public <span class="type">MyHandler</span>(<span class="type">Context</span> context) {
        reference = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;&gt;(context);
        }
        <span class="annotation">@Override</span>
        public void handleMessage(<span class="type">Message</span> msg) {
            <span class="type">MainActivity</span> activity = (<span class="type">MainActivity</span>) reference.get();
            <span class="keyword">if</span>(activity != <span class="literal">null</span>){
            activity.mTextView.setText(<span class="string">""</span>);
            }
        }
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        mTextView = (<span class="type">TextView</span>)findViewById(<span class="type">R</span>.id.textview);
        loadData();
    }

    <span class="keyword">private</span> void loadData() {
        <span class="comment">//...request</span>
        <span class="type">Message</span> message = <span class="type">Message</span>.obtain();
        mHandler.sendMessage(message);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onDestroy() {
        <span class="keyword">super</span>.onDestroy();
        mHandler.removeCallbacksAndMessages(<span class="literal">null</span>);
    }
}
</code></pre><p>使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages();来移除指定的Runnable和Message。</p>
<h4>线程造成的内存泄漏</h4>

<p>对于线程造成的内存泄漏，也是平时比较常见的，异步任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成，<br>那么将导致Activity的内存资源无法回收，造成内存泄漏。正确的做法还是使用静态内部类的方式，如下：</p>
<pre><code><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">Void</span>&gt; </span>{
    <span class="keyword">private</span> WeakReference&lt;Context&gt; weakReference;

    <span class="function"><span class="keyword">public</span> <span class="title">MyAsyncTask</span><span class="params">(Context context)</span> </span>{
        weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>{
        SystemClock.sleep(<span class="number">10000</span>);
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Void aVoid)</span> </span>{
        <span class="keyword">super</span>.onPostExecute(aVoid);
        MainActivity activity = (MainActivity) weakReference.get();
        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) {
        <span class="comment">//...</span>
        }
    }
}
<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        SystemClock.sleep(<span class="number">10000</span>);
    }
}
<span class="comment">//——————</span>
<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();
<span class="keyword">new</span> MyAsyncTask(<span class="keyword">this</span>).execute();
</code></pre><p>这样就避免了Activity的内存资源泄漏，当然在Activity销毁时候也应该取消相应的任务AsyncTask::cancel()，避免任务在后台执行浪费资源。</p>
<h4>资源未关闭造成的内存泄漏</h4>

<p>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>
<h4>一些建议</h4>

<ol>
<li>对于生命周期比Activity长的对象如果需要应该使用ApplicationContext</li>
<li>对于需要在静态内部类中使用非静态外部成员变量（如：Context、View )，可以在静态内部类中使用弱引用来引用外部类的变量来避免内存泄漏</li>
<li>对于不再需要使用的对象，显示的将其赋值为null，比如使用完Bitmap后先调用recycle()，再赋为null</li>
<li>保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期</li>
<li><p>对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏：</p>
<ol>
<li>将内部类改为静态内部类</li>
<li>静态内部类中使用弱引用来引用外部类的成员变量</li>
</ol>
</li>
<li><p>在涉及到Context时先考虑ApplicationContext，当然它并不是万能的，对于有些地方则必须使用Activity的Context，对于Application，Service，Activity三者的Context的应用场景如下：</p>
</li>
</ol>
<p><img src="http://img.blog.csdn.net/20151123144226349" alt=""></p>
<p><strong>其中：</strong>NO1表示Application和Service可以启动一个Activity，不过需要创建一个新的task任务队列。而对于Dialog而言，只有在Activity中才能创建</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>前言</h2>

<p>对于内存泄漏，我想大家在开发中肯定都遇到过，只不过内存泄漏对我们来说并不是可见的，因为它是在堆中活动，而要想检测程序中是否有内存泄漏的产生，通常我们可以借助LeakCanary、MAT等工具来检测应用程序是否存在内存泄漏，MAT是一款强大的内存分析工具，功能繁多而复杂，而LeakCanary则是由Square开源的一款轻量第三方内存泄漏检测工具，当它检测到程序中有内存泄漏的产生时，它将以最直观的方式告诉我们该内存泄漏是由谁产生的和该内存泄漏导致谁泄漏了而不能回收，供我们复查。</p>
<p>最近腾讯bugly也推出了三篇关于Android内存泄漏调优的文章：</p>
<ol>
<li><a href="http://bugly.qq.com/blog/?p=832">内存泄露从入门到精通三部曲之基础知识篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=872">内存泄露从入门到精通三部曲之排查方法篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=884">内存泄露从入门到精通三部曲之常见原因与用户实践</a></li>
</ol>
<p>Realm同样给出了性能优化文章：</p>
<p><a href="https://realm.io/cn/news/droidcon-farber-improving-android-app-performance/">10条提升Android性能的建议</a></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sublime Text自动开启换行Word Wrap]]></title>
    <link href="http://hanhailong.com/2015/11/24/Sublime-Text%E8%87%AA%E5%8A%A8%E5%BC%80%E5%90%AF%E6%8D%A2%E8%A1%8CWord-Wrap/"/>
    <id>http://hanhailong.com/2015/11/24/Sublime-Text自动开启换行Word-Wrap/</id>
    <published>2015-11-24T10:02:27.000Z</published>
    <updated>2015-11-24T10:22:38.000Z</updated>
    <content type="html"><![CDATA[<p>Sublime Text，绝对是神器中的神器，之前在windows电脑上一直都是用nodepad++。mac上也没找到太好的编辑工具，之前曾用过破解版的<em>UltraEdit</em>，但是自从第一次用了Sublime Text后，就彻底的把它打入冷宫了！！</p>
<p>下面讲讲如何开启Sublime Text的自动换行功能，默认情况下是不开启的。当然你也可以点击导航栏上View-&gt;Word Wrap开启，不过对我们程序猿来说，还是太麻烦了。这里从根本上解决自动换行的问题。</p>
<p>解决方案：<br>    我这里用的是mac版本的，windows同理</p>
<pre><code>Preferences-&gt;Setting - <span class="built_ins">User</span>
</code></pre><p>在打开的<em>Preferences.sublime-settings</em>文件里面，你将会看到类似下面的内容：</p>
<pre><code>{
    "<span class="attribute">ignored_packages</span>":
    <span class="value">[
        <span class="string">"Markdown"</span>,
        <span class="string">"Vintage"</span>
    ]
</span>}
</code></pre><p>很明显，这是一个json格式的配置文件，在后面直接追加</p>
<pre><code>{ "<span class="attribute">word_wrap</span>" : <span class="value"><span class="literal">true</span> </span>}
</code></pre><p>修改之后的文件内容为：</p>
<pre><code>{
    "<span class="attribute">ignored_packages</span>":
    <span class="value">[
        <span class="string">"Markdown"</span>,
        <span class="string">"Vintage"</span>
    ]</span>,
    "<span class="attribute">word_wrap</span>":<span class="value"><span class="literal">true</span>
</span>}
</code></pre><p>重启Sublime Text后，你将会发现文字、代码超过一行后会自动换行！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Sublime Text，绝对是神器中的神器，之前在windows电脑上一直都是用nodepad++。mac上也没找到太好的编辑工具，之前曾用过破解版的<em>UltraEdit</em>，但是自从第一次用了Sublime Text后，就彻底的把它打入冷宫了！！</p>
<]]>
    </summary>
    
      <category term="Sublime Text" scheme="http://hanhailong.com/tags/Sublime-Text/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-小米桌面图标显示角标数]]></title>
    <link href="http://hanhailong.com/2015/11/23/Android-%E5%B0%8F%E7%B1%B3%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA%E8%A7%92%E6%A0%87%E6%95%B0/"/>
    <id>http://hanhailong.com/2015/11/23/Android-小米桌面图标显示角标数/</id>
    <published>2015-11-23T07:07:11.000Z</published>
    <updated>2015-11-23T10:02:09.000Z</updated>
    <content type="html"><![CDATA[<h3>基本介绍</h3>

<p>最近有群里问：怎样在小米手机桌面的图标上显示角标数，我看了下我的红米note手机，果然有的第三方app图标上显示角标数，尤其是微信和QQ。这让我立马想到了：小米是不是对通知栏做了手脚。立马我查了相关文档并做了相关的测试，发现果然如我猜测的：MIUI系统对通知栏做了手脚。它目前有两种情况：</p>
<ol>
<li>默认情况<br> 当第三方app向通知栏发送一条通知（一般不带进度条并且用户可以删除的通知），那么此时app icon的角标数就会显示1。<br> 这个时候app显示的角标数和通知栏里app发送的通知数是对应的，即向通知栏发多少条通知就会显示多少角标数。</li>
</ol>
<a id="more"></a>
<ol>
<li><p>定义角标数量<br> 如果想让app在通知栏里只显示一条通知，但角标数是多个怎么办呢？</p>
<p> 原理是通过反射拿到<em>Notification</em>的私有属性<em>extraNotification</em>，重点就是这个<em>extraNotification</em>,MIUI系统对这个重定义了，这个类在MIUI系统里是<em>android.app.MiuiNotification</em>这个类，这个类里面有个私有属性<em>messageCount</em>,我们只要改变这个<em>messageCount</em>值就能显示的改变app icon的角标数了。如下图所示：</p>
</li>
</ol>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/miui_notification.png?raw=true" alt="miuinotification">    </p>
<p>这里给出代码示例：</p>
<pre><code><span class="type">NotificationCompat</span>.<span class="type">Builder</span> builder = new <span class="type">NotificationCompat</span>.<span class="type">Builder</span>(this)
            .setSmallIcon(R.mipmap.ic_launcher)
            .setContentTitle(<span class="string">"小米角标"</span>)
            .setContentText(<span class="string">"miui桌面角标消息"</span>);

    <span class="type">NotificationManagerCompat</span> managerCompat = <span class="type">NotificationManagerCompat</span>.<span class="keyword">from</span>(this);

    <span class="type">Notification</span> notification = builder.build();
    <span class="keyword">try</span> {
        <span class="type">Field</span> field = notification.getClass().getDeclaredField(<span class="string">"extraNotification"</span>);

        <span class="type">Object</span> extraNotification = field.get(notification);

        <span class="type">Method</span> <span class="keyword">method</span> = extraNotification.getClass().getDeclaredMethod(<span class="string">"setMessageCount"</span>, <span class="type">int</span>.class);

        <span class="keyword">method</span>.invoke(extraNotification, <span class="number">10</span>);
    } catch (<span class="type">Exception</span> e) {
          e.printStackTrace();
    }

    managerCompat.notify(<span class="number">0</span>, notification);
</code></pre><p>上面的数字10就是要显示的角标数，我们看下结果：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/miui_app_icon_count.png?raw=true" alt="app-icon"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3>基本介绍</h3>

<p>最近有群里问：怎样在小米手机桌面的图标上显示角标数，我看了下我的红米note手机，果然有的第三方app图标上显示角标数，尤其是微信和QQ。这让我立马想到了：小米是不是对通知栏做了手脚。立马我查了相关文档并做了相关的测试，发现果然如我猜测的：MIUI系统对通知栏做了手脚。它目前有两种情况：</p>
<ol>
<li>默认情况<br> 当第三方app向通知栏发送一条通知（一般不带进度条并且用户可以删除的通知），那么此时app icon的角标数就会显示1。<br> 这个时候app显示的角标数和通知栏里app发送的通知数是对应的，即向通知栏发多少条通知就会显示多少角标数。</li>
</ol>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-部分作品鉴赏]]></title>
    <link href="http://hanhailong.com/2015/11/04/Android-%E9%83%A8%E5%88%86%E4%BD%9C%E5%93%81%E9%89%B4%E8%B5%8F/"/>
    <id>http://hanhailong.com/2015/11/04/Android-部分作品鉴赏/</id>
    <published>2015-11-04T15:32:50.000Z</published>
    <updated>2015-11-04T15:56:09.000Z</updated>
    <content type="html"><![CDATA[<p>时间过得真快，马上快毕业四年了，这里整理了下我做过的部分App，当然还有一些其他的App，不是外包就是没有纪念意义，这里就不列举了！</p>
<a id="more"></a>
<h3>51拉勾</h3>

<p><a href="http://www.wandoujia.com/apps/com.ydcy.lago.app" target="_blank" rel="external">51拉钩</a>是我做过的第二个商业Android客户端App，承载了我很多记忆，现在还记得当初和小伙伴们加班到晚上11点、12点甚至凌晨两三点的情景（岁月不饶人啊~~~）！！！</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-1.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-2.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-3.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-4.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-5.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-6.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-7.png?raw=true" alt="家庭首页"></p>
<h3>51听听</h3>

<p><a href="http://www.wandoujia.com/apps/com.ydcy.ting.app" target="_blank" rel="external">51听听</a>是继51拉钩之后的又一个商业App，这个App比较有意思，里面包括大量童话、唐诗三百首等儿童教育方面的故事！！！</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-1.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-2.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-3.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-4.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-5.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-6.png?raw=true" alt="51听"></p>
<h3>发镖</h3>

<p><a href="http://www.wandoujia.com/apps/com.cubead.appclient" target="_blank" rel="external">发镖</a>这是我加入北京博雅立方做过的唯一的一款App，包括IOS版本，这个App以前叫营销掌中宝，是国内首家最专业的营销推广平台，服务类目包括微信营销、百度营销、建站推广等多产品类目。</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-1.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-2.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-3.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-4.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-5.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-6.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-7.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-8.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-9.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-10.png?raw=true" alt="发镖"></p>
<h3>极客学院</h3>

<p><a href="http://www.jikexueyuan.com/app/" target="_blank" rel="external">极客学院</a>，中国最大的IT职业在线教育平台！！</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-1.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-2.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-3.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-4.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-5.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-6.png?raw=true" alt="jike"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>时间过得真快，马上快毕业四年了，这里整理了下我做过的部分App，当然还有一些其他的App，不是外包就是没有纪念意义，这里就不列举了！</p>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://hanhailong.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android版本-编译VLC]]></title>
    <link href="http://hanhailong.com/2015/10/27/Android%E7%89%88%E6%9C%AC-%E7%BC%96%E8%AF%91VLC/"/>
    <id>http://hanhailong.com/2015/10/27/Android版本-编译VLC/</id>
    <published>2015-10-27T13:54:31.000Z</published>
    <updated>2015-11-05T16:06:59.000Z</updated>
    <content type="html"><![CDATA[<h2>简述</h2>

<p>最近公司项目<a href="http://www.jikexueyuan.com/app/" target="_blank" rel="external">极客学院</a>在线播放器要加一个需求：支持播放倍数加速、支持字幕；之前用的是一个第三方的开源库<a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="external">ijkplayer</a>，这个库也非常的给力，它对ffmpeg做了很好的封装，不过不支持加速减速播放，所以弃用改成<a href="https://wiki.videolan.org/AndroidCompile" target="_blank" rel="external">VLC-Android</a>，IOS的在这<a href="https://wiki.videolan.org/IOSCompile" target="_blank" rel="external">VLC-IOS</a>.</p>
<a id="more"></a>
<p>这里记录下编译Android版本的过程和遇到的错误：</p>
<p>总体来说是比较顺利的，按照官方的wiki文档一步一步走下来，基本上没有遇到大问题，遇到唯一的问题是<a href="http://download.csdn.net/detail/hanhailong726188/9218615" target="_blank" rel="external">xz-5.0.3.tar.bz2</a>和<a href="http://download.csdn.net/detail/hanhailong726188/9218631" target="_blank" rel="external">protobuf-2.6.1.tar.gz</a>这两个库文件没有下载些来（因为被墙了），我单独下载安装的，这里我把这两个文件放到CSDN上了，有需要的自行下载！！</p>
<h2>编译过程</h2>

<p>编译的第一步肯定是需要下载一些必要的工具，如果你的系统是Linux，你可以通过api-get来安装：</p>
<pre><code><span class="label">sudo</span> apt-<span class="preprocessor">get</span> install automake ant autopoint cmake <span class="keyword">build-essential </span>libtool \
     patch pkg-config protobuf-compiler ragel <span class="keyword">subversion </span>unzip git
</code></pre><p>我这里用的是Mac Ox，所以采用<a href="http://brew.sh/" target="_blank" rel="external">HomeBrew</a>来安装，首先需要执行命令：</p>
<pre><code><span class="keyword">brew </span>install automake ant autopoint cmake <span class="keyword">build-essential </span>libtool \
     patch pkg-config protobuf-compiler ragel <span class="keyword">subversion </span>unzip git
</code></pre><p>然后等待上面的工具安装完成，安装完成后开始执行下一步</p>
<p>这里假设你已经装好<a href="http://developer.android.com/sdk/index.html" target="_blank" rel="external">Android SDK</a>和<a href="http://developer.android.com/tools/sdk/ndk/index.html" target="_blank" rel="external">Android NDK</a></p>
<h4>配置环境变量</h4>

<p>1.cd命令到当前用户目录下，打开.bash_profile文件：</p>
<pre><code><span class="title">cd</span> <span class="regexp">~
open</span> .bash_profile
</code></pre><p>如果没有.bash_profile，请touch新建一个.bash_profile</p>
<pre><code><span class="tag">touch</span> <span class="class">.bash_profile</span>
</code></pre><p>打开.bash_profile文件后，在文件里面输入</p>
<pre><code>export ANDROID_SDK=/Users/HanHailong/Library/Android/sdk
export ANDROID_NDK=/Users/HanHailong/NDK/android-ndk-r10e
export PATH=<span class="variable">$PATH</span>:<span class="variable">$ANDROID</span>_SDK/platform-tools:<span class="variable">$ANDROID</span>_SDK/tools
</code></pre><p>ANDROID_SDK和ANDROID_NDK后面的换成你自己对应的路径。</p>
<h4>克隆代码</h4>

<pre><code>git clone <span class="string">git:</span><span class="comment">//git.videolan.org/vlc-ports/android.git</span>
</code></pre><p></p><h5>编译工程</h5><br>将项目clone下来后就开始编译项目了，<br>cd命令到你clone下来的工程里面，执行命令：<p></p>
<pre><code>./compile.<span class="keyword">sh</span>
</code></pre><p>然后VLC会自动执行一长系列的下载、编译工作，这里需要等老长时间，如果你有vpn，最好开启vpn，因为一些用到的文件被墙了！！我这里就遇到坑了，<a href="http://download.csdn.net/detail/hanhailong726188/9218615" target="_blank" rel="external">xz-5.0.3.tar.bz2</a>和<a href="http://download.csdn.net/detail/hanhailong726188/9218631" target="_blank" rel="external">protobuf-2.6.1.tar.gz</a>下载失败，而导致VLC编译失败，没办法，只能将上面两个文件单独下载下来.</p>
<ol>
<li><p>解压并安装protobuf</p>
<p> 一步一步执行下面如下命令：</p>
<pre><code>tar -zxf protobuf-<span class="number">2.6</span><span class="number">.1</span>.tar.gz
cd protobuf-<span class="number">2.6</span><span class="number">.1</span>
./configure
make install
</code></pre></li>
</ol>
<ol>
<li><p>解压并安装xz</p>
<p> 一步一步执行下面如下命令：</p>
<pre><code>tar -zxf xz-<span class="number">5.0</span><span class="number">.3</span>.tar.bz2
cd xz-<span class="number">5.0</span><span class="number">.3</span>
./configure
make install
</code></pre></li>
</ol>
<p>执行完了后，继续回到VLC工程目录下执行命令：</p>
<pre><code>./compile.<span class="keyword">sh</span>
</code></pre><p>之后，VLC会继续执行下载、编译库文件，稍微等一段时间，快得几分钟，慢的十几分钟！！看编译成功后的截图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_android.png?raw=true" alt="VLC"></p>
<h4>编译结果</h4>

<p>编译成功后，会在<font color="red">vlc-android/build/outputs/apk</font>目录下生成编译后的apk包：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_apk.png?raw=true" alt="apk"></p>
<p>我们将其安装到真机上，效果图还是蛮不错的：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_1.png?raw=true" alt="image1"><br><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_2.png?raw=true" alt="image2"><br><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_3.png?raw=true" alt="image3"></p>
<p>VLC很强大，支持字幕，支持锁定屏幕，支持跳转到某个具体时间，支持0.25-4倍的慢放、快放、支持亮度调节、支持音量调节、支持快进、支持直播等特性，是做在线视频播放的绝佳选择之一！！！！</p>
<p>上面两个<a href="http://download.csdn.net/detail/hanhailong726188/9218615" target="_blank" rel="external">xz-5.0.3.tar.bz2</a>和<a href="http://download.csdn.net/detail/hanhailong726188/9218631" target="_blank" rel="external">protobuf-2.6.1.tar.gz</a>可以在这里下载！</p>
<p>最后，附上我编译好的项目<a href="https://github.com/hanhailong/VCL-Android" target="_blank" rel="external">VLC-Android</a>，这里我只编译了四种so包（armeabi-v7a、armeabi、x86、mips），有需要的朋友自行下载。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>简述</h2>

<p>最近公司项目<a href="http://www.jikexueyuan.com/app/">极客学院</a>在线播放器要加一个需求：支持播放倍数加速、支持字幕；之前用的是一个第三方的开源库<a href="https://github.com/Bilibili/ijkplayer">ijkplayer</a>，这个库也非常的给力，它对ffmpeg做了很好的封装，不过不支持加速减速播放，所以弃用改成<a href="https://wiki.videolan.org/AndroidCompile">VLC-Android</a>，IOS的在这<a href="https://wiki.videolan.org/IOSCompile">VLC-IOS</a>.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不错的IOS学习博客网站-IOS122]]></title>
    <link href="http://hanhailong.com/2015/10/22/%E4%B8%8D%E9%94%99%E7%9A%84IOS%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99-IOS122/"/>
    <id>http://hanhailong.com/2015/10/22/不错的IOS学习博客网站-IOS122/</id>
    <published>2015-10-22T08:58:51.000Z</published>
    <updated>2015-10-22T09:07:09.000Z</updated>
    <content type="html"><![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第四篇，只不过<a href="http://www.ios122.com/" target="_blank" rel="external">IOS122</a>只讲解IOS技术。</p>
<p>当我第一次打开这个博客的时候，我被里面的第三库资源震惊了，没想到作者整理了这么多的第三库资源。最重要的是，里面的博文质量非常高，绝对是IOS学习技术的最佳去处！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第四篇，只不过<a href="http://www.ios122.com/" targe]]>
    </summary>
    
      <category term="技术博客" scheme="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[cocoapods安装失败-bad response Not Found 404 (http://ruby.taobao.org/latest_specs.4.8.gz]]></title>
    <link href="http://hanhailong.com/2015/10/22/cocoapods%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5-bad-response-Not-Found-404-http-ruby-taobao-org-latest-specs-4-8-gz/"/>
    <id>http://hanhailong.com/2015/10/22/cocoapods安装失败-bad-response-Not-Found-404-http-ruby-taobao-org-latest-specs-4-8-gz/</id>
    <published>2015-10-22T05:37:34.000Z</published>
    <updated>2015-10-22T06:17:49.000Z</updated>
    <content type="html"><![CDATA[<p>最近把MAC系统升级到了最新版本-10.11（OS X EI Capitan），发现之前装的<a href="https://github.com/CocoaPods/CocoaPods" target="_blank" rel="external">CocoaPods</a>不能用了，只好重新装了。执行如下命令：</p>
<pre><code>sudo gem <span class="keyword">install</span> cocoapods
</code></pre><p>发现报如下错误：<br><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/pod_error.png?raw=true" alt="image"></p>
<a id="more"></a>
<p>我之前就是用的淘宝的镜像<a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a>，我们在浏览器上输入：<a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a>，链接自动重定向到了<a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a>，淘宝镜像也给了提示：</p>
<p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/taobao_tips.png?raw=true" alt="image"></p>
<p>好吧，那我们只能删掉http的，改成https的，执行命令：</p>
<pre><code>gem sources --remove <span class="string">http:</span><span class="comment">//ruby.taobao.org/</span>
gem sources -a <span class="string">https:</span><span class="comment">//ruby.taobao.org/</span>
</code></pre><p>改掉之后我们继续使用命令查看我们改之后的ruby镜像：</p>
<pre><code>gem sources <span class="operator">-l</span>
</code></pre><p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/pod_new.png?raw=true" alt="image"></p>
<p>我们继续安装cocoapods，执行命令：</p>
<pre><code>sudo gem <span class="keyword">install</span> cocoapods
</code></pre><p>这时候会让你输入密码，输入密码完了之后就开始真正的安装cocoapods了</p>
<p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/pod_install.png?raw=true" alt="image"></p>
<p>安装完之后，执行命令：</p>
<pre><code>pod <span class="comment">--version</span>
</code></pre><p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/pod_version.png?raw=true" alt="image"></p>
<p>出现版本0.39.0之后，就说明安装成功了！！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近把MAC系统升级到了最新版本-10.11（OS X EI Capitan），发现之前装的<a href="https://github.com/CocoaPods/CocoaPods">CocoaPods</a>不能用了，只好重新装了。执行如下命令：</p>
<pre><code>sudo gem <span class="keyword">install</span> cocoapods
</code></pre><p>发现报如下错误：<br><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/pod_error.png?raw=true" alt="image"></p>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://hanhailong.com/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-教你自作一个简单而又实用的流式Tag标签布局]]></title>
    <link href="http://hanhailong.com/2015/10/20/Android-%E6%95%99%E4%BD%A0%E8%87%AA%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%80%8C%E5%8F%88%E5%AE%9E%E7%94%A8%E7%9A%84%E6%B5%81%E5%BC%8FTag%E6%A0%87%E7%AD%BE%E5%B8%83%E5%B1%80/"/>
    <id>http://hanhailong.com/2015/10/20/Android-教你自作一个简单而又实用的流式Tag标签布局/</id>
    <published>2015-10-20T10:26:19.000Z</published>
    <updated>2015-10-20T13:44:35.000Z</updated>
    <content type="html"><![CDATA[<p>在这一章节，我们继续学习Android自定义控件。这里要自定义的是Android里面的一个常用控件-Android流式Tag布局，这里我们命名为：<a href="https://github.com/hanhailong/FlowTag/blob/master/library/src/main/java/com/hhl/library/FlowTagLayout.java" target="_blank" rel="external">FlowTagLayout</a>，我们要实现的流式布局，有如下特色：</p>
<ul>
<li>填充数据和ListView、GridView用法一样使用Adapter，更新数据直接通过adapter.notifyDataChanged来更新</li>
<li>支持点击、单选、多选三种模式：FLOW_TAG_CHECKED_NONE、FLOW_TAG_CHECKED_SINGLE、FLOW_TAG_CHECKED_MULTI</li>
</ul>
<h3>正式讲解之前先看下我们实现后的效果图：</h3>

<p> <img src="https://github.com/hanhailong/AndroidStudyResources/raw/master/screenshot/flow_tag.gif?raw=true" alt="image"></p>
<a id="more"></a>
<p>目前网上有很多的教程来写流式布局实现，我看到的版本大体上有两种，一种是继承<font color="red">ViewGroup</font>，然后重写其<font color="red">onMeasure</font>和<font color="red">onLayout</font>方法，另一种则是继承自<font color="red">RelativeLayout</font>，例如这个<a href="https://github.com/kaedea/Android-Cloud-TagView-Plus/blob/master/library/src/main/java/me/kaede/tagview/TagView.java" target="_blank" rel="external">TagView</a></p>
<p>而我们这里采用的是第一种方法，因为我感觉第一种方法简单、清晰、明了！！</p>
<p>因为我们直接继承的<em>ViewGroup</em>，所以要指定它的<em>LayoutParams</em>，这里因为只需要margin，所以我们直接返回<em>MarginLayoutParams</em>就可以了，代码如下：</p>
<pre><code><span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> MarginLayoutParams(getContext(), attrs);
    }
</code></pre><h3>onMeasure测量</h3>

<pre><code>@<span class="function">Override
    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>{
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);

        <span class="comment">//获取Padding</span>
        <span class="comment">// 获得它的父容器为它设置的测量模式和大小</span>
        <span class="keyword">int</span> sizeWidth = MeasureSpec.getSize(widthMeasureSpec);
        <span class="keyword">int</span> sizeHeight = MeasureSpec.getSize(heightMeasureSpec);
        <span class="keyword">int</span> modeWidth = MeasureSpec.getMode(widthMeasureSpec);
        <span class="keyword">int</span> modeHeight = MeasureSpec.getMode(heightMeasureSpec);

        <span class="comment">//FlowLayout最终的宽度和高度值</span>
        <span class="keyword">int</span> resultWidth = <span class="number">0</span>;
        <span class="keyword">int</span> resultHeight = <span class="number">0</span>;

        <span class="comment">//测量时每一行的宽度</span>
        <span class="keyword">int</span> lineWidth = <span class="number">0</span>;
        <span class="comment">//测量时每一行的高度，加起来就是FlowLayout的高度</span>
        <span class="keyword">int</span> lineHeight = <span class="number">0</span>;

        <span class="comment">//遍历每个子元素</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, childCount = getChildCount(); i &lt; childCount; i++) {
            View childView = getChildAt(i);
            <span class="comment">//测量每一个子view的宽和高</span>
            measureChild(childView, widthMeasureSpec, heightMeasureSpec);

            <span class="comment">//获取到测量的宽和高</span>
            <span class="keyword">int</span> childWidth = childView.getMeasuredWidth();
            <span class="keyword">int</span> childHeight = childView.getMeasuredHeight();

            <span class="comment">//因为子View可能设置margin，这里要加上margin的距离</span>
            MarginLayoutParams mlp = (MarginLayoutParams) childView.getLayoutParams();
            <span class="keyword">int</span> realChildWidth = childWidth + mlp.leftMargin + mlp.rightMargin;
            <span class="keyword">int</span> realChildHeight = childHeight + mlp.topMargin + mlp.bottomMargin;

            <span class="comment">//如果当前一行的宽度加上要加入的子view的宽度大于父容器给的宽度，就换行</span>
            <span class="keyword">if</span> ((lineWidth + realChildWidth) &gt; sizeWidth) {
                <span class="comment">//换行</span>
                resultWidth = Math.max(lineWidth, realChildWidth);
                resultHeight += realChildHeight;
                <span class="comment">//换行了，lineWidth和lineHeight重新算</span>
                lineWidth = realChildWidth;
                lineHeight = realChildHeight;
            } <span class="keyword">else</span> {
                <span class="comment">//不换行，直接相加</span>
                lineWidth += realChildWidth;
                <span class="comment">//每一行的高度取二者最大值</span>
                lineHeight = Math.max(lineHeight, realChildHeight);
            }

            <span class="comment">//遍历到最后一个的时候，肯定走的是不换行</span>
            <span class="keyword">if</span> (i == childCount - <span class="number">1</span>) {
                resultWidth = Math.max(lineWidth, resultWidth);
                resultHeight += lineHeight;
            }

            setMeasuredDimension(modeWidth == MeasureSpec.EXACTLY ? sizeWidth : resultWidth,
                    modeHeight == MeasureSpec.EXACTLY ? sizeHeight : resultHeight);

        }

    }
</code></pre><p>代码注释的很详细，首先得到其父容器传入的测量模式和宽高的计算值，然后遍历所有的childView，使用measureChild方法对所有的childView进行测量。然后根据所有childView的测量得出的宽和高得到该ViewGroup如果设置为wrap_content时的宽和高</p>
<h3>onLayout</h3>

<pre><code>@<span class="function">Override
<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(boolean changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>{

    <span class="keyword">int</span> flowWidth = getWidth();

    <span class="keyword">int</span> childLeft = <span class="number">0</span>;
    <span class="keyword">int</span> childTop = <span class="number">0</span>;

    <span class="comment">//遍历子控件，记录每个子view的位置</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, childCount = getChildCount(); i &lt; childCount; i++) {
        View childView = getChildAt(i);

        <span class="comment">//跳过View.GONE的子View</span>
        <span class="keyword">if</span> (childView.getVisibility() == View.GONE) {
            <span class="keyword">continue</span>;
        }

        <span class="comment">//获取到测量的宽和高</span>
        <span class="keyword">int</span> childWidth = childView.getMeasuredWidth();
        <span class="keyword">int</span> childHeight = childView.getMeasuredHeight();

        <span class="comment">//因为子View可能设置margin，这里要加上margin的距离</span>
        MarginLayoutParams mlp = (MarginLayoutParams) childView.getLayoutParams();

        <span class="keyword">if</span> (childLeft + mlp.leftMargin + childWidth + mlp.rightMargin &gt; flowWidth) {
            <span class="comment">//换行处理</span>
            childTop += (mlp.topMargin + childHeight + mlp.bottomMargin);
            childLeft = <span class="number">0</span>;
        }
        <span class="comment">//布局</span>
        <span class="keyword">int</span> left = childLeft + mlp.leftMargin;
        <span class="keyword">int</span> top = childTop + mlp.topMargin;
        <span class="keyword">int</span> right = childLeft + mlp.leftMargin + childWidth;
        <span class="keyword">int</span> bottom = childTop + mlp.topMargin + childHeight;
        childView.layout(left, top, right, bottom);

        childLeft += (mlp.leftMargin + childWidth + mlp.rightMargin);
    }
}
</code></pre><p>onLayout方法就是将子View摆放到FlowTagLayout中，核心就是childView.layout(l,t,r,b)方法。</p>
<p>测量完了，布局也完了，下面就是填充数据了，我们这里采用的是Adapter模式，用法基本上和我们常用的ListView、GridView一样，用户只要写一个适配器Adapter，然后调用xxx.setAdapter方法，就把数据源绑到控件上了，而且这种做法还有个好处：子View可以是任意类型的控件</p>
<h3>填充数据和ListView、GridView用法一样使用Adapter，更新数据直接通过adapter.notifyDataChanged来更新</h3>

<p>我研究了下ListView和GridView的adapter.notifyDataChanged实现，一句话：观察者模式！首先，我们要在<em>FlowTagLayout</em>里面注册一个观察者，当我们调用adapter.notifyDataChanged的时候能通知这个观察者来刷新页面。</p>
<pre><code><span class="comment">/**
     * 像ListView、GridView一样使用FlowLayout
     *
     * <span class="doctag">@param</span> adapter
     */</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(ListAdapter adapter)</span> </span>{
        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span> &amp;&amp; mDataSetObserver != <span class="keyword">null</span>) {
            mAdapter.unregisterDataSetObserver(mDataSetObserver);
        }

        <span class="comment">//清除现有的数据</span>
        removeAllViews();
        mAdapter = adapter;

        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) {
            mDataSetObserver = <span class="keyword">new</span> AdapterDataSetObserver();
            mAdapter.registerDataSetObserver(mDataSetObserver);
        }
    }
</code></pre><p> 方法                mAdapter.registerDataSetObserver(mDataSetObserver);<br>就注册了观察者，我们继续看：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">AdapterDataSetObserver</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">DataSetObserver</span> {</span>
        <span class="annotation">@Override</span>
        public void onChanged() {
            <span class="keyword">super</span>.onChanged();
            reloadData();
        }

        <span class="annotation">@Override</span>
        public void onInvalidated() {
            <span class="keyword">super</span>.onInvalidated();
        }
    }
</code></pre><p>当我们调用adapter.notifyDataChanged方法的时候，就会执行<em>onChanged</em>这个方法，我加了一个<em>reloadData</em>方法：</p>
<pre><code><span class="comment">/**
     * 重新加载刷新数据
     */</span>
    <span class="keyword">private</span> <span class="keyword">void</span> reloadData() {
        removeAllViews();

        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; mAdapter.getCount(); i++) {
            <span class="keyword">final</span> <span class="built_in">int</span> j = i;
            mCheckedTagArray.put(i, <span class="keyword">false</span>);
            <span class="keyword">final</span> View childView = mAdapter.getView(i, <span class="keyword">null</span>, <span class="keyword">this</span>);
            addView(childView, <span class="keyword">new</span> MarginLayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
            <span class="keyword">final</span> <span class="built_in">int</span> finalI = i;
            childView.setOnClickListener(<span class="keyword">new</span> OnClickListener() {
                @Override
                <span class="keyword">public</span> <span class="keyword">void</span> onClick(View v) {
                    <span class="keyword">if</span> (mTagCheckMode == FLOW_TAG_CHECKED_NONE) {
                        <span class="keyword">if</span> (mOnTagClickListener != <span class="keyword">null</span>) {
                            mOnTagClickListener.onItemClick(FlowTagLayout.<span class="keyword">this</span>, childView, j);
                        }
                    } <span class="keyword">else</span> <span class="keyword">if</span> (mTagCheckMode == FLOW_TAG_CHECKED_SINGLE) {
                        <span class="comment">//判断状态</span>
                        <span class="keyword">if</span> (mCheckedTagArray.<span class="built_in">get</span>(j)) {
                            mCheckedTagArray.put(j, <span class="keyword">false</span>);
                            childView.setSelected(<span class="keyword">false</span>);
                            <span class="keyword">if</span> (mOnTagSelectListener != <span class="keyword">null</span>) {
                                mOnTagSelectListener.onItemSelect(FlowTagLayout.<span class="keyword">this</span>, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());
                            }
                            <span class="keyword">return</span>;
                        }

                        <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; mAdapter.getCount(); k++) {
                            mCheckedTagArray.put(k, <span class="keyword">false</span>);
                            getChildAt(k).setSelected(<span class="keyword">false</span>);
                        }
                        mCheckedTagArray.put(j, <span class="keyword">true</span>);
                        childView.setSelected(<span class="keyword">true</span>);

                        <span class="keyword">if</span> (mOnTagSelectListener != <span class="keyword">null</span>) {
                            mOnTagSelectListener.onItemSelect(FlowTagLayout.<span class="keyword">this</span>, Arrays.asList(j));
                        }
                    } <span class="keyword">else</span> <span class="keyword">if</span> (mTagCheckMode == FLOW_TAG_CHECKED_MULTI) {
                        <span class="keyword">if</span> (mCheckedTagArray.<span class="built_in">get</span>(j)) {
                            mCheckedTagArray.put(j, <span class="keyword">false</span>);
                            childView.setSelected(<span class="keyword">false</span>);
                        } <span class="keyword">else</span> {
                            mCheckedTagArray.put(j, <span class="keyword">true</span>);
                            childView.setSelected(<span class="keyword">true</span>);
                        }
                        <span class="comment">//回调</span>
                        <span class="keyword">if</span> (mOnTagSelectListener != <span class="keyword">null</span>) {
                            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();
                            <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; mAdapter.getCount(); k++) {
                                <span class="keyword">if</span> (mCheckedTagArray.<span class="built_in">get</span>(k)) {
                                    list.<span class="built_in">add</span>(k);
                                }
                            }
                            mOnTagSelectListener.onItemSelect(FlowTagLayout.<span class="keyword">this</span>, list);
                        }
                    }
                }
            });
        }
    }
</code></pre><p>这个方法的作用就是重新加载子View，先是移除所有的子View，然后从<em>Adapter</em>中获取子View，addView到FlowTagLayout中，在这个过程中，我们给每个子View添加了点击事件，点击事件里面的逻辑很简单，就是根据<em>FlowTagLayout</em>的三种模式分别处理单击、单选、多选逻辑，三种模式分别为：</p>
<pre><code><span class="comment">/**
     * FlowLayout not support checked
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLOW_TAG_CHECKED_NONE = <span class="number">0</span>;
    <span class="comment">/**
     * FlowLayout support single-select
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLOW_TAG_CHECKED_SINGLE = <span class="number">1</span>;
    <span class="comment">/**
     * FlowLayout support multi-select
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLOW_TAG_CHECKED_MULTI = <span class="number">2</span>;
</code></pre><p>为了使单击、单选、多选事件通知到Activity、Fragment，我们加入了两个监听方法：</p>
<pre><code><span class="comment">/**
 * Created by HanHailong on 15/10/20.
 */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">OnTagClickListener</span> {
    <span class="function"><span class="keyword">void</span> <span class="title">onItemClick</span>(<span class="params">FlowTagLayout parent, View view, <span class="keyword">int</span> position</span>)</span>;
}
</code></pre><p>和</p>
<pre><code><span class="comment">/**
 * Created by HanHailong on 15/10/20.
 */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">OnTagSelectListener</span> {
    <span class="function"><span class="keyword">void</span> <span class="title">onItemSelect</span>(<span class="params">FlowTagLayout parent, List&lt;Integer&gt; selectedList</span>)</span>;
}
</code></pre><p>改写的都写了，我们怎么使用呢？请继续往下看</p>
<h3>用法</h3>

<p>首先，我们先写一个适配器<em>TagAdapter</em>，写法完全和写ListView的适配器一样：</p>
<pre><code><span class="comment">/**
 * Created by HanHailong on 15/10/19.
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TagAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>{

    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;
    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; mDataList;

    <span class="function"><span class="keyword">public</span> <span class="title">TagAdapter</span><span class="params">(Context context)</span> </span>{
        <span class="keyword">this</span>.mContext = context;
        mDataList = <span class="keyword">new</span> ArrayList&lt;&gt;();
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>{
        <span class="function"><span class="keyword">return</span> mDataList.<span class="title">size</span><span class="params">()</span></span>;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">Object <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>{
        <span class="function"><span class="keyword">return</span> mDataList.<span class="title">get</span><span class="params">(position)</span></span>;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>{
        <span class="keyword">return</span> position;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>{

        View view = LayoutInflater.from(mContext).inflate(R.layout.tag_item, <span class="keyword">null</span>);

        TextView textView = (TextView) view.findViewById(R.id.tv_tag);
        T t = mDataList.get(position);

        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> String) {
            textView.setText((String) t);
        }
        <span class="keyword">return</span> view;
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onlyAddAll</span><span class="params">(List&lt;T&gt; datas)</span> </span>{
        mDataList.addAll(datas);
        notifyDataSetChanged();
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">clearAndAddAll</span><span class="params">(List&lt;T&gt; datas)</span> </span>{
        mDataList.clear();
        onlyAddAll(datas);
    }
}
</code></pre><h4>布局tag_item.xml</h4>

<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>&gt;</span>

    <span class="tag">&lt;<span class="title">TextView</span>
        <span class="attribute">android:id</span>=<span class="value">"@+id/tv_tag"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_marginLeft</span>=<span class="value">"10dp"</span>
        <span class="attribute">android:layout_marginTop</span>=<span class="value">"10dp"</span>
        <span class="attribute">android:background</span>=<span class="value">"@drawable/round_rectangle_bg"</span>
        <span class="attribute">android:paddingBottom</span>=<span class="value">"5dp"</span>
        <span class="attribute">android:paddingLeft</span>=<span class="value">"10dp"</span>
        <span class="attribute">android:paddingRight</span>=<span class="value">"10dp"</span>
        <span class="attribute">android:paddingTop</span>=<span class="value">"5dp"</span>
        <span class="attribute">android:text</span>=<span class="value">"TAG标签"</span>
        <span class="attribute">android:textColor</span>=<span class="value">"@color/normal_text_color"</span> /&gt;</span>

<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>再看我们引用<em>FlowTagLayout</em>的主布局代码：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">ScrollView</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">xmlns:app</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span>
    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>
    <span class="attribute">android:fillViewport</span>=<span class="value">"true"</span>
    <span class="attribute">app:layout_behavior</span>=<span class="value">"@string/appbar_scrolling_view_behavior"</span>
    <span class="attribute">tools:context</span>=<span class="value">".MainActivity"</span>
    <span class="attribute">tools:showIn</span>=<span class="value">"@layout/activity_main"</span>&gt;</span>

    <span class="tag">&lt;<span class="title">LinearLayout</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>
        <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
        <span class="attribute">android:paddingBottom</span>=<span class="value">"30dp"</span>&gt;</span>

        <span class="tag">&lt;<span class="title">LinearLayout</span>
            <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
            <span class="attribute">android:orientation</span>=<span class="value">"horizontal"</span>&gt;</span>

            <span class="tag">&lt;<span class="title">TextView</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_margin</span>=<span class="value">"10dp"</span>
                <span class="attribute">android:text</span>=<span class="value">"颜色\n(点击)"</span> /&gt;</span>

            <span class="tag">&lt;<span class="title">com.hhl.library.FlowTagLayout</span>
                <span class="attribute">android:id</span>=<span class="value">"@+id/color_flow_layout"</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>

        <span class="tag">&lt;<span class="title">LinearLayout</span>
            <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
            <span class="attribute">android:layout_marginTop</span>=<span class="value">"10dp"</span>
            <span class="attribute">android:orientation</span>=<span class="value">"horizontal"</span>&gt;</span>

            <span class="tag">&lt;<span class="title">TextView</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_margin</span>=<span class="value">"10dp"</span>
                <span class="attribute">android:text</span>=<span class="value">"尺寸\n(单选)"</span> /&gt;</span>

            <span class="tag">&lt;<span class="title">com.hhl.library.FlowTagLayout</span>
                <span class="attribute">android:id</span>=<span class="value">"@+id/size_flow_layout"</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>

        <span class="tag">&lt;<span class="title">LinearLayout</span>
            <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
            <span class="attribute">android:layout_marginTop</span>=<span class="value">"10dp"</span>
            <span class="attribute">android:orientation</span>=<span class="value">"horizontal"</span>&gt;</span>

            <span class="tag">&lt;<span class="title">TextView</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_margin</span>=<span class="value">"10dp"</span>
                <span class="attribute">android:text</span>=<span class="value">"移动\n(多选)"</span> /&gt;</span>

            <span class="tag">&lt;<span class="title">com.hhl.library.FlowTagLayout</span>
                <span class="attribute">android:id</span>=<span class="value">"@+id/mobile_flow_layout"</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>

    <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>

<span class="tag">&lt;/<span class="title">ScrollView</span>&gt;</span>
</code></pre><p>最后，我们看Activity里面是怎么使用的：</p>
<pre><code><span class="keyword">package</span> com.hhl.flowlayoutdemo;

<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.support.design.widget.FloatingActionButton;
<span class="keyword">import</span> android.support.design.widget.Snackbar;
<span class="keyword">import</span> android.support.v7.app.AppCompatActivity;
<span class="keyword">import</span> android.support.v7.widget.Toolbar;
<span class="keyword">import</span> android.view.Menu;
<span class="keyword">import</span> android.view.MenuItem;
<span class="keyword">import</span> android.view.View;

<span class="keyword">import</span> com.hhl.library.FlowTagLayout;
<span class="keyword">import</span> com.hhl.library.OnTagClickListener;
<span class="keyword">import</span> com.hhl.library.OnTagSelectListener;

<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.List;

<span class="keyword">public</span> class MainActivity extends AppCompatActivity {

    <span class="keyword">private</span> FlowTagLayout mColorFlowTagLayout;
    <span class="keyword">private</span> FlowTagLayout mSizeFlowTagLayout;
    <span class="keyword">private</span> FlowTagLayout mMobileFlowTagLayout;
    <span class="keyword">private</span> TagAdapter&lt;<span class="keyword">String</span>&gt; mSizeTagAdapter;
    <span class="keyword">private</span> TagAdapter&lt;<span class="keyword">String</span>&gt; mColorTagAdapter;
    <span class="keyword">private</span> TagAdapter&lt;<span class="keyword">String</span>&gt; mMobileTagAdapter;

    @Override
    <span class="keyword">protected</span> <span class="keyword">void</span> onCreate(Bundle savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
        fab.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
            @Override
            <span class="keyword">public</span> <span class="keyword">void</span> onClick(View view) {
                Snackbar.make(view, <span class="string">"Replace with your own action"</span>, Snackbar.LENGTH_LONG)
                        .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
            }
        });

        mColorFlowTagLayout = (FlowTagLayout) findViewById(R.id.color_flow_layout);
        mSizeFlowTagLayout = (FlowTagLayout) findViewById(R.id.size_flow_layout);
        mMobileFlowTagLayout = (FlowTagLayout) findViewById(R.id.mobile_flow_layout);

        <span class="comment">//颜色</span>
        mColorTagAdapter = <span class="keyword">new</span> TagAdapter&lt;&gt;(<span class="keyword">this</span>);
        mColorFlowTagLayout.setAdapter(mColorTagAdapter);
        mColorFlowTagLayout.setOnTagClickListener(<span class="keyword">new</span> OnTagClickListener() {
            @Override
            <span class="keyword">public</span> <span class="keyword">void</span> onItemClick(FlowTagLayout parent, View view, <span class="built_in">int</span> position) {
                Snackbar.make(view, <span class="string">"颜色:"</span> + parent.getAdapter().getItem(position), Snackbar.LENGTH_LONG)
                        .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
            }
        });

        <span class="comment">//尺寸</span>
        mSizeTagAdapter = <span class="keyword">new</span> TagAdapter&lt;&gt;(<span class="keyword">this</span>);
        mSizeFlowTagLayout.setTagCheckedMode(FlowTagLayout.FLOW_TAG_CHECKED_SINGLE);
        mSizeFlowTagLayout.setAdapter(mSizeTagAdapter);
        mSizeFlowTagLayout.setOnTagSelectListener(<span class="keyword">new</span> OnTagSelectListener() {
            @Override
            <span class="keyword">public</span> <span class="keyword">void</span> onItemSelect(FlowTagLayout parent, List&lt;Integer&gt; selectedList) {
                <span class="keyword">if</span> (selectedList != <span class="keyword">null</span> &amp;&amp; selectedList.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {
                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();
                    <span class="keyword">for</span> (<span class="built_in">int</span> i : selectedList) {
                        sb.<span class="built_in">append</span>(parent.getAdapter().getItem(i));
                        sb.<span class="built_in">append</span>(<span class="string">":"</span>);
                    }
                    Snackbar.make(parent, <span class="string">"移动研发:"</span> + sb.toString(), Snackbar.LENGTH_LONG)
                            .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
                }<span class="keyword">else</span>{
                    Snackbar.make(parent, <span class="string">"没有选择标签"</span>, Snackbar.LENGTH_LONG)
                            .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
                }
            }
        });

        <span class="comment">//移动研发标签</span>
        mMobileTagAdapter = <span class="keyword">new</span> TagAdapter&lt;&gt;(<span class="keyword">this</span>);
        mMobileFlowTagLayout.setTagCheckedMode(FlowTagLayout.FLOW_TAG_CHECKED_MULTI);
        mMobileFlowTagLayout.setAdapter(mMobileTagAdapter);
        mMobileFlowTagLayout.setOnTagSelectListener(<span class="keyword">new</span> OnTagSelectListener() {
            @Override
            <span class="keyword">public</span> <span class="keyword">void</span> onItemSelect(FlowTagLayout parent, List&lt;Integer&gt; selectedList) {
                <span class="keyword">if</span> (selectedList != <span class="keyword">null</span> &amp;&amp; selectedList.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {
                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();

                    <span class="keyword">for</span> (<span class="built_in">int</span> i : selectedList) {
                        sb.<span class="built_in">append</span>(parent.getAdapter().getItem(i));
                        sb.<span class="built_in">append</span>(<span class="string">":"</span>);
                    }
                    Snackbar.make(parent, <span class="string">"移动研发:"</span> + sb.toString(), Snackbar.LENGTH_LONG)
                            .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
                }<span class="keyword">else</span>{
                    Snackbar.make(parent, <span class="string">"没有选择标签"</span>, Snackbar.LENGTH_LONG)
                            .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
                }
            }
        });

        initColorData();

        initSizeData();

        initMobileData();
    }

    <span class="keyword">private</span> <span class="keyword">void</span> initMobileData() {
        List&lt;<span class="keyword">String</span>&gt; dataSource = <span class="keyword">new</span> ArrayList&lt;&gt;();
        dataSource.<span class="built_in">add</span>(<span class="string">"android"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"安卓"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"SDK源码"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"IOS"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"iPhone"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"游戏"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"fragment"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"viewcontroller"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"cocoachina"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"移动研发工程师"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"移动互联网"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"高薪+期权"</span>);
        mMobileTagAdapter.onlyAddAll(dataSource);
    }

    <span class="keyword">private</span> <span class="keyword">void</span> initColorData() {
        List&lt;<span class="keyword">String</span>&gt; dataSource = <span class="keyword">new</span> ArrayList&lt;&gt;();
        dataSource.<span class="built_in">add</span>(<span class="string">"红色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"黑色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"花边色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"深蓝色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"白色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"玫瑰红色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"紫黑紫兰色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"葡萄红色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"屎黄色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"绿色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"彩虹色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"牡丹色"</span>);
        mColorTagAdapter.onlyAddAll(dataSource);
    }

    <span class="comment">/**
     * 初始化数据
     */</span>
    <span class="keyword">private</span> <span class="keyword">void</span> initSizeData() {
        List&lt;<span class="keyword">String</span>&gt; dataSource = <span class="keyword">new</span> ArrayList&lt;&gt;();
        dataSource.<span class="built_in">add</span>(<span class="string">"28 (2.1尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"29 (2.2尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"30 (2.3尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"31 (2.4尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"32 (2.5尺)........"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"33 (2.6尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"34 (2.7尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"35 (2.8尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"36 (2.9尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"37 (3.0尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"38 (3.1尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"39 (3.2尺)........"</span>);
        mSizeTagAdapter.onlyAddAll(dataSource);
    }

    @Override
    <span class="keyword">public</span> <span class="built_in">boolean</span> onCreateOptionsMenu(Menu menu) {
        <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span>
        getMenuInflater().inflate(R.menu.menu_main, menu);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    @Override
    <span class="keyword">public</span> <span class="built_in">boolean</span> onOptionsItemSelected(MenuItem item) {
        <span class="comment">// Handle action bar item clicks here. The action bar will</span>
        <span class="comment">// automatically handle clicks on the Home/Up button, so long</span>
        <span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span>
        <span class="built_in">int</span> id = item.getItemId();

        <span class="comment">//noinspection SimplifiableIfStatement</span>
        <span class="keyword">if</span> (id == R.id.action_settings) {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }

        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);
    }
}
</code></pre><p>好了，一个简单而实用的流式标签就轻松搞定了！！</p>
<h3>TODO</h3>

<ul>
<li>添加初始化选中标签</li>
<li>添加tag样式支持（颜色、图标等等）</li>
<li>像ListView、GridView一样复用子View</li>
<li>其他…</li>
</ul>
<p>如果你觉得本篇博客对你有用，那么就留个言或者顶一个~~</p>
<p>最后，附上github源码<a href="https://github.com/hanhailong/FlowTag" target="_blank" rel="external">FlowTagLayout</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这一章节，我们继续学习Android自定义控件。这里要自定义的是Android里面的一个常用控件-Android流式Tag布局，这里我们命名为：<a href="https://github.com/hanhailong/FlowTag/blob/master/library/src/main/java/com/hhl/library/FlowTagLayout.java">FlowTagLayout</a>，我们要实现的流式布局，有如下特色：</p>
<ul>
<li>填充数据和ListView、GridView用法一样使用Adapter，更新数据直接通过adapter.notifyDataChanged来更新</li>
<li>支持点击、单选、多选三种模式：FLOW_TAG_CHECKED_NONE、FLOW_TAG_CHECKED_SINGLE、FLOW_TAG_CHECKED_MULTI</li>
</ul>
<h3>正式讲解之前先看下我们实现后的效果图：</h3>

<p> <img src="https://github.com/hanhailong/AndroidStudyResources/raw/master/screenshot/flow_tag.gif?raw=true" alt="image"></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Support Library 23.1 now available]]></title>
    <link href="http://hanhailong.com/2015/10/19/Android-Support-Library-23-1-now-available/"/>
    <id>http://hanhailong.com/2015/10/19/Android-Support-Library-23-1-now-available/</id>
    <published>2015-10-19T02:50:32.000Z</published>
    <updated>2015-10-19T03:14:48.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Support V4</strong> gets a number of important bug fixes as well as a few new features for NestedScrollView and around MediaSessionCompat.</p>
<p><strong>Media Router</strong> has gotten a design overhaul, making connecting and controlling remote devices such as Google Cast enabled devices even easier.</p>
<p><strong>RecyclerView</strong> has a significant <strong>backward incompatible</strong> change to the animation system, offering new flexibility and support for item content animations. You’ll find a SimpleItemAnimator helper class for easing the transition to the new animation system.</p>
<p><strong>AppCompat</strong> adds a new tint aware <em>Seekbar</em>, <em>ImageButton</em>, and <em>ImageView</em> and updating styling to <em>SwitchCompat</em>.</p>
<p><strong>Design</strong> improves TextInputLayout with support for character counting, the new <em>SCROLL_FLAG_SNAP</em> allows <em>AppBarLayout</em> children to snap completely on or off the screen when scrolling completes, and <em>NavigationView</em> now supports custom views for menu items.</p>
<p><strong>Percent</strong> adds support for <em>setting a custom aspect ratio</em> to both <em>PercentFrameLayout</em> and <em>PercentRelativeLayout</em>.</p>
<p><strong>Custom Tabs</strong> increases the customization available with the ability to hide the URL bar when scrolling down and change the custom action button for current custom tab session as well as the ability to receive tab shown and hidden events.</p>
<p><strong>Leanback</strong> updates <em>GuidedStepFragment</em> so it can be placed on top of existing content and adds new search completion type annotations for SearchFragment.﻿</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Support V4</strong> gets a number of important bug fixes as well as a few new features for NestedScrollView and around MediaSessi]]>
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
      <category term="Android咨询" scheme="http://hanhailong.com/tags/Android%E5%92%A8%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-一步一步教你自定义IOS样式的UISwitch]]></title>
    <link href="http://hanhailong.com/2015/10/17/Android-%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89IOS%E6%A0%B7%E5%BC%8F%E7%9A%84UISwitch/"/>
    <id>http://hanhailong.com/2015/10/17/Android-一步一步教你自定义IOS样式的UISwitch/</id>
    <published>2015-10-17T13:08:13.000Z</published>
    <updated>2015-10-18T16:59:54.000Z</updated>
    <content type="html"><![CDATA[<p>在这一章节，我们将开始在Android上做一个IOS风格的UISwitch控件。这篇文章主要涉及如下知识点：</p>
<ol>
<li>Android属性动画Animator</li>
<li>自定义手势GestureDetector</li>
<li>自定义View属性attrs</li>
</ol>
<p>首先，让我们来看一下效果图：</p>
<p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/uiswitch.gif?raw=true" alt="uiswitch"></p>
<a id="more"></a>
<h3>自定义View属性</h3>

<p>接下来，我们要先新建<font color="red">IOSSwitchView</font>类，继承自View类，重写其构造方法，代码如下：</p>
<pre><code><span class="comment">/**
 * 高仿IOS风格的UISwitchView
 * Created by HanHailong on 15/10/15.
 */</span>
public <span class="class"><span class="keyword">class</span> <span class="title">IOSSwitchView</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">View</span> {</span>
    public <span class="type">IOSSwitchView</span>(<span class="type">Context</span> context) {
        <span class="keyword">this</span>(context, <span class="literal">null</span>);
    }

    public <span class="type">IOSSwitchView</span>(<span class="type">Context</span> context, <span class="type">AttributeSet</span> attrs) {
        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);
    }

    public <span class="type">IOSSwitchView</span>(<span class="type">Context</span> context, <span class="type">AttributeSet</span> attrs, int defStyleAttr) {
        <span class="keyword">super</span>(context, attrs, defStyleAttr);
        init(context, attrs);
    }
}
</code></pre><p>然后，自定义我们需要的View属性，代码如下：</p>
<!-- IOSSwitchView -->
<pre><code><span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"IOSSwitchView"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"tintColor"</span> <span class="attribute">format</span>=<span class="value">"reference|color"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"thumbTintColor"</span> <span class="attribute">format</span>=<span class="value">"reference|color"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"strokeWidth"</span> <span class="attribute">format</span>=<span class="value">"reference|dimension"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"isOn"</span> <span class="attribute">format</span>=<span class="value">"reference|boolean"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span>
</code></pre><p>其中，<font color="red">tintColor</font>是Switch控件选中的颜色，，<font color="red">thumbTintColor</font>是里面可拖动开关扳手的颜色，，<font color="red">strokeWidth</font>是开关扳手的外边距宽度，<font color="red">isOn</font>是开关的打开状态，true是打开状态，false是关闭状态。</p>
<p>代码里怎么接收在布局里设置的属性值呢？答案：<font color="red">TypedArray</font>，我们继续看代码：</p>
<pre><code><span class="title">TypedArray</span> a = context.obtainStyledAttributes(attrs, R.styleable.IOSSwitchView);
       <span class="title">mTintColor</span> = a.getColor(R.styleable.IOSSwitchView_tintColor, Color.GREEN);
       <span class="title">mThumbTintColor</span> = a.getColor(R.styleable.IOSSwitchView_thumbTintColor, Color.WHITE);

       <span class="title">int</span> defaultStrokeWidth = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">1</span>.5f, context.getResources()
               .getDisplayMetrics());
       <span class="title">mStrokeWidth</span> = a.getDimensionPixelOffset(R.styleable.IOSSwitchView_strokeWidth, defaultStrokeWidth);
       <span class="title">isOn</span> = a.getBoolean(R.styleable.IOSSwitchView_isOn, <span class="built_in">false</span>);
</code></pre><p>上面的代码都很简单，都是自定义View常规的步骤，接下来我们再看添加动画的代码，看我们的gif效果图，你会发现，中间的开关把手在你手指点击它（此时没松手）的时候，它会有一个拉伸的动画，松手的时候，它会移动到另一侧，所以我们这里需要两个属性动画，一个是：拉伸动画，一个是移动动画。另外，因为我们这里有个背景颜色的变化：在默认关闭的情况下，背景色是灰白色的，打开的情况下是我们设置的tintColor颜色的，这里我们采用的是画了两个圆角矩形实现的，先画的tintColor颜色的圆角矩形，后画的灰白色的圆角矩形，刚开始开关关闭的时候灰白色的圆角矩形完全覆盖在上面，此时它的大小和它下面的矩形大小是一样的，之后在我们打开开关thumb的时候，灰白色的圆角矩形大小变成0，这样我们就看到tintColor颜色的圆角矩形了，这就实现了我们的背景切换。所以，这里又加了一个属性动画：灰白色圆角矩形的放大缩小动画。介绍到这里，我们总算理清了，我们要实现三个动画：一个thumb拉伸动画、一个thumb位移动画、一个灰白色圆角矩形形变动画（放大缩小动画）。这里我们添加初始化动画代码：</p>
<pre><code><span class="comment">//灰白色矩形形变动画</span>
        mInnerContentAnimator = ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="keyword">new</span> Property&lt;IOSSwitchView, Float&gt;(Float.class, <span class="string">"innerbound"</span>) {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">IOSSwitchView <span class="keyword">object</span>, Float <span class="keyword">value</span></span>) </span>{
                <span class="keyword">object</span>.setInnerContentRate(<span class="keyword">value</span>);
            }

            @<span class="function">Override
            <span class="keyword">public</span> Float <span class="title">get</span>(<span class="params">IOSSwitchView <span class="keyword">object</span></span>) </span>{
                <span class="keyword">return</span> <span class="keyword">object</span>.getInnerContentRate();
            }
        }, innerContentRate, <span class="number">1.0</span>f);
        mInnerContentAnimator.setDuration(<span class="number">300</span>);
        mInnerContentAnimator.setInterpolator(<span class="keyword">new</span> DecelerateInterpolator());

        <span class="comment">//thumb拉伸动画</span>
        mThumbExpandAnimator = ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="keyword">new</span> Property&lt;IOSSwitchView, Float&gt;(Float.class, <span class="string">"thumbExpand"</span>) {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">IOSSwitchView <span class="keyword">object</span>, Float <span class="keyword">value</span></span>) </span>{
                <span class="keyword">object</span>.setThumbExpandRate(<span class="keyword">value</span>);
            }

            @<span class="function">Override
            <span class="keyword">public</span> Float <span class="title">get</span>(<span class="params">IOSSwitchView <span class="keyword">object</span></span>) </span>{
                <span class="keyword">return</span> <span class="keyword">object</span>.getThumbExpandRate();
            }
        }, thumbExpandRate, <span class="number">1.0</span>f);
        mThumbExpandAnimator.setDuration(<span class="number">300</span>);
        mThumbExpandAnimator.setInterpolator(<span class="keyword">new</span> DecelerateInterpolator());

        <span class="comment">//thumb位移动画</span>
        mThumbMoveAnimator = ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="keyword">new</span> Property&lt;IOSSwitchView, Float&gt;(Float.class, <span class="string">"thumbMove"</span>) {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">IOSSwitchView <span class="keyword">object</span>, Float <span class="keyword">value</span></span>) </span>{
                <span class="keyword">object</span>.setThumbMoveRate(<span class="keyword">value</span>);
            }

            @<span class="function">Override
            <span class="keyword">public</span> Float <span class="title">get</span>(<span class="params">IOSSwitchView <span class="keyword">object</span></span>) </span>{
                <span class="keyword">return</span> <span class="keyword">object</span>.getThumbMoveRate();
            }
        }, thumbMoveRate, <span class="number">1.0</span>f);
        mThumbMoveAnimator.setDuration(<span class="number">300</span>);
        mThumbMoveAnimator.setInterpolator(<span class="keyword">new</span> DecelerateInterpolator());
</code></pre><p>初始化完三个属性动画后，我们下一步就该初始化滑动手势了，因为我们的<font color="red">IOSSwitchView</font>支持thumb滑动而改变打开关闭状态，所以我们要添加支持滑动手势<font color="red">GestureDetector</font>代码：</p>
<pre><code><span class="comment">//手势</span>
        mGestureDetector = <span class="keyword">new</span> GestureDetector(context, <span class="keyword">new</span> GestureDetector.SimpleOnGestureListener() {
            @<span class="function">Override
            <span class="keyword">public</span> boolean <span class="title">onDown</span><span class="params">(MotionEvent e)</span> </span>{

                <span class="keyword">if</span> (!isEnabled()) <span class="keyword">return</span> <span class="literal">false</span>;

                preIsOn = isOn;

                <span class="comment">//灰白色矩形缩小到0</span>
                mInnerContentAnimator.setFloatValues(innerContentRate, <span class="number">0.0f</span>);
                mInnerContentAnimator.start();

                <span class="comment">//thumb有个拉伸的动作</span>
                mThumbExpandAnimator.setFloatValues(thumbExpandRate, <span class="number">1.0f</span>);
                mThumbExpandAnimator.start();

                <span class="keyword">return</span> <span class="literal">true</span>;
            }

            @<span class="function">Override
            <span class="keyword">public</span> boolean <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span> </span>{
                <span class="comment">//手指抬起执行一系列的动画</span>
                isOn = thumbState;

                <span class="keyword">if</span> (preIsOn == isOn) {<span class="comment">//反转</span>
                    isOn = !isOn;
                    thumbState = !thumbState;
                }

                <span class="comment">//打开状态</span>
                <span class="keyword">if</span> (thumbState) {
                    <span class="comment">//thumb移动到右侧打开区域</span>
                    mThumbMoveAnimator.setFloatValues(thumbMoveRate, <span class="number">1.0F</span>);
                    mThumbMoveAnimator.start();

                    <span class="comment">//灰白色圆角矩形缩小到0</span>
                    mInnerContentAnimator.setFloatValues(innerContentRate, <span class="number">0.0F</span>);
                    mInnerContentAnimator.start();
                } <span class="keyword">else</span> {<span class="comment">//关闭状态</span>
                    <span class="comment">//thumb移动到左侧关闭区域</span>
                    mThumbMoveAnimator.setFloatValues(thumbMoveRate, <span class="number">0.0F</span>);
                    mThumbMoveAnimator.start();

                    <span class="comment">//灰白色圆角矩形放大到覆盖背景大小</span>
                    mInnerContentAnimator.setFloatValues(innerContentRate, <span class="number">1.0F</span>);
                    mInnerContentAnimator.start();
                }
                <span class="comment">//thumb恢复原大小</span>
                mThumbExpandAnimator.setFloatValues(thumbExpandRate, <span class="number">0.0F</span>);
                mThumbExpandAnimator.start();

                <span class="keyword">if</span> (mOnSwitchStateChangeListener != null &amp;&amp; preIsOn != isOn) {
                    mOnSwitchStateChangeListener.onStateSwitched(isOn);
                }

                <span class="keyword">return</span> <span class="literal">true</span>;
            }

            @<span class="function">Override
            <span class="keyword">public</span> boolean <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)</span> </span>{

                <span class="comment">//在打开开关的区域</span>
                <span class="keyword">if</span> (e2.getX() &gt; centerX) {
                    <span class="comment">//并且开关状态是关闭的，就执行打开开关操作</span>
                    <span class="keyword">if</span> (!thumbState) {
                        thumbState = !thumbState;

                        mThumbMoveAnimator.setFloatValues(thumbMoveRate, <span class="number">1.0F</span>);
                        mThumbMoveAnimator.start();

                        mInnerContentAnimator.setFloatValues(innerContentRate, <span class="number">0.0F</span>);
                        mInnerContentAnimator.start();
                    }
                } <span class="keyword">else</span> {<span class="comment">//在关闭区域</span>
                    <span class="comment">//开关处于打开状态</span>
                    <span class="keyword">if</span> (thumbState) {
                        thumbState = !thumbState;
                        <span class="comment">//执行关闭开关动画</span>
                        mThumbMoveAnimator.setFloatValues(thumbMoveRate, <span class="number">0.0F</span>);
                        mThumbMoveAnimator.start();
                    }
                }

                <span class="keyword">return</span> <span class="literal">true</span>;
            }

        });
        <span class="comment">//禁止长按</span>
        mGestureDetector.setIsLongpressEnabled(<span class="literal">false</span>);
</code></pre><p>因为<font color="red">OnGestureListener</font>里面的方法没必要都实现，我们这用的是它的子静态类<font color="red">SimpleOnGestureListener</font>，我们重写了里面的<font color="red">onDown</font>、<font color="red">onSingleTapUp</font>、<font color="red">onScroll</font>方法。</p>
<font color="red">onDown</font>方法的作用就是在按下控件的时候，thumb执行一个拉伸动画，灰白色圆角矩形则执行缩小到0的动画。如下图所示：<br><br><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/uiswitch-expand.gif?raw=true" alt="switch-expand"><br><br><font color="red">onSingleTapUp</font>则是单点抬起手指后执行的操作，这里执行的就是开关互斥动画和互斥逻辑，之前如果是打开的状态，就变成关闭状态，相反则反之。。。<br><br><font color="red">onScroll</font>方法则是手指滑动时的坐标大于中间X时则执行一个选中动画，相反则反之…<br><br>手势识别添加完后，我们为了保证控件有一个好的UI效果展示，一般指控件的宽度和高度保持一个比例，我们重写其<font color="red">onMeasure</font>方法，添加如下代码：<br><br>        @Override<br>        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {<br>            super.onMeasure(widthMeasureSpec, heightMeasureSpec);<br><br>            //测量宽度和高度<br>            width = MeasureSpec.getSize(widthMeasureSpec);<br>            height = MeasureSpec.getSize(heightMeasureSpec);<br><br>            //保持一定的宽高比例<br>            if ((float) height / (float) width &lt; 0.5f) {<br>                height = (int) (width <em> 0.5);<br><br>                heightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.getMode(heightMeasureSpec));<br>                widthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.getMode(widthMeasureSpec));<br>                super.setMeasuredDimension(widthMeasureSpec, heightMeasureSpec);<br>            }<br><br>            centerX = width </em> 0.5f;<br>            centerY = height <em> 0.5f;<br>            cornerRadius = centerY;<br><br>            innerContentRectF.left = mStrokeWidth;<br>            innerContentRectF.top = mStrokeWidth;<br>            innerContentRectF.right = width - mStrokeWidth;<br>            innerContentRectF.bottom = height - mStrokeWidth;<br><br>            intrinsicInnerWidth = innerContentRectF.width();<br>            intrinsicInnerHeight = innerContentRectF.height();<br><br>            thumbRectF.left = mStrokeWidth;<br>            thumbRectF.top = mStrokeWidth;<br>            thumbRectF.right = width - mStrokeWidth;<br>            thumbRectF.bottom = height - mStrokeWidth;<br><br>            intrinsicThumbWidth = thumbRectF.height();<br><br>            //thumb最大拉伸宽度<br>            thumbMaxExpandWidth = width </em> 0.7f;<br><br>            if (thumbMaxExpandWidth &gt; intrinsicThumbWidth <em> 1.25f) {<br>                thumbMaxExpandWidth = intrinsicThumbWidth </em> 1.25f;<br>            }<br>        }<br><br><br>测量完后，我们就开始执行最后一步也是最重要的一步：将控件画到画布canvas上，我们重写<font color="red">onDraw</font>方法：<br><br><br>        @Override<br>        protected void onDraw(Canvas canvas) {<br>        super.onDraw(canvas);<br><br>        float w = intrinsicInnerWidth <em> 0.5f </em> innerContentRate;<br>        float h = intrinsicInnerHeight <em> 0.5f </em> innerContentRate;<br><br>        this.innerContentRectF.left = centerX - w;<br>        this.innerContentRectF.top = centerY - h;<br>        this.innerContentRectF.right = centerX + w;<br>        this.innerContentRectF.bottom = centerY + h;<br><br>        //thumb拉伸宽度变化，其变化值从1-&gt;1.7之间<br>        w = intrinsicThumbWidth + (thumbMaxExpandWidth - intrinsicThumbWidth) <em> thumbExpandRate;<br><br>        boolean left = thumbRectF.left + thumbRectF.width() </em> 0.5f &lt; centerX;<br>        if (left) {<br>            thumbRectF.left = thumbRectF.right - w;<br>        } else {<br>            thumbRectF.right = thumbRectF.left + w;<br>        }<br><br>        float kw = thumbRectF.width();<br>        w = (float) (width - kw - (mStrokeWidth <em> 2)) </em> thumbMoveRate;<br><br>        thumbRectF.left = mStrokeWidth + w;<br>        thumbRectF.right = thumbRectF.left + kw;<br><br>        //颜色值过渡变化，从深灰白色变化到tintColor色<br>        this.colorStep = transformRGBColor(thumbMoveRate, backgroundColor, mTintColor);<br><br>        //画TintColor颜色的圆角矩形<br>        mPaint.setColor(colorStep);<br>        mPaint.setStyle(Paint.Style.FILL_AND_STROKE);<br>        drawRoundRect(0, 0, width, height, cornerRadius, canvas, mPaint);<br><br>        mPaint.setColor(foregroundColor);<br>        //画灰白色圆角矩形<br>        canvas.drawRoundRect(innerContentRectF, innerContentRectF.height() <em> 0.5f, innerContentRectF.height() </em> 0.5f, mPaint);<br><br>        //画thumb<br>        mPaint.setColor(mThumbTintColor);<br>        canvas.drawRoundRect(thumbRectF, cornerRadius, cornerRadius, mPaint);<br><br>        mPaint.setColor(0xFFCCCCCC);<br>        mPaint.setStyle(Paint.Style.STROKE);<br>        mPaint.setStrokeWidth(1);<br>        canvas.drawRoundRect(thumbRectF, cornerRadius, cornerRadius, mPaint);<br>        }<br><br><br><font color="red">onDraw</font>方法执行了四步绘制：四次绘制圆角矩形，第一次绘制背景tintColor颜色的圆角矩形，第二次绘制灰白色覆盖在上面的圆角矩形，第三次绘制thumb，第四次绘制一个空心的圆角矩形，这个是为了加深thumb和周围的颜色区分。<br><br>其中，里面有个方法<font color="red"> transformRGBColor </font>

<pre><code><span class="comment">/**
     * RGB颜色过渡变化
     *
     * @param progress
     * @param fromColor
     * @param toColor
     * @return
     */</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">transformRGBColor</span><span class="params">(<span class="keyword">float</span> progress, <span class="keyword">int</span> fromColor, <span class="keyword">int</span> toColor)</span> </span>{
        <span class="keyword">int</span> fr = (fromColor &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;
        <span class="keyword">int</span> fg = (fromColor &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;
        <span class="keyword">int</span> fb = fromColor &amp; <span class="number">0xFF</span>;

        <span class="keyword">int</span> tr = (toColor &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;
        <span class="keyword">int</span> tg = (toColor &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;
        <span class="keyword">int</span> tb = toColor &amp; <span class="number">0xFF</span>;

        <span class="keyword">int</span> rGap = (<span class="keyword">int</span>) ((<span class="keyword">float</span>) (tr - fr) * progress);
        <span class="keyword">int</span> gGap = (<span class="keyword">int</span>) ((<span class="keyword">float</span>) (tg - fg) * progress);
        <span class="keyword">int</span> bGap = (<span class="keyword">int</span>) ((<span class="keyword">float</span>) (tb - fb) * progress);

        <span class="keyword">return</span> <span class="number">0xFF000000</span> | ((fr + rGap) &lt;&lt; <span class="number">16</span>) | ((fg + gGap) &lt;&lt; <span class="number">8</span>) | (fb + bGap);
    }
</code></pre><p>为了将状态变化值传递给页面，一般指的是Activity、Fragment、View，我们需要定义一个接口：</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> SwitchView状态切换
 <span class="keyword">*</span>/
public static interface OnSwitchStateChangeListener {
    /<span class="keyword">*</span><span class="keyword">*</span>
     <span class="keyword">*</span> 是否选中
     <span class="keyword">*</span>
     <span class="keyword">*</span> <span class="comment">@param isOn</span>
     <span class="keyword">*</span>/
    public void onStateSwitched(boolean isOn);
}
</code></pre><p>里面的一些细节这里就不讲了，最后怎么使用呢？分两步：</p>
<p>第一步：布局xml</p>
<pre><code>&lt;<span class="tag">com</span><span class="class">.hhl</span><span class="class">.library</span><span class="class">.IOSSwitchView</span>
            <span class="rule"><span class="attribute">android</span>:<span class="value">id=<span class="string">"@+id/switch_view"</span>
            android:layout_width=<span class="string">"55dp"</span>
            android:layout_height=<span class="string">"35dp"</span>
            android:layout_gravity=<span class="string">"center"</span>
            app:thumbTintColor=<span class="string">"#fff"</span>
            app:tintColor=<span class="string">"#00ff00"</span> /&gt;</span></span>
</code></pre><p>第二步：代码</p>
<pre><code>mSwitchView = (IOSSwitchView) findViewById(R.id.switch_view);
        mStatusTv = (TextView) findViewById(R.id.tv_status);

        mSwitchView.setOnSwitchStateChangeListener(<span class="keyword">new</span> IOSSwitchView.OnSwitchStateChangeListener() {
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onStateSwitched</span><span class="params">(<span class="keyword">boolean</span> isOn)</span> </span>{
                <span class="keyword">if</span> (isOn) {
                    mStatusTv.setText(<span class="string">"状态：开"</span>);
                } <span class="keyword">else</span> {
                    mStatusTv.setText(<span class="string">"状态：关"</span>);
                }
            }
        });
</code></pre><p>最后，附上源码：<a href="https://github.com/hanhailong/IOSSwitchView" target="_blank" rel="external">github-IOSSwitchView</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这一章节，我们将开始在Android上做一个IOS风格的UISwitch控件。这篇文章主要涉及如下知识点：</p>
<ol>
<li>Android属性动画Animator</li>
<li>自定义手势GestureDetector</li>
<li>自定义View属性attrs</li>
</ol>
<p>首先，让我们来看一下效果图：</p>
<p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/uiswitch.gif?raw=true" alt="uiswitch"></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RxBus—通过RxJava来替换EventBus]]></title>
    <link href="http://hanhailong.com/2015/10/09/RxBus%E2%80%94%E9%80%9A%E8%BF%87RxJava%E6%9D%A5%E6%9B%BF%E6%8D%A2EventBus/"/>
    <id>http://hanhailong.com/2015/10/09/RxBus—通过RxJava来替换EventBus/</id>
    <published>2015-10-09T15:25:07.000Z</published>
    <updated>2015-10-10T02:18:49.000Z</updated>
    <content type="html"><![CDATA[<h2>前言</h2>

<p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a>有多火？看看Github上star数量就知道了，那什么是RxJava呢？</p>
<p>RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。</p>
<p>换一种说法，RxJava 是一个响应式编程框架，采用观察者设计模式。所以自然少不了 Observable 和 Subscriber 这两个东东了。</p>
<a id="more"></a>
<p>而针对Android，则有一个基于RxJava的<a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">RxAndroid</a></p>
<p>甚至Jake Wharton大神还基于RxJava写了一个针对Android平台的binding api<a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="external">RxBinding</a></p>
<p>而这篇博文讲的就是基于RxJava实现的一个Event Bus-&gt;<a href="https://github.com/hanhailong/AndroidStudyResources/blob/master/javacode/RxBus.java" target="_blank" rel="external">RxBus</a></p>
<p>懂得Android的开发者都知道，目前Android上最火的两个Event Bus库是<a href="http://square.github.io/otto/" target="_blank" rel="external">Otto</a>和Green Robot’s<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a>，两个事件总线库写的都非常不错。不过这里不是讲事件总线，而是讲如何通过RxJava来实现事件总线的效果。</p>
<p>总体来说，代码非常的简单，十几行代码就搞定了！</p>
<p>首先，我们来定义一个RxBus单例类：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> rx.Observable;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> rx.subjects.PublishSubject;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> rx.subjects.SerializedSubject;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> rx.subjects.Subject;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by HanHailong on 15/10/9.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxBus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> volatile RxBus mDefaultInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RxBus() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RxBus getDefault() &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDefaultInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            synchronized (RxBus.<span class="keyword">class</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDefaultInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mDefaultInstance = <span class="keyword">new</span> RxBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mDefaultInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject&lt;Object, Object&gt; _bus = <span class="keyword">new</span> SerializedSubject&lt;&gt;(PublishSubject.create());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> send(Object o) &#123;</span><br><span class="line">        _bus.onNext(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Observable&lt;Object&gt; toObservable() &#123;</span><br><span class="line">        <span class="keyword">return</span> _bus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码非常的简单，使用呢？则更简单了，一般来讲，事件总线，包括一个发送事件和多个接收事件。</p>
<p>先看发送事件的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">RxBus</span><span class="class">.getDefault</span>()<span class="class">.send</span>(<span class="tag">new</span> <span class="tag">TapEvent</span>());</span><br></pre></td></tr></table></figure>
<p>而在你想接收事件的地方，只需要加上下面代码就可以了：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RxBus.getDefault().toObservable().subscribe(<span class="keyword">new</span> Action1&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (event <span class="keyword">instanceof</span> TapEvent) &#123;</span><br><span class="line">                   <span class="comment">//do something</span></span><br><span class="line">                &#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(event <span class="keyword">instanceof</span> otherEvent)</span></span>&#123;</span><br><span class="line">                		<span class="comment">//do otherthing</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>这样，一个简单的Event Bus就实现了！如果你的项目已经开始使用RxJava，建议可以把<a href="http://square.github.io/otto/" target="_blank" rel="external">Otto</a>和Green Robot’s<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a>去掉了，直接使用<a href="https://github.com/hanhailong/AndroidStudyResources/blob/master/javacode/RxBus.java" target="_blank" rel="external">RxBus</a>！！</p>
<p>当然，不要忘了在build.gradle引入RxJava和RxAndroid：</p>
<pre><code><span class="keyword">compile</span> <span class="string">'io.reactivex:rxandroid:1.0.1'</span>
<span class="keyword">compile</span> <span class="string">'io.reactivex:rxjava:1.0.14'</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2>前言</h2>

<p><a href="https://github.com/ReactiveX/RxJava">RxJava</a>有多火？看看Github上star数量就知道了，那什么是RxJava呢？</p>
<p>RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。</p>
<p>换一种说法，RxJava 是一个响应式编程框架，采用观察者设计模式。所以自然少不了 Observable 和 Subscriber 这两个东东了。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
      <category term="RxAndroid" scheme="http://hanhailong.com/tags/RxAndroid/"/>
    
      <category term="RxJava" scheme="http://hanhailong.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo—添加百度统计代码]]></title>
    <link href="http://hanhailong.com/2015/10/08/Hexo%E2%80%94%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81/"/>
    <id>http://hanhailong.com/2015/10/08/Hexo—添加百度统计代码/</id>
    <published>2015-10-08T15:31:31.000Z</published>
    <updated>2015-10-08T16:05:53.000Z</updated>
    <content type="html"><![CDATA[<p>本博客采用的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">Yilia</a>主题，这里就以Yilia讲解为例，首先你要去<a href="http://tongji.baidu.com/" target="_blank" rel="external">百度统计</a>注册账号，并获取到相关的百度统计代码：</p>
<ol>
<li><p>编辑文件<font color="blue"><strong>themes/yilia/_config.yml</strong></font>，添加一行配置代码：</p>
<pre><code><span class="string">baidu_tongji:</span> <span class="literal">true</span>
</code></pre></li>
<li><p>新建文件<font color="blue"><strong>themes/yilia/layout/_partial/baidu_tongji.ejs</strong></font>，内容如下：</p>
<pre><code><span class="xml"></span>&lt;%<span class="ruby"> <span class="keyword">if</span> (theme.baidu_tongji) { </span>%&gt;<span class="xml">
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="undefined">
#申请的百度统计代码
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</span>&lt;%<span class="ruby"> } </span>%&gt;<span class="xml"></span>
</code></pre></li>
<li><p>编辑<font color="blue">themes/yilia/layout/_partial/head.ejs</font>文件，在<font color="red">&lt;/head&gt;</font>之前添加代码：</p>
<pre><code>&lt;<span class="preprocessor">%</span>- partial<span class="comment">("baidu_tongji")</span> <span class="preprocessor">%</span>&gt;
</code></pre></li>
<li><p>重新部署发布，搞定睡觉！！！</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本博客采用的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">Yilia</a>主题，这里就以Yilia讲解为例，首先你要去<a href="http:/]]>
    </summary>
    
      <category term="Hexo主题" scheme="http://hanhailong.com/tags/Hexo%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo—正确添加RSS订阅]]></title>
    <link href="http://hanhailong.com/2015/10/08/Hexo%E2%80%94%E6%AD%A3%E7%A1%AE%E6%B7%BB%E5%8A%A0RSS%E8%AE%A2%E9%98%85/"/>
    <id>http://hanhailong.com/2015/10/08/Hexo—正确添加RSS订阅/</id>
    <published>2015-10-08T13:07:13.000Z</published>
    <updated>2015-10-08T13:51:57.000Z</updated>
    <content type="html"><![CDATA[<p>看到别人的博客都有RSS订阅功能，就想着给自己的博客也添加RSS订阅功能。</p>
<p>看网上的教程，写的不是很详细，都是很简单的一句话。而我按照网上的教程愣是没整出来。真是验证了一句古话：<font color="red">尽信书不如无书</font></p>
<p>最后，终于让我整出来了，特此把完整的过程记录一下：</p>
<a id="more"></a>
<p>先看下整出来的效果图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rss.png?raw=true" alt="RSS效果图"></p>
<p>首先，先安装<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="external">hexo-generator-feed</a></p>
<pre><code>$ npm <span class="operator"><span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span>
</code></pre><p>安装完后，会在node_modules目录下生成hexo-generator-feed目录，如图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rss-feed.png?raw=true" alt="image"></p>
<p>安装完hexo-generator-feed后，将其配置到根目录的<font color="red">_config.yml</font></p>
<pre><code><span class="preprocessor"># Extensions</span>
<span class="preprocessor">## Plugins: http://hexo.io/plugins/</span>
<span class="preprocessor">#RSS订阅</span>
<span class="label">plugin:</span>
- hexo-generator-feed
<span class="preprocessor">#Feed Atom</span>
<span class="label">feed:</span>
<span class="label">type:</span> atom
<span class="label">path:</span> atom.xml
<span class="label">limit:</span> <span class="number">20</span>
</code></pre><p>其中，feed是可选项，可配可不配！</p>
<p>最后，在你当前主题下的<font color="blue">_config.yml</font>下，添加RSS订阅链接即可，这里我用的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">Yilia</a>主题，subnav下添加rss：</p>
<pre><code><span class="preprocessor"># SubNav</span>
<span class="label">subnav:</span>
<span class="label">rss:</span> <span class="string">"/atom.xml"</span>
</code></pre><p>添加之后，运行<font color="red">hexo g</font>后，就会在页面上生成RSS图标，如下图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rss-result.png?raw=true" alt="image"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>看到别人的博客都有RSS订阅功能，就想着给自己的博客也添加RSS订阅功能。</p>
<p>看网上的教程，写的不是很详细，都是很简单的一句话。而我按照网上的教程愣是没整出来。真是验证了一句古话：<font color='red'>尽信书不如无书</font></p>
<p>最后，终于让我整出来了，特此把完整的过程记录一下：</p>]]>
    
    </summary>
    
      <category term="Hexo主题" scheme="http://hanhailong.com/tags/Hexo%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不错的学习技术博客之三—泡在网上的日子]]></title>
    <link href="http://hanhailong.com/2015/10/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E4%B9%8B%E4%B8%89%E2%80%94%E6%B3%A1%E5%9C%A8%E7%BD%91%E4%B8%8A%E7%9A%84%E6%97%A5%E5%AD%90/"/>
    <id>http://hanhailong.com/2015/10/08/不错的学习技术博客之三—泡在网上的日子/</id>
    <published>2015-10-08T08:19:33.000Z</published>
    <updated>2015-10-08T08:27:38.000Z</updated>
    <content type="html"><![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第三篇，<a href="http://www.jcodecraeer.com/" target="_blank" rel="external">泡在网上的日子</a>上面的技术博客质量都非常高，文章内容非常广泛，不仅包括Android和IOS，还包括Html5/css3、JS、java、php等，甚至还包括设计模式和算法。</p>
<p>还有就是包括代码，里面的代码大部分都托管在github上面，这里做了比较详细的系统分类，总体做的非常不错，我经常去上面浏览学习！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第三篇，<a href="http://www.jcodecraeer.com/" tar]]>
    </summary>
    
      <category term="技术博客" scheme="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-内存优化之图片优化]]></title>
    <link href="http://hanhailong.com/2015/10/06/Android-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E4%B9%8B%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/"/>
    <id>http://hanhailong.com/2015/10/06/Android-内存优化之图片优化/</id>
    <published>2015-10-06T12:21:39.000Z</published>
    <updated>2015-10-06T12:41:12.000Z</updated>
    <content type="html"><![CDATA[<p>网上有很多大拿分享的关于Android性能优化的文章，主要是通过各种工具分析，使用合理的技巧优化APP的体验，提升APP的流畅度，但关于内存优化的文章很少有看到。在Android设备内存动不动就上G的情况下，的确没有必要去太在意APP对Android系统内存的消耗，但在实际工作中我做的是教育类的小学APP，APP中的按钮、背景、动画变换基本上全是图片，在2K屏上（分辨率2048*1536）一张背景图片就会占用内存12M，来回切换几次内存占用就会增涨到上百兆，为了在不影响APP的视觉效果的前提下，有必要通过各种手段来降低APP对内存的消耗，下面是我在实践过程中使用的一些方法，很多都是不太成熟的项目，也不够深入，只是将其作为一种处理方式分享给大家。</p>
<a id="more"></a>
<p>   通过DDMS的APP内存占用查看工具分析发现，APP中占用内存最多的是图片，每个Activity中图片占用内存占大半，本文重点分享对图片的内存优化。</p>
<h2>不要将Button的背景设置为selector</h2>

<p>   在布局文件和代码中，都可以为Button设置background为selector，这样方便实现按钮的正反选效果，但实际跟踪发现，如果是将Button的背景设置为selector，在初始化Button的时候会将正反选图片都加载在内存中（具体可以查看Android源码，在类Drawable.java的createFromXmlInner方法中对图片进行解析，最终调用Drawable的inflate方法），相当于一个按钮占用了两张相同大小图片所使用的内存，如果一个界面上按钮很多或者是按钮很大，光是按钮占用的内存就会很大，可以通过在布局文件中给按钮只设置正常状态下的背景图片，然后在代码中监听按钮的点击状态，当按下按钮时为按钮设置反选效果的图片，抬起时重新设置为正常状态下的背景，具体实现方式如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageButtonClickUtils</span> </span>{
        <span class="function"><span class="keyword">private</span> <span class="title">ImageButtonClickUtils</span><span class="params">()</span></span>{

        }

        <span class="comment">/**
         * 设置按钮的正反选效果
         * 
         * */</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setClickState</span><span class="params">(View view, <span class="keyword">final</span> <span class="keyword">int</span> normalResId, <span class="keyword">final</span> <span class="keyword">int</span> pressResId)</span></span>{
            view.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() {
                <span class="annotation">@Override</span>
                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>{
                    <span class="keyword">switch</span>(event.getAction()){
                    <span class="keyword">case</span> MotionEvent.ACTION_DOWN:{
                        v.setBackgroundResource(pressResId);
                    }
                    <span class="keyword">break</span>;
                    <span class="keyword">case</span> MotionEvent.ACTION_MOVE:{
                        v.setBackgroundResource(pressResId);
                    }
                    <span class="keyword">break</span>;
                    <span class="keyword">case</span> MotionEvent.ACTION_UP:{
                        v.setBackgroundResource(normalResId);
                    }
                    <span class="keyword">break</span>;
                    <span class="keyword">default</span>:{

                    }
                    <span class="keyword">break</span>;
                    }

                    <span class="comment">// 为了不影响监听按钮的onClick回调，返回值应为false</span>
                    <span class="keyword">return</span> <span class="keyword">false</span>;
                }
            });
        }
}
</code></pre><p>通过上面这种方式就可以解决同一个按钮占用两倍内存的问题，如果你觉得为一个按钮提供正反选两张图片会导致APK的体积变大，可以通过如下方式实现按钮点击的反选效果，这种方式既不会存在Button占用两倍内存的情况，又减小了APK的体积（Android 5.0中的tintColor也可以实现类似的效果）：</p>
<pre><code>ImageButton personalInfoBtn = (ImageButton)findViewById(R.id.personalBtnId);
    personalInfoBtn.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() {
        <span class="annotation">@SuppressLint</span>(<span class="string">"ClickableViewAccessibility"</span>)
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>{
            <span class="keyword">int</span> action = event.getAction();

            <span class="keyword">if</span>(action == MotionEvent.ACTION_DOWN){
                ((ImageButton)v).setColorFilter(getResources().getColor(<span class="number">0X50000000</span>));
            }<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL)</span></span>{
                ((ImageButton)v).clearColorFilter();
            }

            <span class="comment">// 为了不影响监听按钮的onClick回调，返回值应为false</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
    });
</code></pre><h2>将背景图片放在非UI线程绘制，提升APP的效率</h2>

<p>在高分辨率的平板设备上，绘制大背景的图片会影响程序的运行效率，严重情况下就和没有开硬件加速的时候使用手写功能一样，相当地卡，最后我们的解决方案是将背景图片通过SurfaceView来绘制，这样相当于是在非UI线程绘制，不会影响到UI线程做其它事情：</p>
<pre><code><span class="keyword">import</span> android.content.Context;
<span class="keyword">import</span> android.content.res.TypedArray;
<span class="keyword">import</span> android.graphics.Bitmap;
<span class="keyword">import</span> android.graphics.BitmapFactory;
<span class="keyword">import</span> android.graphics.Canvas;
<span class="keyword">import</span> android.graphics.Matrix;
<span class="keyword">import</span> android.graphics.PixelFormat;
<span class="keyword">import</span> android.util.AttributeSet;
<span class="keyword">import</span> android.util.DisplayMetrics;
<span class="keyword">import</span> android.view.SurfaceHolder;
<span class="keyword">import</span> android.view.SurfaceView;

<span class="keyword">import</span> com.hhl.activity.R;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootSurfaceView</span> <span class="keyword">extends</span> <span class="title">SurfaceView</span> <span class="keyword">implements</span> <span class="title">SurfaceHolder</span>.<span class="title">Callback</span>, <span class="title">Runnable</span></span>{
    <span class="keyword">private</span> <span class="keyword">float</span> mViewWidth = <span class="number">0</span>;
    <span class="keyword">private</span> <span class="keyword">float</span> mViewHeight = <span class="number">0</span>;
    <span class="keyword">private</span> <span class="keyword">int</span> mResourceId = <span class="number">0</span>;
    <span class="keyword">private</span> Context mContext = <span class="keyword">null</span>;
    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">false</span>;
    <span class="keyword">private</span> SurfaceHolder mSurfaceHolder = <span class="keyword">null</span>;

    <span class="function"><span class="keyword">public</span> <span class="title">RootSurfaceView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>{
        <span class="keyword">super</span>(context, attrs, defStyleAttr);
        initRootSurfaceView(context, attrs, defStyleAttr, <span class="number">0</span>);
    }

    <span class="function"><span class="keyword">public</span> <span class="title">RootSurfaceView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>{
        <span class="keyword">super</span>(context, attrs);
        initRootSurfaceView(context, attrs, <span class="number">0</span>, <span class="number">0</span>);
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRootSurfaceView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span></span>{
        mContext = context;
        DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RootSurfaceView, defStyleAttr, defStyleRes);
        <span class="keyword">int</span> n = a.getIndexCount();
        mViewWidth = displayMetrics.widthPixels;
        mViewHeight = displayMetrics.heightPixels;
        <span class="keyword">for</span>(<span class="keyword">int</span> index=<span class="number">0</span>; index&lt;n; index++){
            <span class="keyword">int</span> attr = a.getIndex(index);
            <span class="keyword">switch</span>(attr){
            <span class="keyword">case</span> R.styleable.RootSurfaceView_background:{
                mResourceId = a.getResourceId(attr, <span class="number">0</span>);
            }
            <span class="keyword">break</span>;
            <span class="keyword">case</span> R.styleable.RootSurfaceView_view_width:{
                mViewWidth = a.getDimension(attr, displayMetrics.widthPixels);
            }
            <span class="keyword">break</span>;
            <span class="keyword">case</span> R.styleable.RootSurfaceView_view_height:{
                mViewHeight = a.getDimension(attr, displayMetrics.heightPixels);
            }
            <span class="keyword">break</span>;
            <span class="keyword">default</span>:{

            }
            <span class="keyword">break</span>;
            }
        }
        a.recycle();
        mSurfaceHolder = getHolder();
        mSurfaceHolder.addCallback(<span class="keyword">this</span>);
        mSurfaceHolder.setFormat(PixelFormat.TRANSLUCENT);
    }

    <span class="function"><span class="keyword">private</span> Bitmap <span class="title">getDrawBitmap</span><span class="params">(Context context, <span class="keyword">float</span> width, <span class="keyword">float</span> height)</span> </span>{
        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), mResourceId);
        Bitmap resultBitmap = zoomImage(bitmap, width, height);
        <span class="keyword">return</span> resultBitmap;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder arg0, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">int</span> arg3)</span> </span>{
        System.out.println(<span class="string">"RootSurfaceView surfaceChanged"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> </span>{
        drawBackGround(holder);
        System.out.println(<span class="string">"RootSurfaceView surfaceCreated"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>{
        isRunning = <span class="keyword">false</span>;
        System.out.println(<span class="string">"RootSurfaceView surfaceDestroyed"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onAttachedToWindow();
        System.out.println(<span class="string">"RootSurfaceView onAttachedToWindow"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onDetachedFromWindow();
        System.out.println(<span class="string">"RootSurfaceView onDetachedFromWindow"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{  
        <span class="keyword">while</span>(isRunning){  
            <span class="keyword">synchronized</span> (mSurfaceHolder) { 
                <span class="keyword">if</span>(!mSurfaceHolder.getSurface().isValid()){
                    <span class="keyword">continue</span>;
                }
                drawBackGround(mSurfaceHolder);
            }
            isRunning = <span class="keyword">false</span>;
            <span class="keyword">break</span>;
        }  
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawBackGround</span><span class="params">(SurfaceHolder holder)</span> </span>{
        Canvas canvas = holder.lockCanvas();
        Bitmap bitmap = getDrawBitmap(mContext, mViewWidth, mViewHeight);
        canvas.drawBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);
        bitmap.recycle();
        holder.unlockCanvasAndPost(canvas);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">zoomImage</span><span class="params">( Bitmap bgimage , <span class="keyword">float</span> newWidth , <span class="keyword">float</span> newHeight )</span> </span>{
        <span class="keyword">float</span> width = bgimage.getWidth( );
        <span class="keyword">float</span> height = bgimage.getHeight( );
        Matrix matrix = <span class="keyword">new</span> Matrix();
        <span class="keyword">float</span> scaleWidth = newWidth/width;
        <span class="keyword">float</span> scaleHeight = newHeight/height;
        matrix.postScale( scaleWidth, scaleHeight );
        Bitmap bitmap = Bitmap.createBitmap( bgimage, <span class="number">0</span>, <span class="number">0</span>, ( <span class="keyword">int</span> ) width , ( <span class="keyword">int</span> ) height, matrix, <span class="keyword">true</span> );
        <span class="keyword">if</span>( bitmap != bgimage ){
            bgimage.recycle();
            bgimage = <span class="keyword">null</span>;
        }
        <span class="keyword">return</span> bitmap;
    }
}
</code></pre><p>在res/values/attr.xml文件中定义自定义View的自定义属性：</p>
<pre><code><span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"RootSurfaceView"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"background"</span> <span class="attribute">format</span>=<span class="value">"reference"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"view_width"</span> <span class="attribute">format</span>=<span class="value">"dimension"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"view_height"</span> <span class="attribute">format</span>=<span class="value">"dimension"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span>
</code></pre><h2> 没有必要使用硬件加速的界面建议关掉硬件加速 </h2>

<p>通过DDMS的heap跟踪发现，相比于关闭硬件加速，在打开硬件加速的情况下会消耗更多的内存，但有的界面打开或者关闭硬件加速对程序的运行效率并没有太大的影响，此种情况下可以考虑在AndroidManifest.xml文件中关闭掉对应Activity的硬件加速，like this：</p>
<pre><code><span class="comment">&lt;!-- 设置界面 --&gt;</span>
<span class="tag">&lt;<span class="title">activity</span>
    <span class="attribute">android:name</span>=<span class="value">".SettingActivity"</span>
    <span class="attribute">android:hardwareAccelerated</span>=<span class="value">"false"</span>
    <span class="attribute">android:screenOrientation</span>=<span class="value">"sensorLandscape"</span>&gt;</span>
<span class="tag">&lt;/<span class="title">activity</span>&gt;</span>
</code></pre><p>注意：如果使用到WebView、视频播放、手写、动画等功能时，关掉硬件加速会严重音效程序的运行效率，这种情况可以只关闭掉Activity中某些view的硬件加速，整个Activity的硬件加速不关闭。</p>
<p>如果Activity中某个View需要关闭硬件加速，但整个Activity不能关闭，可以调用view层级关闭硬件加速的方法：</p>
<pre><code><span class="comment">// view.setLayerType || 在定义view的构造方法中调用该方法</span>
setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="literal">null</span>);
</code></pre><h2>尽量少用AnimationDrawable，如果必须要可以自定义图片切换器代替AnimationDrawable</h2>

<p>AnimationDrawable也是一个耗内存大户，图片帧数越多耗内存越大，具体可以查看AnimationDrawable的源码，在AnimationDrawable实例化的时候，Drawable的createFromXmlInner方法会调用AnimationDrawable的inflate方法，该方法里面有一个while循环去一次性将所有帧都读取出来，也就是在初始化的时候就将所有的帧读在内存中了，有多少张图片，它就要消耗对应大小的内存。</p>
<p>虽然可以通过如下方式释放AnimationDrawable占用的内存，但是当退出使用AnimationDrawable的界面，再次进入使用其播放动画时，会报使用已经回收了的图片的异常，这个应该是Android对图片的处理机制导致的，虽然Activity被finish掉了，但是这个Activity中使用到的图片还是在内存中，如果被回收，下次进入时就会报异常信息：</p>
<pre><code><span class="comment">/**
 * 释放AnimationDrawable占用的内存
 * 
 * 
 * */</span>
<span class="annotation">@SuppressWarnings</span>(<span class="string">"unused"</span>)
<span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">freeAnimationDrawable</span><span class="params">(AnimationDrawable animationDrawable)</span> </span>{
    animationDrawable.stop(); 
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; animationDrawable.getNumberOfFrames(); ++i){
        Drawable frame = animationDrawable.getFrame(i);
        <span class="keyword">if</span> (frame <span class="keyword">instanceof</span> BitmapDrawable) {
            ((BitmapDrawable)frame).getBitmap().recycle();
        } 
        frame.setCallback(<span class="keyword">null</span>);
    } 

    animationDrawable.setCallback(<span class="keyword">null</span>);
}
</code></pre><p>通常情况下我会自定义一个ImageView来实现AnimationDrawable的功能，根据图片之间切换的时间间隔来定时设置ImageView的背景图片，这样始终只是一个ImageView实例，更换的只是其背景，占用内存会比AnimationDrawable小很多：</p>
<pre><code><span class="comment">/**
 * 图片动态切换器
 * 
 * */</span>
<span class="keyword">public</span> <span class="keyword">class</span> AnimImageView {
    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> MSG_START = <span class="number">0xf1</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> MSG_STOP  = <span class="number">0xf2</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> STATE_STOP = <span class="number">0xf3</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> STATE_RUNNING = <span class="number">0xf4</span>;

    <span class="comment">/* 运行状态*/</span>
    <span class="keyword">private</span> <span class="keyword">int</span> mState = STATE_RUNNING;
    <span class="keyword">private</span> ImageView mImageView;
    <span class="comment">/* 图片资源ID列表*/</span>
    <span class="keyword">private</span> List&lt;Integer&gt; mResourceIdList = null;
    <span class="comment">/* 定时任务*/</span>
    <span class="keyword">private</span> Timer mTimer = null;
    <span class="keyword">private</span> AnimTimerTask mTimeTask = null;
    <span class="comment">/* 记录播放位置*/</span>
    <span class="keyword">private</span> <span class="keyword">int</span> mFrameIndex = <span class="number">0</span>;
    <span class="comment">/* 播放形式*/</span>
    <span class="keyword">private</span> boolean isLooping = <span class="literal">false</span>;

    <span class="function"><span class="keyword">public</span> <span class="title">AnimImageView</span><span class="params">( )</span></span>{
        mTimer = <span class="keyword">new</span> Timer();
    }

    <span class="comment">/**
     * 设置动画播放资源
     * 
     * */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnimation</span><span class="params">( HanziImageView imageview, List&lt;Integer&gt; resourceIdList )</span></span>{
        mImageView = imageview;
        mResourceIdList = resourceIdList;
    }

    <span class="comment">/**
     *  开始播放动画
     *  @param loop 时候循环播放
     *  @param duration 动画播放时间间隔
     * */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(boolean loop, <span class="keyword">int</span> duration)</span></span>{
        stop();
        isLooping = loop;
        mFrameIndex = <span class="number">0</span>;
        mState = STATE_RUNNING;
        mTimeTask = <span class="keyword">new</span> AnimTimerTask( );
        mTimer.schedule(mTimeTask, <span class="number">0</span>, duration);
    }

    <span class="comment">/**
     * 停止动画播放
     * 
     * */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>{
        <span class="keyword">if</span> (mTimeTask != null) {
            mFrameIndex = <span class="number">0</span>;
            mState = STATE_STOP;
            mTimer.purge();
            mTimeTask.cancel();
            mTimeTask = null;
            mImageView.setBackgroundResource(<span class="number">0</span>);
        }
    }

    <span class="comment">/**
     * 定时器任务
     * 
     * 
     */</span>
    <span class="keyword">class</span> AnimTimerTask extends TimerTask {
        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            <span class="keyword">if</span>(mFrameIndex &lt; <span class="number">0</span> || mState == STATE_STOP){
                <span class="keyword">return</span>;
            }

            <span class="keyword">if</span>( mFrameIndex &lt; mResourceIdList.size() ){
                Message msg = AnimHanlder.obtainMessage(MSG_START,<span class="number">0</span>,<span class="number">0</span>,null);
                msg.sendToTarget();
            }<span class="keyword">else</span>{
                mFrameIndex = <span class="number">0</span>;
                <span class="keyword">if</span>(!isLooping){
                    Message msg = AnimHanlder.obtainMessage(MSG_STOP,<span class="number">0</span>,<span class="number">0</span>,null);
                    msg.sendToTarget();
                }
            }
        }
    }

    <span class="keyword">private</span> Handler AnimHanlder = <span class="keyword">new</span> Handler(){
         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(android.os.Message msg)</span> </span>{
                <span class="keyword">switch</span> (msg.what) {
                <span class="keyword">case</span> MSG_START:{
                    <span class="keyword">if</span>(mFrameIndex &gt;=<span class="number">0</span> &amp;&amp; mFrameIndex &lt; mResourceIdList.size() &amp;&amp; mState == STATE_RUNNING){
                        mImageView.setImageResource(mResourceIdList.get(mFrameIndex));
                        mFrameIndex++;
                    }
                }
                    <span class="keyword">break</span>;
                <span class="keyword">case</span> MSG_STOP:{
                    <span class="keyword">if</span> (mTimeTask != null) {
                        mFrameIndex = <span class="number">0</span>;
                        mTimer.purge();
                        mTimeTask.cancel();
                        mState = STATE_STOP;
                        mTimeTask = null;
                        mImageView.setImageResource(<span class="number">0</span>);
                    }
                }
                    <span class="keyword">break</span>;
                <span class="keyword">default</span>:
                    <span class="keyword">break</span>;
                }
         }
    };
}
</code></pre><h2>其它优化方式</h2>

<ul>
<li>尽量将Activity中的小图片和背景合并，一张小图片既浪费布局的时间，又平白地增加了内存占用；</li>
<li><p>不要在Activity的主题中为Activity设置默认的背景图片，这样会导致Activity占用的内存翻倍：</p>
<pre><code><span class="comment">&lt;!--千万不要在主题中为Activity设置默认背景--&gt;</span>
<span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"Activity_Style"</span> <span class="attribute">parent</span>=<span class="value">"@android:Theme.Holo.Light.NoActionBar"</span>&gt;</span><span class="css">
&lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="rule"><span class="attribute">android</span>:<span class="value">background<span class="string">"&gt;@drawable/*&lt;/item&gt;
</span></span></span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
</code></pre></li>
<li><p>对于在需要时才显示的图片或者布局，可以使用ViewStub标签，通过sdk/tools目录下的hierarchyviewer.bat查看布局文件会发现，使用viewstub标签的组件几乎不消耗布局的时间，在代码中当需要显示时再去实例化有助于提高Activity的布局效率和节省Activity消耗的内存。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>网上有很多大拿分享的关于Android性能优化的文章，主要是通过各种工具分析，使用合理的技巧优化APP的体验，提升APP的流畅度，但关于内存优化的文章很少有看到。在Android设备内存动不动就上G的情况下，的确没有必要去太在意APP对Android系统内存的消耗，但在实际工作中我做的是教育类的小学APP，APP中的按钮、背景、动画变换基本上全是图片，在2K屏上（分辨率2048*1536）一张背景图片就会占用内存12M，来回切换几次内存占用就会增涨到上百兆，为了在不影响APP的视觉效果的前提下，有必要通过各种手段来降低APP对内存的消耗，下面是我在实践过程中使用的一些方法，很多都是不太成熟的项目，也不够深入，只是将其作为一种处理方式分享给大家。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不错的学习技术博客之二————trinea.cn]]></title>
    <link href="http://hanhailong.com/2015/10/06/%E4%B8%8D%E9%94%99%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E4%B9%8B%E4%BA%8C%E2%80%94%E2%80%94%E2%80%94%E2%80%94trinea-cn/"/>
    <id>http://hanhailong.com/2015/10/06/不错的学习技术博客之二————trinea-cn/</id>
    <published>2015-10-06T03:14:05.000Z</published>
    <updated>2015-10-06T03:28:28.000Z</updated>
    <content type="html"><![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第二篇，<a href="http://www.trinea.cn/" target="_blank" rel="external">trinea</a>这个技术博客主要记录Android和Java方面的技术文章，侧重点在于性能调优、开源项目经验分享、新技术调研等等，而作者本身编程功底很深，2010年加入阿里巴巴，目前在<a href="http://codekk.com/jobs/detail/%E6%9D%AD%E5%B7%9E/%E5%BF%AB%E7%9A%84%E6%89%93%E8%BD%A6/Android%20%E5%BC%80%E5%8F%91杭州快的" target="_blank" rel="external">杭州快的</a>担任移动端架构师！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第二篇，<a href="http://www.trinea.cn/" target="_]]>
    </summary>
    
      <category term="技术博客" scheme="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不错的学习技术博客之一————美团tech.meituan]]></title>
    <link href="http://hanhailong.com/2015/10/06/%E4%B8%8D%E9%94%99%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E4%B9%8B%E4%B8%80%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%BE%8E%E5%9B%A2tech-meituan/"/>
    <id>http://hanhailong.com/2015/10/06/不错的学习技术博客之一————美团tech-meituan/</id>
    <published>2015-10-06T03:00:14.000Z</published>
    <updated>2015-10-06T03:16:58.000Z</updated>
    <content type="html"><![CDATA[<p>之前看过很多的技术博客，<a href="http://tech.meituan.com/" target="_blank" rel="external">美团</a>的教学技术博客还是蛮不错的，之前看过里面的一篇文章<a href="http://tech.meituan.com/mt-apk-adaptation.html" target="_blank" rel="external">美团Android自动化之旅—适配渠道包</a>，讲的真心不错，如果再配合<a href="http://hugozhu.myalert.info/2014/08/03/50-use-gradle-to-customize-apk-build.html" target="_blank" rel="external">使用Gradle生成一个App的不同版本，且可以同时安装在一个手机上</a>，基本上使用<font color="red">Gradle</font>来构建Android应用就没啥问题了！</p>
<p>里面的文章讲的透彻清晰！非常值得去学习！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前看过很多的技术博客，<a href="http://tech.meituan.com/" target="_blank" rel="external">美团</a>的教学技术博客还是蛮不错的，之前看过里面的一篇文章<a href="http://tech.meituan]]>
    </summary>
    
      <category term="技术博客" scheme="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android不错的开源库之-ExplosionField（View粒子炸裂效果）]]></title>
    <link href="http://hanhailong.com/2015/10/06/Android%E4%B8%8D%E9%94%99%E7%9A%84%E5%BC%80%E6%BA%90%E5%BA%93%E4%B9%8B-ExplosionField%EF%BC%88View%E7%B2%92%E5%AD%90%E7%82%B8%E8%A3%82%E6%95%88%E6%9E%9C%EF%BC%89/"/>
    <id>http://hanhailong.com/2015/10/06/Android不错的开源库之-ExplosionField（View粒子炸裂效果）/</id>
    <published>2015-10-06T00:36:16.000Z</published>
    <updated>2015-10-06T01:14:31.000Z</updated>
    <content type="html"><![CDATA[<p>前几天微博上出了一个非常优秀的Android开源组件-<a href="https://github.com/tyrantgit/ExplosionField" target="_blank" rel="external">ExplosionField</a>，效果非常的炫酷，类似MIUI卸载app的动画，先看效果：</p>
<p><img src="https://github.com/tyrantgit/ExplosionField/blob/master/explosionfield.gif?raw=true" alt="image"></p>
<a id="more"></a>
<p>我阅读了下源码，代码写的非常的不错，作者的代码功力非常深厚。这里就不赘述了，有需要的可以自己去看。</p>
<p>怎么使用呢？</p>
<p>在你的<font color="red">build.gradle</font>:</p>
<pre><code><span class="keyword">dependencies</span> {
   <span class="keyword">compile</span> <span class="string">'tyrantgit:explosionfield:1.0.0'</span>
 }
</code></pre><p>在<font color="red">Java</font>代码里：</p>
<pre><code>ExplosionField explosionField = ...<span class="comment">;</span>
explosionField.explode(view)<span class="comment">;</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>前几天微博上出了一个非常优秀的Android开源组件-<a href="https://github.com/tyrantgit/ExplosionField">ExplosionField</a>，效果非常的炫酷，类似MIUI卸载app的动画，先看效果：</p>
<p><img src="https://github.com/tyrantgit/ExplosionField/blob/master/explosionfield.gif?raw=true" alt="image"></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[The resource could not be loaded because the App Transport Security policy requires the use of a secure connection]]></title>
    <link href="http://hanhailong.com/2015/10/05/The-resource-could-not-be-loaded-because-the-App-Transport-Security-policy-requires-the-use-of-a-secure-connection/"/>
    <id>http://hanhailong.com/2015/10/05/The-resource-could-not-be-loaded-because-the-App-Transport-Security-policy-requires-the-use-of-a-secure-connection/</id>
    <published>2015-10-05T01:36:33.000Z</published>
    <updated>2015-10-05T02:12:54.000Z</updated>
    <content type="html"><![CDATA[<p>   最近把Xcode升级到最新正式版7.0.1后，发现所有的项目凡是有http请求的都访问失败了，只有https请求的可以访问成功。报错内容如下：</p>
<p>   <img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/ios-9-http-error.png?raw=true" alt="image"></p>
<a id="more"></a>
<p>Google后查证，iOS9引入了新特性<a href="https://developer.apple.com/library/prerelease/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS9.html#//apple_ref/doc/uid/TP40016198-DontLinkElementID_13" target="_blank" rel="external">App Transport Security (ATS)</a></p>
<p>新特性要求App内访问的网络必须使用<font color="red">HTTPS</font>协议。<br>但是现在公司的项目使用的是HTTP协议，使用私有加密方式保证数据安全。现在也不能马上改成HTTPS协议传输。</p>
<hr>
<p>如果要让ios9支持http访问怎么做呢？我们可以采用如下方式：</p>
<ol>
<li>在Info.plist中添加使用<font color="red"> NSAppTransportSecurity</font>类型使用<font color="red"> Dictionary</font></li>
<li>在使用<font color="red">NSAppTransportSecurity</font>下添加使用<font color="red">NSAllowsArbitraryLoads</font>类型Boolean,值设为使用<font color="red">YES</font></li>
</ol>
<p>最后，修改完后Info.plist的效果图如下：</p>
<p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/ios-9-http-resolve.png?raw=true" alt="image"></p>
<p>经过修改之后再请求网络，发现就正常了！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>   最近把Xcode升级到最新正式版7.0.1后，发现所有的项目凡是有http请求的都访问失败了，只有https请求的可以访问成功。报错内容如下：</p>
<p>   <img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/ios-9-http-error.png?raw=true" alt="image"></p>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://hanhailong.com/tags/IOS/"/>
    
  </entry>
  
</feed>
