<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[韩海龙的博客]]></title>
  <subtitle><![CDATA[学习总结 思考感悟 知识管理 代码分享]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://hanhailong.com/"/>
  <updated>2015-12-27T05:41:37.000Z</updated>
  <id>http://hanhailong.com/</id>
  
  <author>
    <name><![CDATA[韩海龙]]></name>
    <email><![CDATA[hanhailong.cool@163.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android性能优化之常见的内存泄漏]]></title>
    <link href="http://hanhailong.com/2015/12/27/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://hanhailong.com/2015/12/27/Android性能优化之常见的内存泄漏/</id>
    <published>2015-12-27T05:12:02.000Z</published>
    <updated>2015-12-27T05:41:37.000Z</updated>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>对于内存泄漏，我想大家在开发中肯定都遇到过，只不过内存泄漏对我们来说并不是可见的，因为它是在堆中活动，而要想检测程序中是否有内存泄漏的产生，通常我们可以借助LeakCanary、MAT等工具来检测应用程序是否存在内存泄漏，MAT是一款强大的内存分析工具，功能繁多而复杂，而LeakCanary则是由Square开源的一款轻量第三方内存泄漏检测工具，当它检测到程序中有内存泄漏的产生时，它将以最直观的方式告诉我们该内存泄漏是由谁产生的和该内存泄漏导致谁泄漏了而不能回收，供我们复查。</p>
<p>最近腾讯bugly也推出了三篇关于Android内存泄漏调优的文章：</p>
<ol>
<li><a href="http://bugly.qq.com/blog/?p=832" target="_blank" rel="external">内存泄露从入门到精通三部曲之基础知识篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=872" target="_blank" rel="external">内存泄露从入门到精通三部曲之排查方法篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=884" target="_blank" rel="external">内存泄露从入门到精通三部曲之常见原因与用户实践</a></li>
</ol>
<p>Realm同样给出了性能优化文章：</p>
<p><a href="https://realm.io/cn/news/droidcon-farber-improving-android-app-performance/" target="_blank" rel="external">10条提升Android性能的建议</a></p>
<a id="more"></a>
<h2>内存泄漏</h2>

<h4>为什么会产生内存泄漏？</h4>

<p>当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p>
<h4>内存泄漏对程序的影响？</h4>

<p>内存泄漏是造成应用程序OOM的主要原因之一！我们知道Android系统为每个应用程序分配的内存有限，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就造成了内存溢出而导致应用Crash。</p>
<h2>Android中常见的内存泄漏汇总</h2>

<h4>单例造成的内存泄漏</h4>

<p>单例模式非常受开发者的喜爱，不过使用的不恰当的话也会造成内存泄漏，由于单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。</p>
<p>如下这个典例：</p>
<pre><code>public class AppManager {
   <span class="keyword"> private</span><span class="keyword"> static</span> AppManager instance;
   <span class="keyword"> private</span> Context context;
   <span class="keyword"> private</span><span class="function"> AppManager(</span>Context context<span class="function">)</span> {
        this.context = context;
    }
   <span class="keyword"> public</span><span class="keyword"> static</span> AppManager<span class="function"> getInstance(</span>Context             context<span class="function">)</span> {
       <span class="instruction"> if </span>(instance != null<span class="function">)</span> {
           <span class="instruction"> instance </span>=<span class="instruction"> new </span>AppManager(context<span class="function">)</span>;
        }
       <span class="instruction"> return </span>instance;
    }
}
</code></pre><p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要： </p>
<ol>
<li>传入的是Application的Context：这将没有任何问题，因为单例的生命周期和Application的一样长</li>
<li>传入的是Activity的Context：当这个Context所对应的Activity退出时，由于该Context和Activity的生命周期一样长（Activity间接继承于Context），所以当前Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用。</li>
</ol>
<p>所以正确的单例应该修改为下面这种方式：</p>
<pre><code>public class AppManager {
   <span class="keyword"> private</span><span class="keyword"> static</span> AppManager instance;
   <span class="keyword"> private</span> Context context;
   <span class="keyword"> private</span><span class="function"> AppManager(</span>Context context<span class="function">)</span> {
        this.context =<span class="function"> context.getApplicationContext(</span><span class="function">)</span>;
    }
   <span class="keyword"> public</span><span class="keyword"> static</span> AppManager<span class="function"> getInstance(</span>Context context<span class="function">)</span> {
       <span class="instruction"> if </span>(instance != null<span class="function">)</span> {
           <span class="instruction"> instance </span>=<span class="instruction"> new </span>AppManager(context<span class="function">)</span>;
        }
       <span class="instruction"> return </span>instance;
    }
}
</code></pre><p>这样不管传入什么Context最终将使用Application的Context，而单例的生命周期和应用的一样长，这样就防止了内存泄漏</p>
<h4>非静态内部类创建静态实例造成的内存泄漏</h4>

<p>有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
    <span class="keyword">private</span> static <span class="type">TestResource</span> mResource = <span class="literal">null</span>;
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        <span class="keyword">if</span>(mResource == <span class="literal">null</span>){
            mResource = <span class="keyword">new</span> <span class="type">TestResource</span>();
        }
        <span class="comment">//...</span>
    }
    <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> {</span>
    <span class="comment">//...</span>
    }
}
</code></pre><p>这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而又使用了该非静态内部类创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为：<br>将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请使用ApplicationContext</p>
<h4>Handler造成的内存泄漏</h4>

<p>Handler的使用造成的内存泄漏问题应该说最为常见了，平时在处理网络任务或者封装一些请求回调等api都应该会借助Handler来处理，对于Handler的使用代码编写一不规范即有可能造成内存泄漏，如下示例：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
<span class="keyword">private</span> <span class="type">Handler</span> mHandler = <span class="keyword">new</span> <span class="type">Handler</span>() {
    <span class="annotation">@Override</span>
    public void handleMessage(<span class="type">Message</span> msg) {
    <span class="comment">//...</span>
    }
};
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        loadData();
    }
    <span class="keyword">private</span> void loadData(){
        <span class="comment">//...request</span>
        <span class="type">Message</span> message = <span class="type">Message</span>.obtain();
        mHandler.sendMessage(message);
    }
}
</code></pre><p>这种创建Handler的方式会造成内存泄漏，由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏，所以另外一种做法为：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
    <span class="keyword">private</span> <span class="type">MyHandler</span> mHandler = <span class="keyword">new</span> <span class="type">MyHandler</span>(<span class="keyword">this</span>);
    <span class="keyword">private</span> <span class="type">TextView</span> mTextView ;
    <span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Handler</span> {</span>
        <span class="keyword">private</span> <span class="type">WeakReference</span>&lt;<span class="type">Context</span>&gt; reference;
        public <span class="type">MyHandler</span>(<span class="type">Context</span> context) {
        reference = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;&gt;(context);
        }
        <span class="annotation">@Override</span>
        public void handleMessage(<span class="type">Message</span> msg) {
            <span class="type">MainActivity</span> activity = (<span class="type">MainActivity</span>) reference.get();
            <span class="keyword">if</span>(activity != <span class="literal">null</span>){
            activity.mTextView.setText(<span class="string">""</span>);
            }
        }
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        mTextView = (<span class="type">TextView</span>)findViewById(<span class="type">R</span>.id.textview);
        loadData();
    }

    <span class="keyword">private</span> void loadData() {
        <span class="comment">//...request</span>
        <span class="type">Message</span> message = <span class="type">Message</span>.obtain();
        mHandler.sendMessage(message);
    }
}
</code></pre><p>创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息，更准确的做法如下：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>
    <span class="keyword">private</span> <span class="type">MyHandler</span> mHandler = <span class="keyword">new</span> <span class="type">MyHandler</span>(<span class="keyword">this</span>);
    <span class="keyword">private</span> <span class="type">TextView</span> mTextView ;
    <span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Handler</span> {</span>
        <span class="keyword">private</span> <span class="type">WeakReference</span>&lt;<span class="type">Context</span>&gt; reference;
        public <span class="type">MyHandler</span>(<span class="type">Context</span> context) {
        reference = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;&gt;(context);
        }
        <span class="annotation">@Override</span>
        public void handleMessage(<span class="type">Message</span> msg) {
            <span class="type">MainActivity</span> activity = (<span class="type">MainActivity</span>) reference.get();
            <span class="keyword">if</span>(activity != <span class="literal">null</span>){
            activity.mTextView.setText(<span class="string">""</span>);
            }
        }
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);
        mTextView = (<span class="type">TextView</span>)findViewById(<span class="type">R</span>.id.textview);
        loadData();
    }

    <span class="keyword">private</span> void loadData() {
        <span class="comment">//...request</span>
        <span class="type">Message</span> message = <span class="type">Message</span>.obtain();
        mHandler.sendMessage(message);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onDestroy() {
        <span class="keyword">super</span>.onDestroy();
        mHandler.removeCallbacksAndMessages(<span class="literal">null</span>);
    }
}
</code></pre><p>使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages();来移除指定的Runnable和Message。</p>
<h4>线程造成的内存泄漏</h4>

<p>对于线程造成的内存泄漏，也是平时比较常见的，异步任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成，<br>那么将导致Activity的内存资源无法回收，造成内存泄漏。正确的做法还是使用静态内部类的方式，如下：</p>
<pre><code><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">Void</span>&gt; </span>{
    <span class="keyword">private</span> WeakReference&lt;Context&gt; weakReference;

    <span class="function"><span class="keyword">public</span> <span class="title">MyAsyncTask</span><span class="params">(Context context)</span> </span>{
        weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>{
        SystemClock.sleep(<span class="number">10000</span>);
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Void aVoid)</span> </span>{
        <span class="keyword">super</span>.onPostExecute(aVoid);
        MainActivity activity = (MainActivity) weakReference.get();
        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) {
        <span class="comment">//...</span>
        }
    }
}
<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        SystemClock.sleep(<span class="number">10000</span>);
    }
}
<span class="comment">//——————</span>
<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();
<span class="keyword">new</span> MyAsyncTask(<span class="keyword">this</span>).execute();
</code></pre><p>这样就避免了Activity的内存资源泄漏，当然在Activity销毁时候也应该取消相应的任务AsyncTask::cancel()，避免任务在后台执行浪费资源。</p>
<h4>资源未关闭造成的内存泄漏</h4>

<p>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>
<h4>一些建议</h4>

<ol>
<li>对于生命周期比Activity长的对象如果需要应该使用ApplicationContext</li>
<li>对于需要在静态内部类中使用非静态外部成员变量（如：Context、View )，可以在静态内部类中使用弱引用来引用外部类的变量来避免内存泄漏</li>
<li>对于不再需要使用的对象，显示的将其赋值为null，比如使用完Bitmap后先调用recycle()，再赋为null</li>
<li>保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期</li>
<li><p>对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏：</p>
<ol>
<li>将内部类改为静态内部类</li>
<li>静态内部类中使用弱引用来引用外部类的成员变量</li>
</ol>
</li>
<li><p>在涉及到Context时先考虑ApplicationContext，当然它并不是万能的，对于有些地方则必须使用Activity的Context，对于Application，Service，Activity三者的Context的应用场景如下：</p>
</li>
</ol>
<p><img src="http://img.blog.csdn.net/20151123144226349" alt=""></p>
<p><strong>其中：</strong>NO1表示Application和Service可以启动一个Activity，不过需要创建一个新的task任务队列。而对于Dialog而言，只有在Activity中才能创建</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>前言</h2>

<p>对于内存泄漏，我想大家在开发中肯定都遇到过，只不过内存泄漏对我们来说并不是可见的，因为它是在堆中活动，而要想检测程序中是否有内存泄漏的产生，通常我们可以借助LeakCanary、MAT等工具来检测应用程序是否存在内存泄漏，MAT是一款强大的内存分析工具，功能繁多而复杂，而LeakCanary则是由Square开源的一款轻量第三方内存泄漏检测工具，当它检测到程序中有内存泄漏的产生时，它将以最直观的方式告诉我们该内存泄漏是由谁产生的和该内存泄漏导致谁泄漏了而不能回收，供我们复查。</p>
<p>最近腾讯bugly也推出了三篇关于Android内存泄漏调优的文章：</p>
<ol>
<li><a href="http://bugly.qq.com/blog/?p=832">内存泄露从入门到精通三部曲之基础知识篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=872">内存泄露从入门到精通三部曲之排查方法篇</a></li>
<li><a href="http://bugly.qq.com/blog/?p=884">内存泄露从入门到精通三部曲之常见原因与用户实践</a></li>
</ol>
<p>Realm同样给出了性能优化文章：</p>
<p><a href="https://realm.io/cn/news/droidcon-farber-improving-android-app-performance/">10条提升Android性能的建议</a></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sublime Text自动开启换行Word Wrap]]></title>
    <link href="http://hanhailong.com/2015/11/24/Sublime-Text%E8%87%AA%E5%8A%A8%E5%BC%80%E5%90%AF%E6%8D%A2%E8%A1%8CWord-Wrap/"/>
    <id>http://hanhailong.com/2015/11/24/Sublime-Text自动开启换行Word-Wrap/</id>
    <published>2015-11-24T10:02:27.000Z</published>
    <updated>2015-11-24T10:22:38.000Z</updated>
    <content type="html"><![CDATA[<p>Sublime Text，绝对是神器中的神器，之前在windows电脑上一直都是用nodepad++。mac上也没找到太好的编辑工具，之前曾用过破解版的<em>UltraEdit</em>，但是自从第一次用了Sublime Text后，就彻底的把它打入冷宫了！！</p>
<p>下面讲讲如何开启Sublime Text的自动换行功能，默认情况下是不开启的。当然你也可以点击导航栏上View-&gt;Word Wrap开启，不过对我们程序猿来说，还是太麻烦了。这里从根本上解决自动换行的问题。</p>
<p>解决方案：<br>    我这里用的是mac版本的，windows同理</p>
<pre><code>Preferences-&gt;Setting - <span class="built_ins">User</span>
</code></pre><p>在打开的<em>Preferences.sublime-settings</em>文件里面，你将会看到类似下面的内容：</p>
<pre><code>{
    "<span class="attribute">ignored_packages</span>":
    <span class="value">[
        <span class="string">"Markdown"</span>,
        <span class="string">"Vintage"</span>
    ]
</span>}
</code></pre><p>很明显，这是一个json格式的配置文件，在后面直接追加</p>
<pre><code>{ "<span class="attribute">word_wrap</span>" : <span class="value"><span class="literal">true</span> </span>}
</code></pre><p>修改之后的文件内容为：</p>
<pre><code>{
    "<span class="attribute">ignored_packages</span>":
    <span class="value">[
        <span class="string">"Markdown"</span>,
        <span class="string">"Vintage"</span>
    ]</span>,
    "<span class="attribute">word_wrap</span>":<span class="value"><span class="literal">true</span>
</span>}
</code></pre><p>重启Sublime Text后，你将会发现文字、代码超过一行后会自动换行！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Sublime Text，绝对是神器中的神器，之前在windows电脑上一直都是用nodepad++。mac上也没找到太好的编辑工具，之前曾用过破解版的<em>UltraEdit</em>，但是自从第一次用了Sublime Text后，就彻底的把它打入冷宫了！！</p>
<]]>
    </summary>
    
      <category term="Sublime Text" scheme="http://hanhailong.com/tags/Sublime-Text/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-小米桌面图标显示角标数]]></title>
    <link href="http://hanhailong.com/2015/11/23/Android-%E5%B0%8F%E7%B1%B3%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA%E8%A7%92%E6%A0%87%E6%95%B0/"/>
    <id>http://hanhailong.com/2015/11/23/Android-小米桌面图标显示角标数/</id>
    <published>2015-11-23T07:07:11.000Z</published>
    <updated>2015-11-23T10:02:09.000Z</updated>
    <content type="html"><![CDATA[<h3>基本介绍</h3>

<p>最近有群里问：怎样在小米手机桌面的图标上显示角标数，我看了下我的红米note手机，果然有的第三方app图标上显示角标数，尤其是微信和QQ。这让我立马想到了：小米是不是对通知栏做了手脚。立马我查了相关文档并做了相关的测试，发现果然如我猜测的：MIUI系统对通知栏做了手脚。它目前有两种情况：</p>
<ol>
<li>默认情况<br> 当第三方app向通知栏发送一条通知（一般不带进度条并且用户可以删除的通知），那么此时app icon的角标数就会显示1。<br> 这个时候app显示的角标数和通知栏里app发送的通知数是对应的，即向通知栏发多少条通知就会显示多少角标数。</li>
</ol>
<a id="more"></a>
<ol>
<li><p>定义角标数量<br> 如果想让app在通知栏里只显示一条通知，但角标数是多个怎么办呢？</p>
<p> 原理是通过反射拿到<em>Notification</em>的私有属性<em>extraNotification</em>，重点就是这个<em>extraNotification</em>,MIUI系统对这个重定义了，这个类在MIUI系统里是<em>android.app.MiuiNotification</em>这个类，这个类里面有个私有属性<em>messageCount</em>,我们只要改变这个<em>messageCount</em>值就能显示的改变app icon的角标数了。如下图所示：</p>
</li>
</ol>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/miui_notification.png?raw=true" alt="miuinotification">    </p>
<p>这里给出代码示例：</p>
<pre><code><span class="type">NotificationCompat</span>.<span class="type">Builder</span> builder = new <span class="type">NotificationCompat</span>.<span class="type">Builder</span>(this)
            .setSmallIcon(R.mipmap.ic_launcher)
            .setContentTitle(<span class="string">"小米角标"</span>)
            .setContentText(<span class="string">"miui桌面角标消息"</span>);

    <span class="type">NotificationManagerCompat</span> managerCompat = <span class="type">NotificationManagerCompat</span>.<span class="keyword">from</span>(this);

    <span class="type">Notification</span> notification = builder.build();
    <span class="keyword">try</span> {
        <span class="type">Field</span> field = notification.getClass().getDeclaredField(<span class="string">"extraNotification"</span>);

        <span class="type">Object</span> extraNotification = field.get(notification);

        <span class="type">Method</span> <span class="keyword">method</span> = extraNotification.getClass().getDeclaredMethod(<span class="string">"setMessageCount"</span>, <span class="type">int</span>.class);

        <span class="keyword">method</span>.invoke(extraNotification, <span class="number">10</span>);
    } catch (<span class="type">Exception</span> e) {
          e.printStackTrace();
    }

    managerCompat.notify(<span class="number">0</span>, notification);
</code></pre><p>上面的数字10就是要显示的角标数，我们看下结果：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/miui_app_icon_count.png?raw=true" alt="app-icon"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3>基本介绍</h3>

<p>最近有群里问：怎样在小米手机桌面的图标上显示角标数，我看了下我的红米note手机，果然有的第三方app图标上显示角标数，尤其是微信和QQ。这让我立马想到了：小米是不是对通知栏做了手脚。立马我查了相关文档并做了相关的测试，发现果然如我猜测的：MIUI系统对通知栏做了手脚。它目前有两种情况：</p>
<ol>
<li>默认情况<br> 当第三方app向通知栏发送一条通知（一般不带进度条并且用户可以删除的通知），那么此时app icon的角标数就会显示1。<br> 这个时候app显示的角标数和通知栏里app发送的通知数是对应的，即向通知栏发多少条通知就会显示多少角标数。</li>
</ol>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-部分作品鉴赏]]></title>
    <link href="http://hanhailong.com/2015/11/04/Android-%E9%83%A8%E5%88%86%E4%BD%9C%E5%93%81%E9%89%B4%E8%B5%8F/"/>
    <id>http://hanhailong.com/2015/11/04/Android-部分作品鉴赏/</id>
    <published>2015-11-04T15:32:50.000Z</published>
    <updated>2015-11-04T15:56:09.000Z</updated>
    <content type="html"><![CDATA[<p>时间过得真快，马上快毕业四年了，这里整理了下我做过的部分App，当然还有一些其他的App，不是外包就是没有纪念意义，这里就不列举了！</p>
<a id="more"></a>
<h3>51拉勾</h3>

<p><a href="http://www.wandoujia.com/apps/com.ydcy.lago.app" target="_blank" rel="external">51拉钩</a>是我做过的第二个商业Android客户端App，承载了我很多记忆，现在还记得当初和小伙伴们加班到晚上11点、12点甚至凌晨两三点的情景（岁月不饶人啊~~~）！！！</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-1.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-2.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-3.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-4.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-5.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-6.png?raw=true" alt="家庭首页"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/lagou-7.png?raw=true" alt="家庭首页"></p>
<h3>51听听</h3>

<p><a href="http://www.wandoujia.com/apps/com.ydcy.ting.app" target="_blank" rel="external">51听听</a>是继51拉钩之后的又一个商业App，这个App比较有意思，里面包括大量童话、唐诗三百首等儿童教育方面的故事！！！</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-1.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-2.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-3.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-4.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-5.png?raw=true" alt="51听"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ting-6.png?raw=true" alt="51听"></p>
<h3>发镖</h3>

<p><a href="http://www.wandoujia.com/apps/com.cubead.appclient" target="_blank" rel="external">发镖</a>这是我加入北京博雅立方做过的唯一的一款App，包括IOS版本，这个App以前叫营销掌中宝，是国内首家最专业的营销推广平台，服务类目包括微信营销、百度营销、建站推广等多产品类目。</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-1.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-2.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-3.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-4.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-5.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-6.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-7.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-8.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-9.png?raw=true" alt="发镖"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/ying-10.png?raw=true" alt="发镖"></p>
<h3>极客学院</h3>

<p><a href="http://www.jikexueyuan.com/app/" target="_blank" rel="external">极客学院</a>，中国最大的IT职业在线教育平台！！</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-1.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-2.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-3.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-4.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-5.png?raw=true" alt="jike"></p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/collections_app/jike-6.png?raw=true" alt="jike"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>时间过得真快，马上快毕业四年了，这里整理了下我做过的部分App，当然还有一些其他的App，不是外包就是没有纪念意义，这里就不列举了！</p>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://hanhailong.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android版本-编译VLC]]></title>
    <link href="http://hanhailong.com/2015/10/27/Android%E7%89%88%E6%9C%AC-%E7%BC%96%E8%AF%91VLC/"/>
    <id>http://hanhailong.com/2015/10/27/Android版本-编译VLC/</id>
    <published>2015-10-27T13:54:31.000Z</published>
    <updated>2015-11-05T16:06:59.000Z</updated>
    <content type="html"><![CDATA[<h2>简述</h2>

<p>最近公司项目<a href="http://www.jikexueyuan.com/app/" target="_blank" rel="external">极客学院</a>在线播放器要加一个需求：支持播放倍数加速、支持字幕；之前用的是一个第三方的开源库<a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="external">ijkplayer</a>，这个库也非常的给力，它对ffmpeg做了很好的封装，不过不支持加速减速播放，所以弃用改成<a href="https://wiki.videolan.org/AndroidCompile" target="_blank" rel="external">VLC-Android</a>，IOS的在这<a href="https://wiki.videolan.org/IOSCompile" target="_blank" rel="external">VLC-IOS</a>.</p>
<a id="more"></a>
<p>这里记录下编译Android版本的过程和遇到的错误：</p>
<p>总体来说是比较顺利的，按照官方的wiki文档一步一步走下来，基本上没有遇到大问题，遇到唯一的问题是<a href="http://download.csdn.net/detail/hanhailong726188/9218615" target="_blank" rel="external">xz-5.0.3.tar.bz2</a>和<a href="http://download.csdn.net/detail/hanhailong726188/9218631" target="_blank" rel="external">protobuf-2.6.1.tar.gz</a>这两个库文件没有下载些来（因为被墙了），我单独下载安装的，这里我把这两个文件放到CSDN上了，有需要的自行下载！！</p>
<h2>编译过程</h2>

<p>编译的第一步肯定是需要下载一些必要的工具，如果你的系统是Linux，你可以通过api-get来安装：</p>
<pre><code><span class="label">sudo</span> apt-<span class="preprocessor">get</span> install automake ant autopoint cmake <span class="keyword">build-essential </span>libtool \
     patch pkg-config protobuf-compiler ragel <span class="keyword">subversion </span>unzip git
</code></pre><p>我这里用的是Mac Ox，所以采用<a href="http://brew.sh/" target="_blank" rel="external">HomeBrew</a>来安装，首先需要执行命令：</p>
<pre><code><span class="keyword">brew </span>install automake ant autopoint cmake <span class="keyword">build-essential </span>libtool \
     patch pkg-config protobuf-compiler ragel <span class="keyword">subversion </span>unzip git
</code></pre><p>然后等待上面的工具安装完成，安装完成后开始执行下一步</p>
<p>这里假设你已经装好<a href="http://developer.android.com/sdk/index.html" target="_blank" rel="external">Android SDK</a>和<a href="http://developer.android.com/tools/sdk/ndk/index.html" target="_blank" rel="external">Android NDK</a></p>
<h4>配置环境变量</h4>

<p>1.cd命令到当前用户目录下，打开.bash_profile文件：</p>
<pre><code><span class="title">cd</span> <span class="regexp">~
open</span> .bash_profile
</code></pre><p>如果没有.bash_profile，请touch新建一个.bash_profile</p>
<pre><code><span class="tag">touch</span> <span class="class">.bash_profile</span>
</code></pre><p>打开.bash_profile文件后，在文件里面输入</p>
<pre><code>export ANDROID_SDK=/Users/HanHailong/Library/Android/sdk
export ANDROID_NDK=/Users/HanHailong/NDK/android-ndk-r10e
export PATH=<span class="variable">$PATH</span>:<span class="variable">$ANDROID</span>_SDK/platform-tools:<span class="variable">$ANDROID</span>_SDK/tools
</code></pre><p>ANDROID_SDK和ANDROID_NDK后面的换成你自己对应的路径。</p>
<h4>克隆代码</h4>

<pre><code>git clone <span class="string">git:</span><span class="comment">//git.videolan.org/vlc-ports/android.git</span>
</code></pre><p></p><h5>编译工程</h5><br>将项目clone下来后就开始编译项目了，<br>cd命令到你clone下来的工程里面，执行命令：<p></p>
<pre><code>./compile.<span class="keyword">sh</span>
</code></pre><p>然后VLC会自动执行一长系列的下载、编译工作，这里需要等老长时间，如果你有vpn，最好开启vpn，因为一些用到的文件被墙了！！我这里就遇到坑了，<a href="http://download.csdn.net/detail/hanhailong726188/9218615" target="_blank" rel="external">xz-5.0.3.tar.bz2</a>和<a href="http://download.csdn.net/detail/hanhailong726188/9218631" target="_blank" rel="external">protobuf-2.6.1.tar.gz</a>下载失败，而导致VLC编译失败，没办法，只能将上面两个文件单独下载下来.</p>
<ol>
<li><p>解压并安装protobuf</p>
<p> 一步一步执行下面如下命令：</p>
<pre><code>tar -zxf protobuf-<span class="number">2.6</span><span class="number">.1</span>.tar.gz
cd protobuf-<span class="number">2.6</span><span class="number">.1</span>
./configure
make install
</code></pre></li>
</ol>
<ol>
<li><p>解压并安装xz</p>
<p> 一步一步执行下面如下命令：</p>
<pre><code>tar -zxf xz-<span class="number">5.0</span><span class="number">.3</span>.tar.bz2
cd xz-<span class="number">5.0</span><span class="number">.3</span>
./configure
make install
</code></pre></li>
</ol>
<p>执行完了后，继续回到VLC工程目录下执行命令：</p>
<pre><code>./compile.<span class="keyword">sh</span>
</code></pre><p>之后，VLC会继续执行下载、编译库文件，稍微等一段时间，快得几分钟，慢的十几分钟！！看编译成功后的截图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_android.png?raw=true" alt="VLC"></p>
<h4>编译结果</h4>

<p>编译成功后，会在<font color="red">vlc-android/build/outputs/apk</font>目录下生成编译后的apk包：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_apk.png?raw=true" alt="apk"></p>
<p>我们将其安装到真机上，效果图还是蛮不错的：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_1.png?raw=true" alt="image1"><br><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_2.png?raw=true" alt="image2"><br><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/vlc_3.png?raw=true" alt="image3"></p>
<p>VLC很强大，支持字幕，支持锁定屏幕，支持跳转到某个具体时间，支持0.25-4倍的慢放、快放、支持亮度调节、支持音量调节、支持快进、支持直播等特性，是做在线视频播放的绝佳选择之一！！！！</p>
<p>上面两个<a href="http://download.csdn.net/detail/hanhailong726188/9218615" target="_blank" rel="external">xz-5.0.3.tar.bz2</a>和<a href="http://download.csdn.net/detail/hanhailong726188/9218631" target="_blank" rel="external">protobuf-2.6.1.tar.gz</a>可以在这里下载！</p>
<p>最后，附上我编译好的项目<a href="https://github.com/hanhailong/VCL-Android" target="_blank" rel="external">VLC-Android</a>，这里我只编译了四种so包（armeabi-v7a、armeabi、x86、mips），有需要的朋友自行下载。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2>简述</h2>

<p>最近公司项目<a href="http://www.jikexueyuan.com/app/">极客学院</a>在线播放器要加一个需求：支持播放倍数加速、支持字幕；之前用的是一个第三方的开源库<a href="https://github.com/Bilibili/ijkplayer">ijkplayer</a>，这个库也非常的给力，它对ffmpeg做了很好的封装，不过不支持加速减速播放，所以弃用改成<a href="https://wiki.videolan.org/AndroidCompile">VLC-Android</a>，IOS的在这<a href="https://wiki.videolan.org/IOSCompile">VLC-IOS</a>.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不错的IOS学习博客网站-IOS122]]></title>
    <link href="http://hanhailong.com/2015/10/22/%E4%B8%8D%E9%94%99%E7%9A%84IOS%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99-IOS122/"/>
    <id>http://hanhailong.com/2015/10/22/不错的IOS学习博客网站-IOS122/</id>
    <published>2015-10-22T08:58:51.000Z</published>
    <updated>2015-10-22T09:07:09.000Z</updated>
    <content type="html"><![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第四篇，只不过<a href="http://www.ios122.com/" target="_blank" rel="external">IOS122</a>只讲解IOS技术。</p>
<p>当我第一次打开这个博客的时候，我被里面的第三库资源震惊了，没想到作者整理了这么多的第三库资源。最重要的是，里面的博文质量非常高，绝对是IOS学习技术的最佳去处！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第四篇，只不过<a href="http://www.ios122.com/" targe]]>
    </summary>
    
      <category term="技术博客" scheme="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[cocoapods安装失败-bad response Not Found 404 (http://ruby.taobao.org/latest_specs.4.8.gz]]></title>
    <link href="http://hanhailong.com/2015/10/22/cocoapods%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5-bad-response-Not-Found-404-http-ruby-taobao-org-latest-specs-4-8-gz/"/>
    <id>http://hanhailong.com/2015/10/22/cocoapods安装失败-bad-response-Not-Found-404-http-ruby-taobao-org-latest-specs-4-8-gz/</id>
    <published>2015-10-22T05:37:34.000Z</published>
    <updated>2015-10-22T06:17:49.000Z</updated>
    <content type="html"><![CDATA[<p>最近把MAC系统升级到了最新版本-10.11（OS X EI Capitan），发现之前装的<a href="https://github.com/CocoaPods/CocoaPods" target="_blank" rel="external">CocoaPods</a>不能用了，只好重新装了。执行如下命令：</p>
<pre><code>sudo gem <span class="keyword">install</span> cocoapods
</code></pre><p>发现报如下错误：<br><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/pod_error.png?raw=true" alt="image"></p>
<a id="more"></a>
<p>我之前就是用的淘宝的镜像<a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a>，我们在浏览器上输入：<a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a>，链接自动重定向到了<a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a>，淘宝镜像也给了提示：</p>
<p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/taobao_tips.png?raw=true" alt="image"></p>
<p>好吧，那我们只能删掉http的，改成https的，执行命令：</p>
<pre><code>gem sources --remove <span class="string">http:</span><span class="comment">//ruby.taobao.org/</span>
gem sources -a <span class="string">https:</span><span class="comment">//ruby.taobao.org/</span>
</code></pre><p>改掉之后我们继续使用命令查看我们改之后的ruby镜像：</p>
<pre><code>gem sources <span class="operator">-l</span>
</code></pre><p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/pod_new.png?raw=true" alt="image"></p>
<p>我们继续安装cocoapods，执行命令：</p>
<pre><code>sudo gem <span class="keyword">install</span> cocoapods
</code></pre><p>这时候会让你输入密码，输入密码完了之后就开始真正的安装cocoapods了</p>
<p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/pod_install.png?raw=true" alt="image"></p>
<p>安装完之后，执行命令：</p>
<pre><code>pod <span class="comment">--version</span>
</code></pre><p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/pod_version.png?raw=true" alt="image"></p>
<p>出现版本0.39.0之后，就说明安装成功了！！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近把MAC系统升级到了最新版本-10.11（OS X EI Capitan），发现之前装的<a href="https://github.com/CocoaPods/CocoaPods">CocoaPods</a>不能用了，只好重新装了。执行如下命令：</p>
<pre><code>sudo gem <span class="keyword">install</span> cocoapods
</code></pre><p>发现报如下错误：<br><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/cocoapods/pod_error.png?raw=true" alt="image"></p>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://hanhailong.com/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-教你自作一个简单而又实用的流式Tag标签布局]]></title>
    <link href="http://hanhailong.com/2015/10/20/Android-%E6%95%99%E4%BD%A0%E8%87%AA%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%80%8C%E5%8F%88%E5%AE%9E%E7%94%A8%E7%9A%84%E6%B5%81%E5%BC%8FTag%E6%A0%87%E7%AD%BE%E5%B8%83%E5%B1%80/"/>
    <id>http://hanhailong.com/2015/10/20/Android-教你自作一个简单而又实用的流式Tag标签布局/</id>
    <published>2015-10-20T10:26:19.000Z</published>
    <updated>2015-10-20T13:44:35.000Z</updated>
    <content type="html"><![CDATA[<p>在这一章节，我们继续学习Android自定义控件。这里要自定义的是Android里面的一个常用控件-Android流式Tag布局，这里我们命名为：<a href="https://github.com/hanhailong/FlowTag/blob/master/library/src/main/java/com/hhl/library/FlowTagLayout.java" target="_blank" rel="external">FlowTagLayout</a>，我们要实现的流式布局，有如下特色：</p>
<ul>
<li>填充数据和ListView、GridView用法一样使用Adapter，更新数据直接通过adapter.notifyDataChanged来更新</li>
<li>支持点击、单选、多选三种模式：FLOW_TAG_CHECKED_NONE、FLOW_TAG_CHECKED_SINGLE、FLOW_TAG_CHECKED_MULTI</li>
</ul>
<h3>正式讲解之前先看下我们实现后的效果图：</h3>

<p> <img src="https://github.com/hanhailong/AndroidStudyResources/raw/master/screenshot/flow_tag.gif?raw=true" alt="image"></p>
<a id="more"></a>
<p>目前网上有很多的教程来写流式布局实现，我看到的版本大体上有两种，一种是继承<font color="red">ViewGroup</font>，然后重写其<font color="red">onMeasure</font>和<font color="red">onLayout</font>方法，另一种则是继承自<font color="red">RelativeLayout</font>，例如这个<a href="https://github.com/kaedea/Android-Cloud-TagView-Plus/blob/master/library/src/main/java/me/kaede/tagview/TagView.java" target="_blank" rel="external">TagView</a></p>
<p>而我们这里采用的是第一种方法，因为我感觉第一种方法简单、清晰、明了！！</p>
<p>因为我们直接继承的<em>ViewGroup</em>，所以要指定它的<em>LayoutParams</em>，这里因为只需要margin，所以我们直接返回<em>MarginLayoutParams</em>就可以了，代码如下：</p>
<pre><code><span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> MarginLayoutParams(getContext(), attrs);
    }
</code></pre><h3>onMeasure测量</h3>

<pre><code>@<span class="function">Override
    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>{
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);

        <span class="comment">//获取Padding</span>
        <span class="comment">// 获得它的父容器为它设置的测量模式和大小</span>
        <span class="keyword">int</span> sizeWidth = MeasureSpec.getSize(widthMeasureSpec);
        <span class="keyword">int</span> sizeHeight = MeasureSpec.getSize(heightMeasureSpec);
        <span class="keyword">int</span> modeWidth = MeasureSpec.getMode(widthMeasureSpec);
        <span class="keyword">int</span> modeHeight = MeasureSpec.getMode(heightMeasureSpec);

        <span class="comment">//FlowLayout最终的宽度和高度值</span>
        <span class="keyword">int</span> resultWidth = <span class="number">0</span>;
        <span class="keyword">int</span> resultHeight = <span class="number">0</span>;

        <span class="comment">//测量时每一行的宽度</span>
        <span class="keyword">int</span> lineWidth = <span class="number">0</span>;
        <span class="comment">//测量时每一行的高度，加起来就是FlowLayout的高度</span>
        <span class="keyword">int</span> lineHeight = <span class="number">0</span>;

        <span class="comment">//遍历每个子元素</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, childCount = getChildCount(); i &lt; childCount; i++) {
            View childView = getChildAt(i);
            <span class="comment">//测量每一个子view的宽和高</span>
            measureChild(childView, widthMeasureSpec, heightMeasureSpec);

            <span class="comment">//获取到测量的宽和高</span>
            <span class="keyword">int</span> childWidth = childView.getMeasuredWidth();
            <span class="keyword">int</span> childHeight = childView.getMeasuredHeight();

            <span class="comment">//因为子View可能设置margin，这里要加上margin的距离</span>
            MarginLayoutParams mlp = (MarginLayoutParams) childView.getLayoutParams();
            <span class="keyword">int</span> realChildWidth = childWidth + mlp.leftMargin + mlp.rightMargin;
            <span class="keyword">int</span> realChildHeight = childHeight + mlp.topMargin + mlp.bottomMargin;

            <span class="comment">//如果当前一行的宽度加上要加入的子view的宽度大于父容器给的宽度，就换行</span>
            <span class="keyword">if</span> ((lineWidth + realChildWidth) &gt; sizeWidth) {
                <span class="comment">//换行</span>
                resultWidth = Math.max(lineWidth, realChildWidth);
                resultHeight += realChildHeight;
                <span class="comment">//换行了，lineWidth和lineHeight重新算</span>
                lineWidth = realChildWidth;
                lineHeight = realChildHeight;
            } <span class="keyword">else</span> {
                <span class="comment">//不换行，直接相加</span>
                lineWidth += realChildWidth;
                <span class="comment">//每一行的高度取二者最大值</span>
                lineHeight = Math.max(lineHeight, realChildHeight);
            }

            <span class="comment">//遍历到最后一个的时候，肯定走的是不换行</span>
            <span class="keyword">if</span> (i == childCount - <span class="number">1</span>) {
                resultWidth = Math.max(lineWidth, resultWidth);
                resultHeight += lineHeight;
            }

            setMeasuredDimension(modeWidth == MeasureSpec.EXACTLY ? sizeWidth : resultWidth,
                    modeHeight == MeasureSpec.EXACTLY ? sizeHeight : resultHeight);

        }

    }
</code></pre><p>代码注释的很详细，首先得到其父容器传入的测量模式和宽高的计算值，然后遍历所有的childView，使用measureChild方法对所有的childView进行测量。然后根据所有childView的测量得出的宽和高得到该ViewGroup如果设置为wrap_content时的宽和高</p>
<h3>onLayout</h3>

<pre><code>@<span class="function">Override
<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(boolean changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>{

    <span class="keyword">int</span> flowWidth = getWidth();

    <span class="keyword">int</span> childLeft = <span class="number">0</span>;
    <span class="keyword">int</span> childTop = <span class="number">0</span>;

    <span class="comment">//遍历子控件，记录每个子view的位置</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, childCount = getChildCount(); i &lt; childCount; i++) {
        View childView = getChildAt(i);

        <span class="comment">//跳过View.GONE的子View</span>
        <span class="keyword">if</span> (childView.getVisibility() == View.GONE) {
            <span class="keyword">continue</span>;
        }

        <span class="comment">//获取到测量的宽和高</span>
        <span class="keyword">int</span> childWidth = childView.getMeasuredWidth();
        <span class="keyword">int</span> childHeight = childView.getMeasuredHeight();

        <span class="comment">//因为子View可能设置margin，这里要加上margin的距离</span>
        MarginLayoutParams mlp = (MarginLayoutParams) childView.getLayoutParams();

        <span class="keyword">if</span> (childLeft + mlp.leftMargin + childWidth + mlp.rightMargin &gt; flowWidth) {
            <span class="comment">//换行处理</span>
            childTop += (mlp.topMargin + childHeight + mlp.bottomMargin);
            childLeft = <span class="number">0</span>;
        }
        <span class="comment">//布局</span>
        <span class="keyword">int</span> left = childLeft + mlp.leftMargin;
        <span class="keyword">int</span> top = childTop + mlp.topMargin;
        <span class="keyword">int</span> right = childLeft + mlp.leftMargin + childWidth;
        <span class="keyword">int</span> bottom = childTop + mlp.topMargin + childHeight;
        childView.layout(left, top, right, bottom);

        childLeft += (mlp.leftMargin + childWidth + mlp.rightMargin);
    }
}
</code></pre><p>onLayout方法就是将子View摆放到FlowTagLayout中，核心就是childView.layout(l,t,r,b)方法。</p>
<p>测量完了，布局也完了，下面就是填充数据了，我们这里采用的是Adapter模式，用法基本上和我们常用的ListView、GridView一样，用户只要写一个适配器Adapter，然后调用xxx.setAdapter方法，就把数据源绑到控件上了，而且这种做法还有个好处：子View可以是任意类型的控件</p>
<h3>填充数据和ListView、GridView用法一样使用Adapter，更新数据直接通过adapter.notifyDataChanged来更新</h3>

<p>我研究了下ListView和GridView的adapter.notifyDataChanged实现，一句话：观察者模式！首先，我们要在<em>FlowTagLayout</em>里面注册一个观察者，当我们调用adapter.notifyDataChanged的时候能通知这个观察者来刷新页面。</p>
<pre><code><span class="comment">/**
     * 像ListView、GridView一样使用FlowLayout
     *
     * <span class="doctag">@param</span> adapter
     */</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(ListAdapter adapter)</span> </span>{
        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span> &amp;&amp; mDataSetObserver != <span class="keyword">null</span>) {
            mAdapter.unregisterDataSetObserver(mDataSetObserver);
        }

        <span class="comment">//清除现有的数据</span>
        removeAllViews();
        mAdapter = adapter;

        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) {
            mDataSetObserver = <span class="keyword">new</span> AdapterDataSetObserver();
            mAdapter.registerDataSetObserver(mDataSetObserver);
        }
    }
</code></pre><p> 方法                mAdapter.registerDataSetObserver(mDataSetObserver);<br>就注册了观察者，我们继续看：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">AdapterDataSetObserver</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">DataSetObserver</span> {</span>
        <span class="annotation">@Override</span>
        public void onChanged() {
            <span class="keyword">super</span>.onChanged();
            reloadData();
        }

        <span class="annotation">@Override</span>
        public void onInvalidated() {
            <span class="keyword">super</span>.onInvalidated();
        }
    }
</code></pre><p>当我们调用adapter.notifyDataChanged方法的时候，就会执行<em>onChanged</em>这个方法，我加了一个<em>reloadData</em>方法：</p>
<pre><code><span class="comment">/**
     * 重新加载刷新数据
     */</span>
    <span class="keyword">private</span> <span class="keyword">void</span> reloadData() {
        removeAllViews();

        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; mAdapter.getCount(); i++) {
            <span class="keyword">final</span> <span class="built_in">int</span> j = i;
            mCheckedTagArray.put(i, <span class="keyword">false</span>);
            <span class="keyword">final</span> View childView = mAdapter.getView(i, <span class="keyword">null</span>, <span class="keyword">this</span>);
            addView(childView, <span class="keyword">new</span> MarginLayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
            <span class="keyword">final</span> <span class="built_in">int</span> finalI = i;
            childView.setOnClickListener(<span class="keyword">new</span> OnClickListener() {
                @Override
                <span class="keyword">public</span> <span class="keyword">void</span> onClick(View v) {
                    <span class="keyword">if</span> (mTagCheckMode == FLOW_TAG_CHECKED_NONE) {
                        <span class="keyword">if</span> (mOnTagClickListener != <span class="keyword">null</span>) {
                            mOnTagClickListener.onItemClick(FlowTagLayout.<span class="keyword">this</span>, childView, j);
                        }
                    } <span class="keyword">else</span> <span class="keyword">if</span> (mTagCheckMode == FLOW_TAG_CHECKED_SINGLE) {
                        <span class="comment">//判断状态</span>
                        <span class="keyword">if</span> (mCheckedTagArray.<span class="built_in">get</span>(j)) {
                            mCheckedTagArray.put(j, <span class="keyword">false</span>);
                            childView.setSelected(<span class="keyword">false</span>);
                            <span class="keyword">if</span> (mOnTagSelectListener != <span class="keyword">null</span>) {
                                mOnTagSelectListener.onItemSelect(FlowTagLayout.<span class="keyword">this</span>, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());
                            }
                            <span class="keyword">return</span>;
                        }

                        <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; mAdapter.getCount(); k++) {
                            mCheckedTagArray.put(k, <span class="keyword">false</span>);
                            getChildAt(k).setSelected(<span class="keyword">false</span>);
                        }
                        mCheckedTagArray.put(j, <span class="keyword">true</span>);
                        childView.setSelected(<span class="keyword">true</span>);

                        <span class="keyword">if</span> (mOnTagSelectListener != <span class="keyword">null</span>) {
                            mOnTagSelectListener.onItemSelect(FlowTagLayout.<span class="keyword">this</span>, Arrays.asList(j));
                        }
                    } <span class="keyword">else</span> <span class="keyword">if</span> (mTagCheckMode == FLOW_TAG_CHECKED_MULTI) {
                        <span class="keyword">if</span> (mCheckedTagArray.<span class="built_in">get</span>(j)) {
                            mCheckedTagArray.put(j, <span class="keyword">false</span>);
                            childView.setSelected(<span class="keyword">false</span>);
                        } <span class="keyword">else</span> {
                            mCheckedTagArray.put(j, <span class="keyword">true</span>);
                            childView.setSelected(<span class="keyword">true</span>);
                        }
                        <span class="comment">//回调</span>
                        <span class="keyword">if</span> (mOnTagSelectListener != <span class="keyword">null</span>) {
                            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();
                            <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; mAdapter.getCount(); k++) {
                                <span class="keyword">if</span> (mCheckedTagArray.<span class="built_in">get</span>(k)) {
                                    list.<span class="built_in">add</span>(k);
                                }
                            }
                            mOnTagSelectListener.onItemSelect(FlowTagLayout.<span class="keyword">this</span>, list);
                        }
                    }
                }
            });
        }
    }
</code></pre><p>这个方法的作用就是重新加载子View，先是移除所有的子View，然后从<em>Adapter</em>中获取子View，addView到FlowTagLayout中，在这个过程中，我们给每个子View添加了点击事件，点击事件里面的逻辑很简单，就是根据<em>FlowTagLayout</em>的三种模式分别处理单击、单选、多选逻辑，三种模式分别为：</p>
<pre><code><span class="comment">/**
     * FlowLayout not support checked
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLOW_TAG_CHECKED_NONE = <span class="number">0</span>;
    <span class="comment">/**
     * FlowLayout support single-select
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLOW_TAG_CHECKED_SINGLE = <span class="number">1</span>;
    <span class="comment">/**
     * FlowLayout support multi-select
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLOW_TAG_CHECKED_MULTI = <span class="number">2</span>;
</code></pre><p>为了使单击、单选、多选事件通知到Activity、Fragment，我们加入了两个监听方法：</p>
<pre><code><span class="comment">/**
 * Created by HanHailong on 15/10/20.
 */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">OnTagClickListener</span> {
    <span class="function"><span class="keyword">void</span> <span class="title">onItemClick</span>(<span class="params">FlowTagLayout parent, View view, <span class="keyword">int</span> position</span>)</span>;
}
</code></pre><p>和</p>
<pre><code><span class="comment">/**
 * Created by HanHailong on 15/10/20.
 */</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">OnTagSelectListener</span> {
    <span class="function"><span class="keyword">void</span> <span class="title">onItemSelect</span>(<span class="params">FlowTagLayout parent, List&lt;Integer&gt; selectedList</span>)</span>;
}
</code></pre><p>改写的都写了，我们怎么使用呢？请继续往下看</p>
<h3>用法</h3>

<p>首先，我们先写一个适配器<em>TagAdapter</em>，写法完全和写ListView的适配器一样：</p>
<pre><code><span class="comment">/**
 * Created by HanHailong on 15/10/19.
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TagAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>{

    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;
    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; mDataList;

    <span class="function"><span class="keyword">public</span> <span class="title">TagAdapter</span><span class="params">(Context context)</span> </span>{
        <span class="keyword">this</span>.mContext = context;
        mDataList = <span class="keyword">new</span> ArrayList&lt;&gt;();
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>{
        <span class="function"><span class="keyword">return</span> mDataList.<span class="title">size</span><span class="params">()</span></span>;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">Object <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>{
        <span class="function"><span class="keyword">return</span> mDataList.<span class="title">get</span><span class="params">(position)</span></span>;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>{
        <span class="keyword">return</span> position;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>{

        View view = LayoutInflater.from(mContext).inflate(R.layout.tag_item, <span class="keyword">null</span>);

        TextView textView = (TextView) view.findViewById(R.id.tv_tag);
        T t = mDataList.get(position);

        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> String) {
            textView.setText((String) t);
        }
        <span class="keyword">return</span> view;
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onlyAddAll</span><span class="params">(List&lt;T&gt; datas)</span> </span>{
        mDataList.addAll(datas);
        notifyDataSetChanged();
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">clearAndAddAll</span><span class="params">(List&lt;T&gt; datas)</span> </span>{
        mDataList.clear();
        onlyAddAll(datas);
    }
}
</code></pre><h4>布局tag_item.xml</h4>

<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>&gt;</span>

    <span class="tag">&lt;<span class="title">TextView</span>
        <span class="attribute">android:id</span>=<span class="value">"@+id/tv_tag"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_marginLeft</span>=<span class="value">"10dp"</span>
        <span class="attribute">android:layout_marginTop</span>=<span class="value">"10dp"</span>
        <span class="attribute">android:background</span>=<span class="value">"@drawable/round_rectangle_bg"</span>
        <span class="attribute">android:paddingBottom</span>=<span class="value">"5dp"</span>
        <span class="attribute">android:paddingLeft</span>=<span class="value">"10dp"</span>
        <span class="attribute">android:paddingRight</span>=<span class="value">"10dp"</span>
        <span class="attribute">android:paddingTop</span>=<span class="value">"5dp"</span>
        <span class="attribute">android:text</span>=<span class="value">"TAG标签"</span>
        <span class="attribute">android:textColor</span>=<span class="value">"@color/normal_text_color"</span> /&gt;</span>

<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>再看我们引用<em>FlowTagLayout</em>的主布局代码：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">ScrollView</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">xmlns:app</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span>
    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>
    <span class="attribute">android:fillViewport</span>=<span class="value">"true"</span>
    <span class="attribute">app:layout_behavior</span>=<span class="value">"@string/appbar_scrolling_view_behavior"</span>
    <span class="attribute">tools:context</span>=<span class="value">".MainActivity"</span>
    <span class="attribute">tools:showIn</span>=<span class="value">"@layout/activity_main"</span>&gt;</span>

    <span class="tag">&lt;<span class="title">LinearLayout</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>
        <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
        <span class="attribute">android:paddingBottom</span>=<span class="value">"30dp"</span>&gt;</span>

        <span class="tag">&lt;<span class="title">LinearLayout</span>
            <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
            <span class="attribute">android:orientation</span>=<span class="value">"horizontal"</span>&gt;</span>

            <span class="tag">&lt;<span class="title">TextView</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_margin</span>=<span class="value">"10dp"</span>
                <span class="attribute">android:text</span>=<span class="value">"颜色\n(点击)"</span> /&gt;</span>

            <span class="tag">&lt;<span class="title">com.hhl.library.FlowTagLayout</span>
                <span class="attribute">android:id</span>=<span class="value">"@+id/color_flow_layout"</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>

        <span class="tag">&lt;<span class="title">LinearLayout</span>
            <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
            <span class="attribute">android:layout_marginTop</span>=<span class="value">"10dp"</span>
            <span class="attribute">android:orientation</span>=<span class="value">"horizontal"</span>&gt;</span>

            <span class="tag">&lt;<span class="title">TextView</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_margin</span>=<span class="value">"10dp"</span>
                <span class="attribute">android:text</span>=<span class="value">"尺寸\n(单选)"</span> /&gt;</span>

            <span class="tag">&lt;<span class="title">com.hhl.library.FlowTagLayout</span>
                <span class="attribute">android:id</span>=<span class="value">"@+id/size_flow_layout"</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>

        <span class="tag">&lt;<span class="title">LinearLayout</span>
            <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
            <span class="attribute">android:layout_marginTop</span>=<span class="value">"10dp"</span>
            <span class="attribute">android:orientation</span>=<span class="value">"horizontal"</span>&gt;</span>

            <span class="tag">&lt;<span class="title">TextView</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_margin</span>=<span class="value">"10dp"</span>
                <span class="attribute">android:text</span>=<span class="value">"移动\n(多选)"</span> /&gt;</span>

            <span class="tag">&lt;<span class="title">com.hhl.library.FlowTagLayout</span>
                <span class="attribute">android:id</span>=<span class="value">"@+id/mobile_flow_layout"</span>
                <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
                <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span>
        <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>

    <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>

<span class="tag">&lt;/<span class="title">ScrollView</span>&gt;</span>
</code></pre><p>最后，我们看Activity里面是怎么使用的：</p>
<pre><code><span class="keyword">package</span> com.hhl.flowlayoutdemo;

<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.support.design.widget.FloatingActionButton;
<span class="keyword">import</span> android.support.design.widget.Snackbar;
<span class="keyword">import</span> android.support.v7.app.AppCompatActivity;
<span class="keyword">import</span> android.support.v7.widget.Toolbar;
<span class="keyword">import</span> android.view.Menu;
<span class="keyword">import</span> android.view.MenuItem;
<span class="keyword">import</span> android.view.View;

<span class="keyword">import</span> com.hhl.library.FlowTagLayout;
<span class="keyword">import</span> com.hhl.library.OnTagClickListener;
<span class="keyword">import</span> com.hhl.library.OnTagSelectListener;

<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.List;

<span class="keyword">public</span> class MainActivity extends AppCompatActivity {

    <span class="keyword">private</span> FlowTagLayout mColorFlowTagLayout;
    <span class="keyword">private</span> FlowTagLayout mSizeFlowTagLayout;
    <span class="keyword">private</span> FlowTagLayout mMobileFlowTagLayout;
    <span class="keyword">private</span> TagAdapter&lt;<span class="keyword">String</span>&gt; mSizeTagAdapter;
    <span class="keyword">private</span> TagAdapter&lt;<span class="keyword">String</span>&gt; mColorTagAdapter;
    <span class="keyword">private</span> TagAdapter&lt;<span class="keyword">String</span>&gt; mMobileTagAdapter;

    @Override
    <span class="keyword">protected</span> <span class="keyword">void</span> onCreate(Bundle savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
        fab.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
            @Override
            <span class="keyword">public</span> <span class="keyword">void</span> onClick(View view) {
                Snackbar.make(view, <span class="string">"Replace with your own action"</span>, Snackbar.LENGTH_LONG)
                        .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
            }
        });

        mColorFlowTagLayout = (FlowTagLayout) findViewById(R.id.color_flow_layout);
        mSizeFlowTagLayout = (FlowTagLayout) findViewById(R.id.size_flow_layout);
        mMobileFlowTagLayout = (FlowTagLayout) findViewById(R.id.mobile_flow_layout);

        <span class="comment">//颜色</span>
        mColorTagAdapter = <span class="keyword">new</span> TagAdapter&lt;&gt;(<span class="keyword">this</span>);
        mColorFlowTagLayout.setAdapter(mColorTagAdapter);
        mColorFlowTagLayout.setOnTagClickListener(<span class="keyword">new</span> OnTagClickListener() {
            @Override
            <span class="keyword">public</span> <span class="keyword">void</span> onItemClick(FlowTagLayout parent, View view, <span class="built_in">int</span> position) {
                Snackbar.make(view, <span class="string">"颜色:"</span> + parent.getAdapter().getItem(position), Snackbar.LENGTH_LONG)
                        .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
            }
        });

        <span class="comment">//尺寸</span>
        mSizeTagAdapter = <span class="keyword">new</span> TagAdapter&lt;&gt;(<span class="keyword">this</span>);
        mSizeFlowTagLayout.setTagCheckedMode(FlowTagLayout.FLOW_TAG_CHECKED_SINGLE);
        mSizeFlowTagLayout.setAdapter(mSizeTagAdapter);
        mSizeFlowTagLayout.setOnTagSelectListener(<span class="keyword">new</span> OnTagSelectListener() {
            @Override
            <span class="keyword">public</span> <span class="keyword">void</span> onItemSelect(FlowTagLayout parent, List&lt;Integer&gt; selectedList) {
                <span class="keyword">if</span> (selectedList != <span class="keyword">null</span> &amp;&amp; selectedList.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {
                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();
                    <span class="keyword">for</span> (<span class="built_in">int</span> i : selectedList) {
                        sb.<span class="built_in">append</span>(parent.getAdapter().getItem(i));
                        sb.<span class="built_in">append</span>(<span class="string">":"</span>);
                    }
                    Snackbar.make(parent, <span class="string">"移动研发:"</span> + sb.toString(), Snackbar.LENGTH_LONG)
                            .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
                }<span class="keyword">else</span>{
                    Snackbar.make(parent, <span class="string">"没有选择标签"</span>, Snackbar.LENGTH_LONG)
                            .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
                }
            }
        });

        <span class="comment">//移动研发标签</span>
        mMobileTagAdapter = <span class="keyword">new</span> TagAdapter&lt;&gt;(<span class="keyword">this</span>);
        mMobileFlowTagLayout.setTagCheckedMode(FlowTagLayout.FLOW_TAG_CHECKED_MULTI);
        mMobileFlowTagLayout.setAdapter(mMobileTagAdapter);
        mMobileFlowTagLayout.setOnTagSelectListener(<span class="keyword">new</span> OnTagSelectListener() {
            @Override
            <span class="keyword">public</span> <span class="keyword">void</span> onItemSelect(FlowTagLayout parent, List&lt;Integer&gt; selectedList) {
                <span class="keyword">if</span> (selectedList != <span class="keyword">null</span> &amp;&amp; selectedList.<span class="built_in">size</span>() &gt; <span class="number">0</span>) {
                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();

                    <span class="keyword">for</span> (<span class="built_in">int</span> i : selectedList) {
                        sb.<span class="built_in">append</span>(parent.getAdapter().getItem(i));
                        sb.<span class="built_in">append</span>(<span class="string">":"</span>);
                    }
                    Snackbar.make(parent, <span class="string">"移动研发:"</span> + sb.toString(), Snackbar.LENGTH_LONG)
                            .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
                }<span class="keyword">else</span>{
                    Snackbar.make(parent, <span class="string">"没有选择标签"</span>, Snackbar.LENGTH_LONG)
                            .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();
                }
            }
        });

        initColorData();

        initSizeData();

        initMobileData();
    }

    <span class="keyword">private</span> <span class="keyword">void</span> initMobileData() {
        List&lt;<span class="keyword">String</span>&gt; dataSource = <span class="keyword">new</span> ArrayList&lt;&gt;();
        dataSource.<span class="built_in">add</span>(<span class="string">"android"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"安卓"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"SDK源码"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"IOS"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"iPhone"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"游戏"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"fragment"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"viewcontroller"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"cocoachina"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"移动研发工程师"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"移动互联网"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"高薪+期权"</span>);
        mMobileTagAdapter.onlyAddAll(dataSource);
    }

    <span class="keyword">private</span> <span class="keyword">void</span> initColorData() {
        List&lt;<span class="keyword">String</span>&gt; dataSource = <span class="keyword">new</span> ArrayList&lt;&gt;();
        dataSource.<span class="built_in">add</span>(<span class="string">"红色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"黑色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"花边色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"深蓝色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"白色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"玫瑰红色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"紫黑紫兰色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"葡萄红色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"屎黄色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"绿色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"彩虹色"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"牡丹色"</span>);
        mColorTagAdapter.onlyAddAll(dataSource);
    }

    <span class="comment">/**
     * 初始化数据
     */</span>
    <span class="keyword">private</span> <span class="keyword">void</span> initSizeData() {
        List&lt;<span class="keyword">String</span>&gt; dataSource = <span class="keyword">new</span> ArrayList&lt;&gt;();
        dataSource.<span class="built_in">add</span>(<span class="string">"28 (2.1尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"29 (2.2尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"30 (2.3尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"31 (2.4尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"32 (2.5尺)........"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"33 (2.6尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"34 (2.7尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"35 (2.8尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"36 (2.9尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"37 (3.0尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"38 (3.1尺)"</span>);
        dataSource.<span class="built_in">add</span>(<span class="string">"39 (3.2尺)........"</span>);
        mSizeTagAdapter.onlyAddAll(dataSource);
    }

    @Override
    <span class="keyword">public</span> <span class="built_in">boolean</span> onCreateOptionsMenu(Menu menu) {
        <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span>
        getMenuInflater().inflate(R.menu.menu_main, menu);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    @Override
    <span class="keyword">public</span> <span class="built_in">boolean</span> onOptionsItemSelected(MenuItem item) {
        <span class="comment">// Handle action bar item clicks here. The action bar will</span>
        <span class="comment">// automatically handle clicks on the Home/Up button, so long</span>
        <span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span>
        <span class="built_in">int</span> id = item.getItemId();

        <span class="comment">//noinspection SimplifiableIfStatement</span>
        <span class="keyword">if</span> (id == R.id.action_settings) {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }

        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);
    }
}
</code></pre><p>好了，一个简单而实用的流式标签就轻松搞定了！！</p>
<h3>TODO</h3>

<ul>
<li>添加初始化选中标签</li>
<li>添加tag样式支持（颜色、图标等等）</li>
<li>像ListView、GridView一样复用子View</li>
<li>其他…</li>
</ul>
<p>如果你觉得本篇博客对你有用，那么就留个言或者顶一个~~</p>
<p>最后，附上github源码<a href="https://github.com/hanhailong/FlowTag" target="_blank" rel="external">FlowTagLayout</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这一章节，我们继续学习Android自定义控件。这里要自定义的是Android里面的一个常用控件-Android流式Tag布局，这里我们命名为：<a href="https://github.com/hanhailong/FlowTag/blob/master/library/src/main/java/com/hhl/library/FlowTagLayout.java">FlowTagLayout</a>，我们要实现的流式布局，有如下特色：</p>
<ul>
<li>填充数据和ListView、GridView用法一样使用Adapter，更新数据直接通过adapter.notifyDataChanged来更新</li>
<li>支持点击、单选、多选三种模式：FLOW_TAG_CHECKED_NONE、FLOW_TAG_CHECKED_SINGLE、FLOW_TAG_CHECKED_MULTI</li>
</ul>
<h3>正式讲解之前先看下我们实现后的效果图：</h3>

<p> <img src="https://github.com/hanhailong/AndroidStudyResources/raw/master/screenshot/flow_tag.gif?raw=true" alt="image"></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Support Library 23.1 now available]]></title>
    <link href="http://hanhailong.com/2015/10/19/Android-Support-Library-23-1-now-available/"/>
    <id>http://hanhailong.com/2015/10/19/Android-Support-Library-23-1-now-available/</id>
    <published>2015-10-19T02:50:32.000Z</published>
    <updated>2015-10-19T03:14:48.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Support V4</strong> gets a number of important bug fixes as well as a few new features for NestedScrollView and around MediaSessionCompat.</p>
<p><strong>Media Router</strong> has gotten a design overhaul, making connecting and controlling remote devices such as Google Cast enabled devices even easier.</p>
<p><strong>RecyclerView</strong> has a significant <strong>backward incompatible</strong> change to the animation system, offering new flexibility and support for item content animations. You’ll find a SimpleItemAnimator helper class for easing the transition to the new animation system.</p>
<p><strong>AppCompat</strong> adds a new tint aware <em>Seekbar</em>, <em>ImageButton</em>, and <em>ImageView</em> and updating styling to <em>SwitchCompat</em>.</p>
<p><strong>Design</strong> improves TextInputLayout with support for character counting, the new <em>SCROLL_FLAG_SNAP</em> allows <em>AppBarLayout</em> children to snap completely on or off the screen when scrolling completes, and <em>NavigationView</em> now supports custom views for menu items.</p>
<p><strong>Percent</strong> adds support for <em>setting a custom aspect ratio</em> to both <em>PercentFrameLayout</em> and <em>PercentRelativeLayout</em>.</p>
<p><strong>Custom Tabs</strong> increases the customization available with the ability to hide the URL bar when scrolling down and change the custom action button for current custom tab session as well as the ability to receive tab shown and hidden events.</p>
<p><strong>Leanback</strong> updates <em>GuidedStepFragment</em> so it can be placed on top of existing content and adds new search completion type annotations for SearchFragment.﻿</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Support V4</strong> gets a number of important bug fixes as well as a few new features for NestedScrollView and around MediaSessi]]>
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
      <category term="Android咨询" scheme="http://hanhailong.com/tags/Android%E5%92%A8%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-一步一步教你自定义IOS样式的UISwitch]]></title>
    <link href="http://hanhailong.com/2015/10/17/Android-%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%99%E4%BD%A0%E8%87%AA%E5%AE%9A%E4%B9%89IOS%E6%A0%B7%E5%BC%8F%E7%9A%84UISwitch/"/>
    <id>http://hanhailong.com/2015/10/17/Android-一步一步教你自定义IOS样式的UISwitch/</id>
    <published>2015-10-17T13:08:13.000Z</published>
    <updated>2015-10-18T16:59:54.000Z</updated>
    <content type="html"><![CDATA[<p>在这一章节，我们将开始在Android上做一个IOS风格的UISwitch控件。这篇文章主要涉及如下知识点：</p>
<ol>
<li>Android属性动画Animator</li>
<li>自定义手势GestureDetector</li>
<li>自定义View属性attrs</li>
</ol>
<p>首先，让我们来看一下效果图：</p>
<p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/uiswitch.gif?raw=true" alt="uiswitch"></p>
<a id="more"></a>
<h3>自定义View属性</h3>

<p>接下来，我们要先新建<font color="red">IOSSwitchView</font>类，继承自View类，重写其构造方法，代码如下：</p>
<pre><code><span class="comment">/**
 * 高仿IOS风格的UISwitchView
 * Created by HanHailong on 15/10/15.
 */</span>
public <span class="class"><span class="keyword">class</span> <span class="title">IOSSwitchView</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">View</span> {</span>
    public <span class="type">IOSSwitchView</span>(<span class="type">Context</span> context) {
        <span class="keyword">this</span>(context, <span class="literal">null</span>);
    }

    public <span class="type">IOSSwitchView</span>(<span class="type">Context</span> context, <span class="type">AttributeSet</span> attrs) {
        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);
    }

    public <span class="type">IOSSwitchView</span>(<span class="type">Context</span> context, <span class="type">AttributeSet</span> attrs, int defStyleAttr) {
        <span class="keyword">super</span>(context, attrs, defStyleAttr);
        init(context, attrs);
    }
}
</code></pre><p>然后，自定义我们需要的View属性，代码如下：</p>
<!-- IOSSwitchView -->
<pre><code><span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"IOSSwitchView"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"tintColor"</span> <span class="attribute">format</span>=<span class="value">"reference|color"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"thumbTintColor"</span> <span class="attribute">format</span>=<span class="value">"reference|color"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"strokeWidth"</span> <span class="attribute">format</span>=<span class="value">"reference|dimension"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"isOn"</span> <span class="attribute">format</span>=<span class="value">"reference|boolean"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span>
</code></pre><p>其中，<font color="red">tintColor</font>是Switch控件选中的颜色，，<font color="red">thumbTintColor</font>是里面可拖动开关扳手的颜色，，<font color="red">strokeWidth</font>是开关扳手的外边距宽度，<font color="red">isOn</font>是开关的打开状态，true是打开状态，false是关闭状态。</p>
<p>代码里怎么接收在布局里设置的属性值呢？答案：<font color="red">TypedArray</font>，我们继续看代码：</p>
<pre><code><span class="title">TypedArray</span> a = context.obtainStyledAttributes(attrs, R.styleable.IOSSwitchView);
       <span class="title">mTintColor</span> = a.getColor(R.styleable.IOSSwitchView_tintColor, Color.GREEN);
       <span class="title">mThumbTintColor</span> = a.getColor(R.styleable.IOSSwitchView_thumbTintColor, Color.WHITE);

       <span class="title">int</span> defaultStrokeWidth = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">1</span>.5f, context.getResources()
               .getDisplayMetrics());
       <span class="title">mStrokeWidth</span> = a.getDimensionPixelOffset(R.styleable.IOSSwitchView_strokeWidth, defaultStrokeWidth);
       <span class="title">isOn</span> = a.getBoolean(R.styleable.IOSSwitchView_isOn, <span class="built_in">false</span>);
</code></pre><p>上面的代码都很简单，都是自定义View常规的步骤，接下来我们再看添加动画的代码，看我们的gif效果图，你会发现，中间的开关把手在你手指点击它（此时没松手）的时候，它会有一个拉伸的动画，松手的时候，它会移动到另一侧，所以我们这里需要两个属性动画，一个是：拉伸动画，一个是移动动画。另外，因为我们这里有个背景颜色的变化：在默认关闭的情况下，背景色是灰白色的，打开的情况下是我们设置的tintColor颜色的，这里我们采用的是画了两个圆角矩形实现的，先画的tintColor颜色的圆角矩形，后画的灰白色的圆角矩形，刚开始开关关闭的时候灰白色的圆角矩形完全覆盖在上面，此时它的大小和它下面的矩形大小是一样的，之后在我们打开开关thumb的时候，灰白色的圆角矩形大小变成0，这样我们就看到tintColor颜色的圆角矩形了，这就实现了我们的背景切换。所以，这里又加了一个属性动画：灰白色圆角矩形的放大缩小动画。介绍到这里，我们总算理清了，我们要实现三个动画：一个thumb拉伸动画、一个thumb位移动画、一个灰白色圆角矩形形变动画（放大缩小动画）。这里我们添加初始化动画代码：</p>
<pre><code><span class="comment">//灰白色矩形形变动画</span>
        mInnerContentAnimator = ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="keyword">new</span> Property&lt;IOSSwitchView, Float&gt;(Float.class, <span class="string">"innerbound"</span>) {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">IOSSwitchView <span class="keyword">object</span>, Float <span class="keyword">value</span></span>) </span>{
                <span class="keyword">object</span>.setInnerContentRate(<span class="keyword">value</span>);
            }

            @<span class="function">Override
            <span class="keyword">public</span> Float <span class="title">get</span>(<span class="params">IOSSwitchView <span class="keyword">object</span></span>) </span>{
                <span class="keyword">return</span> <span class="keyword">object</span>.getInnerContentRate();
            }
        }, innerContentRate, <span class="number">1.0</span>f);
        mInnerContentAnimator.setDuration(<span class="number">300</span>);
        mInnerContentAnimator.setInterpolator(<span class="keyword">new</span> DecelerateInterpolator());

        <span class="comment">//thumb拉伸动画</span>
        mThumbExpandAnimator = ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="keyword">new</span> Property&lt;IOSSwitchView, Float&gt;(Float.class, <span class="string">"thumbExpand"</span>) {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">IOSSwitchView <span class="keyword">object</span>, Float <span class="keyword">value</span></span>) </span>{
                <span class="keyword">object</span>.setThumbExpandRate(<span class="keyword">value</span>);
            }

            @<span class="function">Override
            <span class="keyword">public</span> Float <span class="title">get</span>(<span class="params">IOSSwitchView <span class="keyword">object</span></span>) </span>{
                <span class="keyword">return</span> <span class="keyword">object</span>.getThumbExpandRate();
            }
        }, thumbExpandRate, <span class="number">1.0</span>f);
        mThumbExpandAnimator.setDuration(<span class="number">300</span>);
        mThumbExpandAnimator.setInterpolator(<span class="keyword">new</span> DecelerateInterpolator());

        <span class="comment">//thumb位移动画</span>
        mThumbMoveAnimator = ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="keyword">new</span> Property&lt;IOSSwitchView, Float&gt;(Float.class, <span class="string">"thumbMove"</span>) {
            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">IOSSwitchView <span class="keyword">object</span>, Float <span class="keyword">value</span></span>) </span>{
                <span class="keyword">object</span>.setThumbMoveRate(<span class="keyword">value</span>);
            }

            @<span class="function">Override
            <span class="keyword">public</span> Float <span class="title">get</span>(<span class="params">IOSSwitchView <span class="keyword">object</span></span>) </span>{
                <span class="keyword">return</span> <span class="keyword">object</span>.getThumbMoveRate();
            }
        }, thumbMoveRate, <span class="number">1.0</span>f);
        mThumbMoveAnimator.setDuration(<span class="number">300</span>);
        mThumbMoveAnimator.setInterpolator(<span class="keyword">new</span> DecelerateInterpolator());
</code></pre><p>初始化完三个属性动画后，我们下一步就该初始化滑动手势了，因为我们的<font color="red">IOSSwitchView</font>支持thumb滑动而改变打开关闭状态，所以我们要添加支持滑动手势<font color="red">GestureDetector</font>代码：</p>
<pre><code><span class="comment">//手势</span>
        mGestureDetector = <span class="keyword">new</span> GestureDetector(context, <span class="keyword">new</span> GestureDetector.SimpleOnGestureListener() {
            @<span class="function">Override
            <span class="keyword">public</span> boolean <span class="title">onDown</span><span class="params">(MotionEvent e)</span> </span>{

                <span class="keyword">if</span> (!isEnabled()) <span class="keyword">return</span> <span class="literal">false</span>;

                preIsOn = isOn;

                <span class="comment">//灰白色矩形缩小到0</span>
                mInnerContentAnimator.setFloatValues(innerContentRate, <span class="number">0.0f</span>);
                mInnerContentAnimator.start();

                <span class="comment">//thumb有个拉伸的动作</span>
                mThumbExpandAnimator.setFloatValues(thumbExpandRate, <span class="number">1.0f</span>);
                mThumbExpandAnimator.start();

                <span class="keyword">return</span> <span class="literal">true</span>;
            }

            @<span class="function">Override
            <span class="keyword">public</span> boolean <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span> </span>{
                <span class="comment">//手指抬起执行一系列的动画</span>
                isOn = thumbState;

                <span class="keyword">if</span> (preIsOn == isOn) {<span class="comment">//反转</span>
                    isOn = !isOn;
                    thumbState = !thumbState;
                }

                <span class="comment">//打开状态</span>
                <span class="keyword">if</span> (thumbState) {
                    <span class="comment">//thumb移动到右侧打开区域</span>
                    mThumbMoveAnimator.setFloatValues(thumbMoveRate, <span class="number">1.0F</span>);
                    mThumbMoveAnimator.start();

                    <span class="comment">//灰白色圆角矩形缩小到0</span>
                    mInnerContentAnimator.setFloatValues(innerContentRate, <span class="number">0.0F</span>);
                    mInnerContentAnimator.start();
                } <span class="keyword">else</span> {<span class="comment">//关闭状态</span>
                    <span class="comment">//thumb移动到左侧关闭区域</span>
                    mThumbMoveAnimator.setFloatValues(thumbMoveRate, <span class="number">0.0F</span>);
                    mThumbMoveAnimator.start();

                    <span class="comment">//灰白色圆角矩形放大到覆盖背景大小</span>
                    mInnerContentAnimator.setFloatValues(innerContentRate, <span class="number">1.0F</span>);
                    mInnerContentAnimator.start();
                }
                <span class="comment">//thumb恢复原大小</span>
                mThumbExpandAnimator.setFloatValues(thumbExpandRate, <span class="number">0.0F</span>);
                mThumbExpandAnimator.start();

                <span class="keyword">if</span> (mOnSwitchStateChangeListener != null &amp;&amp; preIsOn != isOn) {
                    mOnSwitchStateChangeListener.onStateSwitched(isOn);
                }

                <span class="keyword">return</span> <span class="literal">true</span>;
            }

            @<span class="function">Override
            <span class="keyword">public</span> boolean <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)</span> </span>{

                <span class="comment">//在打开开关的区域</span>
                <span class="keyword">if</span> (e2.getX() &gt; centerX) {
                    <span class="comment">//并且开关状态是关闭的，就执行打开开关操作</span>
                    <span class="keyword">if</span> (!thumbState) {
                        thumbState = !thumbState;

                        mThumbMoveAnimator.setFloatValues(thumbMoveRate, <span class="number">1.0F</span>);
                        mThumbMoveAnimator.start();

                        mInnerContentAnimator.setFloatValues(innerContentRate, <span class="number">0.0F</span>);
                        mInnerContentAnimator.start();
                    }
                } <span class="keyword">else</span> {<span class="comment">//在关闭区域</span>
                    <span class="comment">//开关处于打开状态</span>
                    <span class="keyword">if</span> (thumbState) {
                        thumbState = !thumbState;
                        <span class="comment">//执行关闭开关动画</span>
                        mThumbMoveAnimator.setFloatValues(thumbMoveRate, <span class="number">0.0F</span>);
                        mThumbMoveAnimator.start();
                    }
                }

                <span class="keyword">return</span> <span class="literal">true</span>;
            }

        });
        <span class="comment">//禁止长按</span>
        mGestureDetector.setIsLongpressEnabled(<span class="literal">false</span>);
</code></pre><p>因为<font color="red">OnGestureListener</font>里面的方法没必要都实现，我们这用的是它的子静态类<font color="red">SimpleOnGestureListener</font>，我们重写了里面的<font color="red">onDown</font>、<font color="red">onSingleTapUp</font>、<font color="red">onScroll</font>方法。</p>
<font color="red">onDown</font>方法的作用就是在按下控件的时候，thumb执行一个拉伸动画，灰白色圆角矩形则执行缩小到0的动画。如下图所示：<br><br><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/uiswitch-expand.gif?raw=true" alt="switch-expand"><br><br><font color="red">onSingleTapUp</font>则是单点抬起手指后执行的操作，这里执行的就是开关互斥动画和互斥逻辑，之前如果是打开的状态，就变成关闭状态，相反则反之。。。<br><br><font color="red">onScroll</font>方法则是手指滑动时的坐标大于中间X时则执行一个选中动画，相反则反之…<br><br>手势识别添加完后，我们为了保证控件有一个好的UI效果展示，一般指控件的宽度和高度保持一个比例，我们重写其<font color="red">onMeasure</font>方法，添加如下代码：<br><br>        @Override<br>        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {<br>            super.onMeasure(widthMeasureSpec, heightMeasureSpec);<br><br>            //测量宽度和高度<br>            width = MeasureSpec.getSize(widthMeasureSpec);<br>            height = MeasureSpec.getSize(heightMeasureSpec);<br><br>            //保持一定的宽高比例<br>            if ((float) height / (float) width &lt; 0.5f) {<br>                height = (int) (width <em> 0.5);<br><br>                heightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.getMode(heightMeasureSpec));<br>                widthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.getMode(widthMeasureSpec));<br>                super.setMeasuredDimension(widthMeasureSpec, heightMeasureSpec);<br>            }<br><br>            centerX = width </em> 0.5f;<br>            centerY = height <em> 0.5f;<br>            cornerRadius = centerY;<br><br>            innerContentRectF.left = mStrokeWidth;<br>            innerContentRectF.top = mStrokeWidth;<br>            innerContentRectF.right = width - mStrokeWidth;<br>            innerContentRectF.bottom = height - mStrokeWidth;<br><br>            intrinsicInnerWidth = innerContentRectF.width();<br>            intrinsicInnerHeight = innerContentRectF.height();<br><br>            thumbRectF.left = mStrokeWidth;<br>            thumbRectF.top = mStrokeWidth;<br>            thumbRectF.right = width - mStrokeWidth;<br>            thumbRectF.bottom = height - mStrokeWidth;<br><br>            intrinsicThumbWidth = thumbRectF.height();<br><br>            //thumb最大拉伸宽度<br>            thumbMaxExpandWidth = width </em> 0.7f;<br><br>            if (thumbMaxExpandWidth &gt; intrinsicThumbWidth <em> 1.25f) {<br>                thumbMaxExpandWidth = intrinsicThumbWidth </em> 1.25f;<br>            }<br>        }<br><br><br>测量完后，我们就开始执行最后一步也是最重要的一步：将控件画到画布canvas上，我们重写<font color="red">onDraw</font>方法：<br><br><br>        @Override<br>        protected void onDraw(Canvas canvas) {<br>        super.onDraw(canvas);<br><br>        float w = intrinsicInnerWidth <em> 0.5f </em> innerContentRate;<br>        float h = intrinsicInnerHeight <em> 0.5f </em> innerContentRate;<br><br>        this.innerContentRectF.left = centerX - w;<br>        this.innerContentRectF.top = centerY - h;<br>        this.innerContentRectF.right = centerX + w;<br>        this.innerContentRectF.bottom = centerY + h;<br><br>        //thumb拉伸宽度变化，其变化值从1-&gt;1.7之间<br>        w = intrinsicThumbWidth + (thumbMaxExpandWidth - intrinsicThumbWidth) <em> thumbExpandRate;<br><br>        boolean left = thumbRectF.left + thumbRectF.width() </em> 0.5f &lt; centerX;<br>        if (left) {<br>            thumbRectF.left = thumbRectF.right - w;<br>        } else {<br>            thumbRectF.right = thumbRectF.left + w;<br>        }<br><br>        float kw = thumbRectF.width();<br>        w = (float) (width - kw - (mStrokeWidth <em> 2)) </em> thumbMoveRate;<br><br>        thumbRectF.left = mStrokeWidth + w;<br>        thumbRectF.right = thumbRectF.left + kw;<br><br>        //颜色值过渡变化，从深灰白色变化到tintColor色<br>        this.colorStep = transformRGBColor(thumbMoveRate, backgroundColor, mTintColor);<br><br>        //画TintColor颜色的圆角矩形<br>        mPaint.setColor(colorStep);<br>        mPaint.setStyle(Paint.Style.FILL_AND_STROKE);<br>        drawRoundRect(0, 0, width, height, cornerRadius, canvas, mPaint);<br><br>        mPaint.setColor(foregroundColor);<br>        //画灰白色圆角矩形<br>        canvas.drawRoundRect(innerContentRectF, innerContentRectF.height() <em> 0.5f, innerContentRectF.height() </em> 0.5f, mPaint);<br><br>        //画thumb<br>        mPaint.setColor(mThumbTintColor);<br>        canvas.drawRoundRect(thumbRectF, cornerRadius, cornerRadius, mPaint);<br><br>        mPaint.setColor(0xFFCCCCCC);<br>        mPaint.setStyle(Paint.Style.STROKE);<br>        mPaint.setStrokeWidth(1);<br>        canvas.drawRoundRect(thumbRectF, cornerRadius, cornerRadius, mPaint);<br>        }<br><br><br><font color="red">onDraw</font>方法执行了四步绘制：四次绘制圆角矩形，第一次绘制背景tintColor颜色的圆角矩形，第二次绘制灰白色覆盖在上面的圆角矩形，第三次绘制thumb，第四次绘制一个空心的圆角矩形，这个是为了加深thumb和周围的颜色区分。<br><br>其中，里面有个方法<font color="red"> transformRGBColor </font>

<pre><code><span class="comment">/**
     * RGB颜色过渡变化
     *
     * @param progress
     * @param fromColor
     * @param toColor
     * @return
     */</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">transformRGBColor</span><span class="params">(<span class="keyword">float</span> progress, <span class="keyword">int</span> fromColor, <span class="keyword">int</span> toColor)</span> </span>{
        <span class="keyword">int</span> fr = (fromColor &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;
        <span class="keyword">int</span> fg = (fromColor &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;
        <span class="keyword">int</span> fb = fromColor &amp; <span class="number">0xFF</span>;

        <span class="keyword">int</span> tr = (toColor &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;
        <span class="keyword">int</span> tg = (toColor &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;
        <span class="keyword">int</span> tb = toColor &amp; <span class="number">0xFF</span>;

        <span class="keyword">int</span> rGap = (<span class="keyword">int</span>) ((<span class="keyword">float</span>) (tr - fr) * progress);
        <span class="keyword">int</span> gGap = (<span class="keyword">int</span>) ((<span class="keyword">float</span>) (tg - fg) * progress);
        <span class="keyword">int</span> bGap = (<span class="keyword">int</span>) ((<span class="keyword">float</span>) (tb - fb) * progress);

        <span class="keyword">return</span> <span class="number">0xFF000000</span> | ((fr + rGap) &lt;&lt; <span class="number">16</span>) | ((fg + gGap) &lt;&lt; <span class="number">8</span>) | (fb + bGap);
    }
</code></pre><p>为了将状态变化值传递给页面，一般指的是Activity、Fragment、View，我们需要定义一个接口：</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> SwitchView状态切换
 <span class="keyword">*</span>/
public static interface OnSwitchStateChangeListener {
    /<span class="keyword">*</span><span class="keyword">*</span>
     <span class="keyword">*</span> 是否选中
     <span class="keyword">*</span>
     <span class="keyword">*</span> <span class="comment">@param isOn</span>
     <span class="keyword">*</span>/
    public void onStateSwitched(boolean isOn);
}
</code></pre><p>里面的一些细节这里就不讲了，最后怎么使用呢？分两步：</p>
<p>第一步：布局xml</p>
<pre><code>&lt;<span class="tag">com</span><span class="class">.hhl</span><span class="class">.library</span><span class="class">.IOSSwitchView</span>
            <span class="rule"><span class="attribute">android</span>:<span class="value">id=<span class="string">"@+id/switch_view"</span>
            android:layout_width=<span class="string">"55dp"</span>
            android:layout_height=<span class="string">"35dp"</span>
            android:layout_gravity=<span class="string">"center"</span>
            app:thumbTintColor=<span class="string">"#fff"</span>
            app:tintColor=<span class="string">"#00ff00"</span> /&gt;</span></span>
</code></pre><p>第二步：代码</p>
<pre><code>mSwitchView = (IOSSwitchView) findViewById(R.id.switch_view);
        mStatusTv = (TextView) findViewById(R.id.tv_status);

        mSwitchView.setOnSwitchStateChangeListener(<span class="keyword">new</span> IOSSwitchView.OnSwitchStateChangeListener() {
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onStateSwitched</span><span class="params">(<span class="keyword">boolean</span> isOn)</span> </span>{
                <span class="keyword">if</span> (isOn) {
                    mStatusTv.setText(<span class="string">"状态：开"</span>);
                } <span class="keyword">else</span> {
                    mStatusTv.setText(<span class="string">"状态：关"</span>);
                }
            }
        });
</code></pre><p>最后，附上源码：<a href="https://github.com/hanhailong/IOSSwitchView" target="_blank" rel="external">github-IOSSwitchView</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这一章节，我们将开始在Android上做一个IOS风格的UISwitch控件。这篇文章主要涉及如下知识点：</p>
<ol>
<li>Android属性动画Animator</li>
<li>自定义手势GestureDetector</li>
<li>自定义View属性attrs</li>
</ol>
<p>首先，让我们来看一下效果图：</p>
<p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/uiswitch.gif?raw=true" alt="uiswitch"></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RxBus—通过RxJava来替换EventBus]]></title>
    <link href="http://hanhailong.com/2015/10/09/RxBus%E2%80%94%E9%80%9A%E8%BF%87RxJava%E6%9D%A5%E6%9B%BF%E6%8D%A2EventBus/"/>
    <id>http://hanhailong.com/2015/10/09/RxBus—通过RxJava来替换EventBus/</id>
    <published>2015-10-09T15:25:07.000Z</published>
    <updated>2015-10-10T02:18:49.000Z</updated>
    <content type="html"><![CDATA[<h2>前言</h2>

<p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a>有多火？看看Github上star数量就知道了，那什么是RxJava呢？</p>
<p>RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。</p>
<p>换一种说法，RxJava 是一个响应式编程框架，采用观察者设计模式。所以自然少不了 Observable 和 Subscriber 这两个东东了。</p>
<a id="more"></a>
<p>而针对Android，则有一个基于RxJava的<a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">RxAndroid</a></p>
<p>甚至Jake Wharton大神还基于RxJava写了一个针对Android平台的binding api<a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="external">RxBinding</a></p>
<p>而这篇博文讲的就是基于RxJava实现的一个Event Bus-&gt;<a href="https://github.com/hanhailong/AndroidStudyResources/blob/master/javacode/RxBus.java" target="_blank" rel="external">RxBus</a></p>
<p>懂得Android的开发者都知道，目前Android上最火的两个Event Bus库是<a href="http://square.github.io/otto/" target="_blank" rel="external">Otto</a>和Green Robot’s<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a>，两个事件总线库写的都非常不错。不过这里不是讲事件总线，而是讲如何通过RxJava来实现事件总线的效果。</p>
<p>总体来说，代码非常的简单，十几行代码就搞定了！</p>
<p>首先，我们来定义一个RxBus单例类：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> rx.Observable;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> rx.subjects.PublishSubject;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> rx.subjects.SerializedSubject;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> rx.subjects.Subject;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by HanHailong on 15/10/9.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxBus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> volatile RxBus mDefaultInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RxBus() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RxBus getDefault() &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDefaultInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            synchronized (RxBus.<span class="keyword">class</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDefaultInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mDefaultInstance = <span class="keyword">new</span> RxBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mDefaultInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject&lt;Object, Object&gt; _bus = <span class="keyword">new</span> SerializedSubject&lt;&gt;(PublishSubject.create());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> send(Object o) &#123;</span><br><span class="line">        _bus.onNext(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Observable&lt;Object&gt; toObservable() &#123;</span><br><span class="line">        <span class="keyword">return</span> _bus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码非常的简单，使用呢？则更简单了，一般来讲，事件总线，包括一个发送事件和多个接收事件。</p>
<p>先看发送事件的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">RxBus</span><span class="class">.getDefault</span>()<span class="class">.send</span>(<span class="tag">new</span> <span class="tag">TapEvent</span>());</span><br></pre></td></tr></table></figure>
<p>而在你想接收事件的地方，只需要加上下面代码就可以了：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RxBus.getDefault().toObservable().subscribe(<span class="keyword">new</span> Action1&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (event <span class="keyword">instanceof</span> TapEvent) &#123;</span><br><span class="line">                   <span class="comment">//do something</span></span><br><span class="line">                &#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(event <span class="keyword">instanceof</span> otherEvent)</span></span>&#123;</span><br><span class="line">                		<span class="comment">//do otherthing</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>这样，一个简单的Event Bus就实现了！如果你的项目已经开始使用RxJava，建议可以把<a href="http://square.github.io/otto/" target="_blank" rel="external">Otto</a>和Green Robot’s<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a>去掉了，直接使用<a href="https://github.com/hanhailong/AndroidStudyResources/blob/master/javacode/RxBus.java" target="_blank" rel="external">RxBus</a>！！</p>
<p>当然，不要忘了在build.gradle引入RxJava和RxAndroid：</p>
<pre><code><span class="keyword">compile</span> <span class="string">'io.reactivex:rxandroid:1.0.1'</span>
<span class="keyword">compile</span> <span class="string">'io.reactivex:rxjava:1.0.14'</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2>前言</h2>

<p><a href="https://github.com/ReactiveX/RxJava">RxJava</a>有多火？看看Github上star数量就知道了，那什么是RxJava呢？</p>
<p>RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。</p>
<p>换一种说法，RxJava 是一个响应式编程框架，采用观察者设计模式。所以自然少不了 Observable 和 Subscriber 这两个东东了。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
      <category term="RxAndroid" scheme="http://hanhailong.com/tags/RxAndroid/"/>
    
      <category term="RxJava" scheme="http://hanhailong.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo—添加百度统计代码]]></title>
    <link href="http://hanhailong.com/2015/10/08/Hexo%E2%80%94%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81/"/>
    <id>http://hanhailong.com/2015/10/08/Hexo—添加百度统计代码/</id>
    <published>2015-10-08T15:31:31.000Z</published>
    <updated>2015-10-08T16:05:53.000Z</updated>
    <content type="html"><![CDATA[<p>本博客采用的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">Yilia</a>主题，这里就以Yilia讲解为例，首先你要去<a href="http://tongji.baidu.com/" target="_blank" rel="external">百度统计</a>注册账号，并获取到相关的百度统计代码：</p>
<ol>
<li><p>编辑文件<font color="blue"><strong>themes/yilia/_config.yml</strong></font>，添加一行配置代码：</p>
<pre><code><span class="string">baidu_tongji:</span> <span class="literal">true</span>
</code></pre></li>
<li><p>新建文件<font color="blue"><strong>themes/yilia/layout/_partial/baidu_tongji.ejs</strong></font>，内容如下：</p>
<pre><code><span class="xml"></span>&lt;%<span class="ruby"> <span class="keyword">if</span> (theme.baidu_tongji) { </span>%&gt;<span class="xml">
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="undefined">
#申请的百度统计代码
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</span>&lt;%<span class="ruby"> } </span>%&gt;<span class="xml"></span>
</code></pre></li>
<li><p>编辑<font color="blue">themes/yilia/layout/_partial/head.ejs</font>文件，在<font color="red">&lt;/head&gt;</font>之前添加代码：</p>
<pre><code>&lt;<span class="preprocessor">%</span>- partial<span class="comment">("baidu_tongji")</span> <span class="preprocessor">%</span>&gt;
</code></pre></li>
<li><p>重新部署发布，搞定睡觉！！！</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本博客采用的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">Yilia</a>主题，这里就以Yilia讲解为例，首先你要去<a href="http:/]]>
    </summary>
    
      <category term="Hexo主题" scheme="http://hanhailong.com/tags/Hexo%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo—正确添加RSS订阅]]></title>
    <link href="http://hanhailong.com/2015/10/08/Hexo%E2%80%94%E6%AD%A3%E7%A1%AE%E6%B7%BB%E5%8A%A0RSS%E8%AE%A2%E9%98%85/"/>
    <id>http://hanhailong.com/2015/10/08/Hexo—正确添加RSS订阅/</id>
    <published>2015-10-08T13:07:13.000Z</published>
    <updated>2015-10-08T13:51:57.000Z</updated>
    <content type="html"><![CDATA[<p>看到别人的博客都有RSS订阅功能，就想着给自己的博客也添加RSS订阅功能。</p>
<p>看网上的教程，写的不是很详细，都是很简单的一句话。而我按照网上的教程愣是没整出来。真是验证了一句古话：<font color="red">尽信书不如无书</font></p>
<p>最后，终于让我整出来了，特此把完整的过程记录一下：</p>
<a id="more"></a>
<p>先看下整出来的效果图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rss.png?raw=true" alt="RSS效果图"></p>
<p>首先，先安装<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="external">hexo-generator-feed</a></p>
<pre><code>$ npm <span class="operator"><span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span>
</code></pre><p>安装完后，会在node_modules目录下生成hexo-generator-feed目录，如图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rss-feed.png?raw=true" alt="image"></p>
<p>安装完hexo-generator-feed后，将其配置到根目录的<font color="red">_config.yml</font></p>
<pre><code><span class="preprocessor"># Extensions</span>
<span class="preprocessor">## Plugins: http://hexo.io/plugins/</span>
<span class="preprocessor">#RSS订阅</span>
<span class="label">plugin:</span>
- hexo-generator-feed
<span class="preprocessor">#Feed Atom</span>
<span class="label">feed:</span>
<span class="label">type:</span> atom
<span class="label">path:</span> atom.xml
<span class="label">limit:</span> <span class="number">20</span>
</code></pre><p>其中，feed是可选项，可配可不配！</p>
<p>最后，在你当前主题下的<font color="blue">_config.yml</font>下，添加RSS订阅链接即可，这里我用的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">Yilia</a>主题，subnav下添加rss：</p>
<pre><code><span class="preprocessor"># SubNav</span>
<span class="label">subnav:</span>
<span class="label">rss:</span> <span class="string">"/atom.xml"</span>
</code></pre><p>添加之后，运行<font color="red">hexo g</font>后，就会在页面上生成RSS图标，如下图：</p>
<p><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/rss-result.png?raw=true" alt="image"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>看到别人的博客都有RSS订阅功能，就想着给自己的博客也添加RSS订阅功能。</p>
<p>看网上的教程，写的不是很详细，都是很简单的一句话。而我按照网上的教程愣是没整出来。真是验证了一句古话：<font color='red'>尽信书不如无书</font></p>
<p>最后，终于让我整出来了，特此把完整的过程记录一下：</p>]]>
    
    </summary>
    
      <category term="Hexo主题" scheme="http://hanhailong.com/tags/Hexo%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不错的学习技术博客之三—泡在网上的日子]]></title>
    <link href="http://hanhailong.com/2015/10/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E4%B9%8B%E4%B8%89%E2%80%94%E6%B3%A1%E5%9C%A8%E7%BD%91%E4%B8%8A%E7%9A%84%E6%97%A5%E5%AD%90/"/>
    <id>http://hanhailong.com/2015/10/08/不错的学习技术博客之三—泡在网上的日子/</id>
    <published>2015-10-08T08:19:33.000Z</published>
    <updated>2015-10-08T08:27:38.000Z</updated>
    <content type="html"><![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第三篇，<a href="http://www.jcodecraeer.com/" target="_blank" rel="external">泡在网上的日子</a>上面的技术博客质量都非常高，文章内容非常广泛，不仅包括Android和IOS，还包括Html5/css3、JS、java、php等，甚至还包括设计模式和算法。</p>
<p>还有就是包括代码，里面的代码大部分都托管在github上面，这里做了比较详细的系统分类，总体做的非常不错，我经常去上面浏览学习！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第三篇，<a href="http://www.jcodecraeer.com/" tar]]>
    </summary>
    
      <category term="技术博客" scheme="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android-内存优化之图片优化]]></title>
    <link href="http://hanhailong.com/2015/10/06/Android-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E4%B9%8B%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/"/>
    <id>http://hanhailong.com/2015/10/06/Android-内存优化之图片优化/</id>
    <published>2015-10-06T12:21:39.000Z</published>
    <updated>2015-10-06T12:41:12.000Z</updated>
    <content type="html"><![CDATA[<p>网上有很多大拿分享的关于Android性能优化的文章，主要是通过各种工具分析，使用合理的技巧优化APP的体验，提升APP的流畅度，但关于内存优化的文章很少有看到。在Android设备内存动不动就上G的情况下，的确没有必要去太在意APP对Android系统内存的消耗，但在实际工作中我做的是教育类的小学APP，APP中的按钮、背景、动画变换基本上全是图片，在2K屏上（分辨率2048*1536）一张背景图片就会占用内存12M，来回切换几次内存占用就会增涨到上百兆，为了在不影响APP的视觉效果的前提下，有必要通过各种手段来降低APP对内存的消耗，下面是我在实践过程中使用的一些方法，很多都是不太成熟的项目，也不够深入，只是将其作为一种处理方式分享给大家。</p>
<a id="more"></a>
<p>   通过DDMS的APP内存占用查看工具分析发现，APP中占用内存最多的是图片，每个Activity中图片占用内存占大半，本文重点分享对图片的内存优化。</p>
<h2>不要将Button的背景设置为selector</h2>

<p>   在布局文件和代码中，都可以为Button设置background为selector，这样方便实现按钮的正反选效果，但实际跟踪发现，如果是将Button的背景设置为selector，在初始化Button的时候会将正反选图片都加载在内存中（具体可以查看Android源码，在类Drawable.java的createFromXmlInner方法中对图片进行解析，最终调用Drawable的inflate方法），相当于一个按钮占用了两张相同大小图片所使用的内存，如果一个界面上按钮很多或者是按钮很大，光是按钮占用的内存就会很大，可以通过在布局文件中给按钮只设置正常状态下的背景图片，然后在代码中监听按钮的点击状态，当按下按钮时为按钮设置反选效果的图片，抬起时重新设置为正常状态下的背景，具体实现方式如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageButtonClickUtils</span> </span>{
        <span class="function"><span class="keyword">private</span> <span class="title">ImageButtonClickUtils</span><span class="params">()</span></span>{

        }

        <span class="comment">/**
         * 设置按钮的正反选效果
         * 
         * */</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setClickState</span><span class="params">(View view, <span class="keyword">final</span> <span class="keyword">int</span> normalResId, <span class="keyword">final</span> <span class="keyword">int</span> pressResId)</span></span>{
            view.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() {
                <span class="annotation">@Override</span>
                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>{
                    <span class="keyword">switch</span>(event.getAction()){
                    <span class="keyword">case</span> MotionEvent.ACTION_DOWN:{
                        v.setBackgroundResource(pressResId);
                    }
                    <span class="keyword">break</span>;
                    <span class="keyword">case</span> MotionEvent.ACTION_MOVE:{
                        v.setBackgroundResource(pressResId);
                    }
                    <span class="keyword">break</span>;
                    <span class="keyword">case</span> MotionEvent.ACTION_UP:{
                        v.setBackgroundResource(normalResId);
                    }
                    <span class="keyword">break</span>;
                    <span class="keyword">default</span>:{

                    }
                    <span class="keyword">break</span>;
                    }

                    <span class="comment">// 为了不影响监听按钮的onClick回调，返回值应为false</span>
                    <span class="keyword">return</span> <span class="keyword">false</span>;
                }
            });
        }
}
</code></pre><p>通过上面这种方式就可以解决同一个按钮占用两倍内存的问题，如果你觉得为一个按钮提供正反选两张图片会导致APK的体积变大，可以通过如下方式实现按钮点击的反选效果，这种方式既不会存在Button占用两倍内存的情况，又减小了APK的体积（Android 5.0中的tintColor也可以实现类似的效果）：</p>
<pre><code>ImageButton personalInfoBtn = (ImageButton)findViewById(R.id.personalBtnId);
    personalInfoBtn.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() {
        <span class="annotation">@SuppressLint</span>(<span class="string">"ClickableViewAccessibility"</span>)
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>{
            <span class="keyword">int</span> action = event.getAction();

            <span class="keyword">if</span>(action == MotionEvent.ACTION_DOWN){
                ((ImageButton)v).setColorFilter(getResources().getColor(<span class="number">0X50000000</span>));
            }<span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL)</span></span>{
                ((ImageButton)v).clearColorFilter();
            }

            <span class="comment">// 为了不影响监听按钮的onClick回调，返回值应为false</span>
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
    });
</code></pre><h2>将背景图片放在非UI线程绘制，提升APP的效率</h2>

<p>在高分辨率的平板设备上，绘制大背景的图片会影响程序的运行效率，严重情况下就和没有开硬件加速的时候使用手写功能一样，相当地卡，最后我们的解决方案是将背景图片通过SurfaceView来绘制，这样相当于是在非UI线程绘制，不会影响到UI线程做其它事情：</p>
<pre><code><span class="keyword">import</span> android.content.Context;
<span class="keyword">import</span> android.content.res.TypedArray;
<span class="keyword">import</span> android.graphics.Bitmap;
<span class="keyword">import</span> android.graphics.BitmapFactory;
<span class="keyword">import</span> android.graphics.Canvas;
<span class="keyword">import</span> android.graphics.Matrix;
<span class="keyword">import</span> android.graphics.PixelFormat;
<span class="keyword">import</span> android.util.AttributeSet;
<span class="keyword">import</span> android.util.DisplayMetrics;
<span class="keyword">import</span> android.view.SurfaceHolder;
<span class="keyword">import</span> android.view.SurfaceView;

<span class="keyword">import</span> com.hhl.activity.R;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootSurfaceView</span> <span class="keyword">extends</span> <span class="title">SurfaceView</span> <span class="keyword">implements</span> <span class="title">SurfaceHolder</span>.<span class="title">Callback</span>, <span class="title">Runnable</span></span>{
    <span class="keyword">private</span> <span class="keyword">float</span> mViewWidth = <span class="number">0</span>;
    <span class="keyword">private</span> <span class="keyword">float</span> mViewHeight = <span class="number">0</span>;
    <span class="keyword">private</span> <span class="keyword">int</span> mResourceId = <span class="number">0</span>;
    <span class="keyword">private</span> Context mContext = <span class="keyword">null</span>;
    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">false</span>;
    <span class="keyword">private</span> SurfaceHolder mSurfaceHolder = <span class="keyword">null</span>;

    <span class="function"><span class="keyword">public</span> <span class="title">RootSurfaceView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>{
        <span class="keyword">super</span>(context, attrs, defStyleAttr);
        initRootSurfaceView(context, attrs, defStyleAttr, <span class="number">0</span>);
    }

    <span class="function"><span class="keyword">public</span> <span class="title">RootSurfaceView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>{
        <span class="keyword">super</span>(context, attrs);
        initRootSurfaceView(context, attrs, <span class="number">0</span>, <span class="number">0</span>);
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRootSurfaceView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span></span>{
        mContext = context;
        DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RootSurfaceView, defStyleAttr, defStyleRes);
        <span class="keyword">int</span> n = a.getIndexCount();
        mViewWidth = displayMetrics.widthPixels;
        mViewHeight = displayMetrics.heightPixels;
        <span class="keyword">for</span>(<span class="keyword">int</span> index=<span class="number">0</span>; index&lt;n; index++){
            <span class="keyword">int</span> attr = a.getIndex(index);
            <span class="keyword">switch</span>(attr){
            <span class="keyword">case</span> R.styleable.RootSurfaceView_background:{
                mResourceId = a.getResourceId(attr, <span class="number">0</span>);
            }
            <span class="keyword">break</span>;
            <span class="keyword">case</span> R.styleable.RootSurfaceView_view_width:{
                mViewWidth = a.getDimension(attr, displayMetrics.widthPixels);
            }
            <span class="keyword">break</span>;
            <span class="keyword">case</span> R.styleable.RootSurfaceView_view_height:{
                mViewHeight = a.getDimension(attr, displayMetrics.heightPixels);
            }
            <span class="keyword">break</span>;
            <span class="keyword">default</span>:{

            }
            <span class="keyword">break</span>;
            }
        }
        a.recycle();
        mSurfaceHolder = getHolder();
        mSurfaceHolder.addCallback(<span class="keyword">this</span>);
        mSurfaceHolder.setFormat(PixelFormat.TRANSLUCENT);
    }

    <span class="function"><span class="keyword">private</span> Bitmap <span class="title">getDrawBitmap</span><span class="params">(Context context, <span class="keyword">float</span> width, <span class="keyword">float</span> height)</span> </span>{
        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), mResourceId);
        Bitmap resultBitmap = zoomImage(bitmap, width, height);
        <span class="keyword">return</span> resultBitmap;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder arg0, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">int</span> arg3)</span> </span>{
        System.out.println(<span class="string">"RootSurfaceView surfaceChanged"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> </span>{
        drawBackGround(holder);
        System.out.println(<span class="string">"RootSurfaceView surfaceCreated"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>{
        isRunning = <span class="keyword">false</span>;
        System.out.println(<span class="string">"RootSurfaceView surfaceDestroyed"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onAttachedToWindow();
        System.out.println(<span class="string">"RootSurfaceView onAttachedToWindow"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onDetachedFromWindow();
        System.out.println(<span class="string">"RootSurfaceView onDetachedFromWindow"</span>);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{  
        <span class="keyword">while</span>(isRunning){  
            <span class="keyword">synchronized</span> (mSurfaceHolder) { 
                <span class="keyword">if</span>(!mSurfaceHolder.getSurface().isValid()){
                    <span class="keyword">continue</span>;
                }
                drawBackGround(mSurfaceHolder);
            }
            isRunning = <span class="keyword">false</span>;
            <span class="keyword">break</span>;
        }  
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawBackGround</span><span class="params">(SurfaceHolder holder)</span> </span>{
        Canvas canvas = holder.lockCanvas();
        Bitmap bitmap = getDrawBitmap(mContext, mViewWidth, mViewHeight);
        canvas.drawBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);
        bitmap.recycle();
        holder.unlockCanvasAndPost(canvas);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">zoomImage</span><span class="params">( Bitmap bgimage , <span class="keyword">float</span> newWidth , <span class="keyword">float</span> newHeight )</span> </span>{
        <span class="keyword">float</span> width = bgimage.getWidth( );
        <span class="keyword">float</span> height = bgimage.getHeight( );
        Matrix matrix = <span class="keyword">new</span> Matrix();
        <span class="keyword">float</span> scaleWidth = newWidth/width;
        <span class="keyword">float</span> scaleHeight = newHeight/height;
        matrix.postScale( scaleWidth, scaleHeight );
        Bitmap bitmap = Bitmap.createBitmap( bgimage, <span class="number">0</span>, <span class="number">0</span>, ( <span class="keyword">int</span> ) width , ( <span class="keyword">int</span> ) height, matrix, <span class="keyword">true</span> );
        <span class="keyword">if</span>( bitmap != bgimage ){
            bgimage.recycle();
            bgimage = <span class="keyword">null</span>;
        }
        <span class="keyword">return</span> bitmap;
    }
}
</code></pre><p>在res/values/attr.xml文件中定义自定义View的自定义属性：</p>
<pre><code><span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"RootSurfaceView"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"background"</span> <span class="attribute">format</span>=<span class="value">"reference"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"view_width"</span> <span class="attribute">format</span>=<span class="value">"dimension"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"view_height"</span> <span class="attribute">format</span>=<span class="value">"dimension"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span>
</code></pre><h2> 没有必要使用硬件加速的界面建议关掉硬件加速 </h2>

<p>通过DDMS的heap跟踪发现，相比于关闭硬件加速，在打开硬件加速的情况下会消耗更多的内存，但有的界面打开或者关闭硬件加速对程序的运行效率并没有太大的影响，此种情况下可以考虑在AndroidManifest.xml文件中关闭掉对应Activity的硬件加速，like this：</p>
<pre><code><span class="comment">&lt;!-- 设置界面 --&gt;</span>
<span class="tag">&lt;<span class="title">activity</span>
    <span class="attribute">android:name</span>=<span class="value">".SettingActivity"</span>
    <span class="attribute">android:hardwareAccelerated</span>=<span class="value">"false"</span>
    <span class="attribute">android:screenOrientation</span>=<span class="value">"sensorLandscape"</span>&gt;</span>
<span class="tag">&lt;/<span class="title">activity</span>&gt;</span>
</code></pre><p>注意：如果使用到WebView、视频播放、手写、动画等功能时，关掉硬件加速会严重音效程序的运行效率，这种情况可以只关闭掉Activity中某些view的硬件加速，整个Activity的硬件加速不关闭。</p>
<p>如果Activity中某个View需要关闭硬件加速，但整个Activity不能关闭，可以调用view层级关闭硬件加速的方法：</p>
<pre><code><span class="comment">// view.setLayerType || 在定义view的构造方法中调用该方法</span>
setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="literal">null</span>);
</code></pre><h2>尽量少用AnimationDrawable，如果必须要可以自定义图片切换器代替AnimationDrawable</h2>

<p>AnimationDrawable也是一个耗内存大户，图片帧数越多耗内存越大，具体可以查看AnimationDrawable的源码，在AnimationDrawable实例化的时候，Drawable的createFromXmlInner方法会调用AnimationDrawable的inflate方法，该方法里面有一个while循环去一次性将所有帧都读取出来，也就是在初始化的时候就将所有的帧读在内存中了，有多少张图片，它就要消耗对应大小的内存。</p>
<p>虽然可以通过如下方式释放AnimationDrawable占用的内存，但是当退出使用AnimationDrawable的界面，再次进入使用其播放动画时，会报使用已经回收了的图片的异常，这个应该是Android对图片的处理机制导致的，虽然Activity被finish掉了，但是这个Activity中使用到的图片还是在内存中，如果被回收，下次进入时就会报异常信息：</p>
<pre><code><span class="comment">/**
 * 释放AnimationDrawable占用的内存
 * 
 * 
 * */</span>
<span class="annotation">@SuppressWarnings</span>(<span class="string">"unused"</span>)
<span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">freeAnimationDrawable</span><span class="params">(AnimationDrawable animationDrawable)</span> </span>{
    animationDrawable.stop(); 
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; animationDrawable.getNumberOfFrames(); ++i){
        Drawable frame = animationDrawable.getFrame(i);
        <span class="keyword">if</span> (frame <span class="keyword">instanceof</span> BitmapDrawable) {
            ((BitmapDrawable)frame).getBitmap().recycle();
        } 
        frame.setCallback(<span class="keyword">null</span>);
    } 

    animationDrawable.setCallback(<span class="keyword">null</span>);
}
</code></pre><p>通常情况下我会自定义一个ImageView来实现AnimationDrawable的功能，根据图片之间切换的时间间隔来定时设置ImageView的背景图片，这样始终只是一个ImageView实例，更换的只是其背景，占用内存会比AnimationDrawable小很多：</p>
<pre><code><span class="comment">/**
 * 图片动态切换器
 * 
 * */</span>
<span class="keyword">public</span> <span class="keyword">class</span> AnimImageView {
    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> MSG_START = <span class="number">0xf1</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> MSG_STOP  = <span class="number">0xf2</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> STATE_STOP = <span class="number">0xf3</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> STATE_RUNNING = <span class="number">0xf4</span>;

    <span class="comment">/* 运行状态*/</span>
    <span class="keyword">private</span> <span class="keyword">int</span> mState = STATE_RUNNING;
    <span class="keyword">private</span> ImageView mImageView;
    <span class="comment">/* 图片资源ID列表*/</span>
    <span class="keyword">private</span> List&lt;Integer&gt; mResourceIdList = null;
    <span class="comment">/* 定时任务*/</span>
    <span class="keyword">private</span> Timer mTimer = null;
    <span class="keyword">private</span> AnimTimerTask mTimeTask = null;
    <span class="comment">/* 记录播放位置*/</span>
    <span class="keyword">private</span> <span class="keyword">int</span> mFrameIndex = <span class="number">0</span>;
    <span class="comment">/* 播放形式*/</span>
    <span class="keyword">private</span> boolean isLooping = <span class="literal">false</span>;

    <span class="function"><span class="keyword">public</span> <span class="title">AnimImageView</span><span class="params">( )</span></span>{
        mTimer = <span class="keyword">new</span> Timer();
    }

    <span class="comment">/**
     * 设置动画播放资源
     * 
     * */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnimation</span><span class="params">( HanziImageView imageview, List&lt;Integer&gt; resourceIdList )</span></span>{
        mImageView = imageview;
        mResourceIdList = resourceIdList;
    }

    <span class="comment">/**
     *  开始播放动画
     *  @param loop 时候循环播放
     *  @param duration 动画播放时间间隔
     * */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(boolean loop, <span class="keyword">int</span> duration)</span></span>{
        stop();
        isLooping = loop;
        mFrameIndex = <span class="number">0</span>;
        mState = STATE_RUNNING;
        mTimeTask = <span class="keyword">new</span> AnimTimerTask( );
        mTimer.schedule(mTimeTask, <span class="number">0</span>, duration);
    }

    <span class="comment">/**
     * 停止动画播放
     * 
     * */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>{
        <span class="keyword">if</span> (mTimeTask != null) {
            mFrameIndex = <span class="number">0</span>;
            mState = STATE_STOP;
            mTimer.purge();
            mTimeTask.cancel();
            mTimeTask = null;
            mImageView.setBackgroundResource(<span class="number">0</span>);
        }
    }

    <span class="comment">/**
     * 定时器任务
     * 
     * 
     */</span>
    <span class="keyword">class</span> AnimTimerTask extends TimerTask {
        @<span class="function">Override
        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            <span class="keyword">if</span>(mFrameIndex &lt; <span class="number">0</span> || mState == STATE_STOP){
                <span class="keyword">return</span>;
            }

            <span class="keyword">if</span>( mFrameIndex &lt; mResourceIdList.size() ){
                Message msg = AnimHanlder.obtainMessage(MSG_START,<span class="number">0</span>,<span class="number">0</span>,null);
                msg.sendToTarget();
            }<span class="keyword">else</span>{
                mFrameIndex = <span class="number">0</span>;
                <span class="keyword">if</span>(!isLooping){
                    Message msg = AnimHanlder.obtainMessage(MSG_STOP,<span class="number">0</span>,<span class="number">0</span>,null);
                    msg.sendToTarget();
                }
            }
        }
    }

    <span class="keyword">private</span> Handler AnimHanlder = <span class="keyword">new</span> Handler(){
         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(android.os.Message msg)</span> </span>{
                <span class="keyword">switch</span> (msg.what) {
                <span class="keyword">case</span> MSG_START:{
                    <span class="keyword">if</span>(mFrameIndex &gt;=<span class="number">0</span> &amp;&amp; mFrameIndex &lt; mResourceIdList.size() &amp;&amp; mState == STATE_RUNNING){
                        mImageView.setImageResource(mResourceIdList.get(mFrameIndex));
                        mFrameIndex++;
                    }
                }
                    <span class="keyword">break</span>;
                <span class="keyword">case</span> MSG_STOP:{
                    <span class="keyword">if</span> (mTimeTask != null) {
                        mFrameIndex = <span class="number">0</span>;
                        mTimer.purge();
                        mTimeTask.cancel();
                        mState = STATE_STOP;
                        mTimeTask = null;
                        mImageView.setImageResource(<span class="number">0</span>);
                    }
                }
                    <span class="keyword">break</span>;
                <span class="keyword">default</span>:
                    <span class="keyword">break</span>;
                }
         }
    };
}
</code></pre><h2>其它优化方式</h2>

<ul>
<li>尽量将Activity中的小图片和背景合并，一张小图片既浪费布局的时间，又平白地增加了内存占用；</li>
<li><p>不要在Activity的主题中为Activity设置默认的背景图片，这样会导致Activity占用的内存翻倍：</p>
<pre><code><span class="comment">&lt;!--千万不要在主题中为Activity设置默认背景--&gt;</span>
<span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"Activity_Style"</span> <span class="attribute">parent</span>=<span class="value">"@android:Theme.Holo.Light.NoActionBar"</span>&gt;</span><span class="css">
&lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="rule"><span class="attribute">android</span>:<span class="value">background<span class="string">"&gt;@drawable/*&lt;/item&gt;
</span></span></span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
</code></pre></li>
<li><p>对于在需要时才显示的图片或者布局，可以使用ViewStub标签，通过sdk/tools目录下的hierarchyviewer.bat查看布局文件会发现，使用viewstub标签的组件几乎不消耗布局的时间，在代码中当需要显示时再去实例化有助于提高Activity的布局效率和节省Activity消耗的内存。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>网上有很多大拿分享的关于Android性能优化的文章，主要是通过各种工具分析，使用合理的技巧优化APP的体验，提升APP的流畅度，但关于内存优化的文章很少有看到。在Android设备内存动不动就上G的情况下，的确没有必要去太在意APP对Android系统内存的消耗，但在实际工作中我做的是教育类的小学APP，APP中的按钮、背景、动画变换基本上全是图片，在2K屏上（分辨率2048*1536）一张背景图片就会占用内存12M，来回切换几次内存占用就会增涨到上百兆，为了在不影响APP的视觉效果的前提下，有必要通过各种手段来降低APP对内存的消耗，下面是我在实践过程中使用的一些方法，很多都是不太成熟的项目，也不够深入，只是将其作为一种处理方式分享给大家。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不错的学习技术博客之二————trinea.cn]]></title>
    <link href="http://hanhailong.com/2015/10/06/%E4%B8%8D%E9%94%99%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E4%B9%8B%E4%BA%8C%E2%80%94%E2%80%94%E2%80%94%E2%80%94trinea-cn/"/>
    <id>http://hanhailong.com/2015/10/06/不错的学习技术博客之二————trinea-cn/</id>
    <published>2015-10-06T03:14:05.000Z</published>
    <updated>2015-10-06T03:28:28.000Z</updated>
    <content type="html"><![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第二篇，<a href="http://www.trinea.cn/" target="_blank" rel="external">trinea</a>这个技术博客主要记录Android和Java方面的技术文章，侧重点在于性能调优、开源项目经验分享、新技术调研等等，而作者本身编程功底很深，2010年加入阿里巴巴，目前在<a href="http://codekk.com/jobs/detail/%E6%9D%AD%E5%B7%9E/%E5%BF%AB%E7%9A%84%E6%89%93%E8%BD%A6/Android%20%E5%BC%80%E5%8F%91杭州快的" target="_blank" rel="external">杭州快的</a>担任移动端架构师！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是<a href="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">不错的学习技术博客系列</a>第二篇，<a href="http://www.trinea.cn/" target="_]]>
    </summary>
    
      <category term="技术博客" scheme="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不错的学习技术博客之一————美团tech.meituan]]></title>
    <link href="http://hanhailong.com/2015/10/06/%E4%B8%8D%E9%94%99%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E4%B9%8B%E4%B8%80%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%BE%8E%E5%9B%A2tech-meituan/"/>
    <id>http://hanhailong.com/2015/10/06/不错的学习技术博客之一————美团tech-meituan/</id>
    <published>2015-10-06T03:00:14.000Z</published>
    <updated>2015-10-06T03:16:58.000Z</updated>
    <content type="html"><![CDATA[<p>之前看过很多的技术博客，<a href="http://tech.meituan.com/" target="_blank" rel="external">美团</a>的教学技术博客还是蛮不错的，之前看过里面的一篇文章<a href="http://tech.meituan.com/mt-apk-adaptation.html" target="_blank" rel="external">美团Android自动化之旅—适配渠道包</a>，讲的真心不错，如果再配合<a href="http://hugozhu.myalert.info/2014/08/03/50-use-gradle-to-customize-apk-build.html" target="_blank" rel="external">使用Gradle生成一个App的不同版本，且可以同时安装在一个手机上</a>，基本上使用<font color="red">Gradle</font>来构建Android应用就没啥问题了！</p>
<p>里面的文章讲的透彻清晰！非常值得去学习！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前看过很多的技术博客，<a href="http://tech.meituan.com/" target="_blank" rel="external">美团</a>的教学技术博客还是蛮不错的，之前看过里面的一篇文章<a href="http://tech.meituan]]>
    </summary>
    
      <category term="技术博客" scheme="http://hanhailong.com/tags/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android不错的开源库之-ExplosionField（View粒子炸裂效果）]]></title>
    <link href="http://hanhailong.com/2015/10/06/Android%E4%B8%8D%E9%94%99%E7%9A%84%E5%BC%80%E6%BA%90%E5%BA%93%E4%B9%8B-ExplosionField%EF%BC%88View%E7%B2%92%E5%AD%90%E7%82%B8%E8%A3%82%E6%95%88%E6%9E%9C%EF%BC%89/"/>
    <id>http://hanhailong.com/2015/10/06/Android不错的开源库之-ExplosionField（View粒子炸裂效果）/</id>
    <published>2015-10-06T00:36:16.000Z</published>
    <updated>2015-10-06T01:14:31.000Z</updated>
    <content type="html"><![CDATA[<p>前几天微博上出了一个非常优秀的Android开源组件-<a href="https://github.com/tyrantgit/ExplosionField" target="_blank" rel="external">ExplosionField</a>，效果非常的炫酷，类似MIUI卸载app的动画，先看效果：</p>
<p><img src="https://github.com/tyrantgit/ExplosionField/blob/master/explosionfield.gif?raw=true" alt="image"></p>
<a id="more"></a>
<p>我阅读了下源码，代码写的非常的不错，作者的代码功力非常深厚。这里就不赘述了，有需要的可以自己去看。</p>
<p>怎么使用呢？</p>
<p>在你的<font color="red">build.gradle</font>:</p>
<pre><code><span class="keyword">dependencies</span> {
   <span class="keyword">compile</span> <span class="string">'tyrantgit:explosionfield:1.0.0'</span>
 }
</code></pre><p>在<font color="red">Java</font>代码里：</p>
<pre><code>ExplosionField explosionField = ...<span class="comment">;</span>
explosionField.explode(view)<span class="comment">;</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>前几天微博上出了一个非常优秀的Android开源组件-<a href="https://github.com/tyrantgit/ExplosionField">ExplosionField</a>，效果非常的炫酷，类似MIUI卸载app的动画，先看效果：</p>
<p><img src="https://github.com/tyrantgit/ExplosionField/blob/master/explosionfield.gif?raw=true" alt="image"></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://hanhailong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[The resource could not be loaded because the App Transport Security policy requires the use of a secure connection]]></title>
    <link href="http://hanhailong.com/2015/10/05/The-resource-could-not-be-loaded-because-the-App-Transport-Security-policy-requires-the-use-of-a-secure-connection/"/>
    <id>http://hanhailong.com/2015/10/05/The-resource-could-not-be-loaded-because-the-App-Transport-Security-policy-requires-the-use-of-a-secure-connection/</id>
    <published>2015-10-05T01:36:33.000Z</published>
    <updated>2015-10-05T02:12:54.000Z</updated>
    <content type="html"><![CDATA[<p>   最近把Xcode升级到最新正式版7.0.1后，发现所有的项目凡是有http请求的都访问失败了，只有https请求的可以访问成功。报错内容如下：</p>
<p>   <img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/ios-9-http-error.png?raw=true" alt="image"></p>
<a id="more"></a>
<p>Google后查证，iOS9引入了新特性<a href="https://developer.apple.com/library/prerelease/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS9.html#//apple_ref/doc/uid/TP40016198-DontLinkElementID_13" target="_blank" rel="external">App Transport Security (ATS)</a></p>
<p>新特性要求App内访问的网络必须使用<font color="red">HTTPS</font>协议。<br>但是现在公司的项目使用的是HTTP协议，使用私有加密方式保证数据安全。现在也不能马上改成HTTPS协议传输。</p>
<hr>
<p>如果要让ios9支持http访问怎么做呢？我们可以采用如下方式：</p>
<ol>
<li>在Info.plist中添加使用<font color="red"> NSAppTransportSecurity</font>类型使用<font color="red"> Dictionary</font></li>
<li>在使用<font color="red">NSAppTransportSecurity</font>下添加使用<font color="red">NSAllowsArbitraryLoads</font>类型Boolean,值设为使用<font color="red">YES</font></li>
</ol>
<p>最后，修改完后Info.plist的效果图如下：</p>
<p><img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/ios-9-http-resolve.png?raw=true" alt="image"></p>
<p>经过修改之后再请求网络，发现就正常了！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>   最近把Xcode升级到最新正式版7.0.1后，发现所有的项目凡是有http请求的都访问失败了，只有https请求的可以访问成功。报错内容如下：</p>
<p>   <img src="https://github.com/hanhailong/IOSStudyResource/blob/master/screenshot/ios-9-http-error.png?raw=true" alt="image"></p>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://hanhailong.com/tags/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IOS-通过自定义iCarousel来高仿土巴兔选择装修风格效果(中间选中项放大)]]></title>
    <link href="http://hanhailong.com/2015/09/28/IOS-%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89iCarousel%E6%9D%A5%E9%AB%98%E4%BB%BF%E5%9C%9F%E5%B7%B4%E5%85%94%E9%80%89%E6%8B%A9%E8%A3%85%E4%BF%AE%E9%A3%8E%E6%A0%BC%E6%95%88%E6%9E%9C-%E4%B8%AD%E9%97%B4%E9%80%89%E4%B8%AD%E9%A1%B9%E6%94%BE%E5%A4%A7/"/>
    <id>http://hanhailong.com/2015/09/28/IOS-通过自定义iCarousel来高仿土巴兔选择装修风格效果-中间选中项放大/</id>
    <published>2015-09-28T10:22:33.000Z</published>
    <updated>2015-09-28T11:25:54.000Z</updated>
    <content type="html"><![CDATA[<p>这是<a href="http://hanhailong.com/2015/09/27/Android-%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89ViewPager%E6%9D%A5%E9%AB%98%E4%BB%BF%E5%9C%9F%E5%B7%B4%E5%85%94%E9%80%89%E6%8B%A9%E8%A3%85%E4%BF%AE%E9%A3%8E%E6%A0%BC%E6%95%88%E6%9E%9C/">Android-通过自定义ViewPager来高仿土巴兔选择装修风格效果</a>的姐妹篇，上篇通过自定义ViewPager来实现了选中的一项居中并放大的效果，这里通过<a href="https://github.com/nicklockwood/iCarousel" target="_blank" rel="external">iCarousel</a>来实现这个效果，<a href="https://github.com/nicklockwood/iCarousel" target="_blank" rel="external">iCarousel</a>是我最喜欢的一个IOS开源库之一，我几乎每个IOS项目都用到了它，真的是非常的赞。好了，废话不多说，马上进入主题，在开始之前，先看下我们高仿后的效果图：</p>
<p><img src="https://github.com/hanhailong/tubatu-iCarousel/raw/master/screenshot/tubatu-viewpager-fang-ios.gif?raw=true" alt="image"> </p>
<a id="more"></a>
<p>要实现这个效果，总体难度上要比Android上轻松不少，你不需要关心点击左右边缘切换到相应的Item，iCarousel都已经帮你实现了，而且iCarousel的每个View都是支持复用。</p>
<p><strong>总体难点就一个地方，那就是自定义iCarousel，然后设置相应的缩放动画。</strong></p>
<p>首先，我们需要把iCarousel的type值设置成<strong>iCarouselTypeCustom</strong>，看代码</p>
<pre><code>-(iCarousel *)iCarousel{
    <span class="built_in">CGFloat</span> height = ScreenWidth - <span class="number">2</span> *PAGE_OFFSET;
    <span class="keyword">if</span> (_iCarousel == <span class="literal">nil</span>) {
        _iCarousel = [[iCarousel alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, (ScreenHeight-height)*<span class="number">0.5</span>, ScreenWidth, height)];
        _iCarousel<span class="variable">.delegate</span> = <span class="keyword">self</span>;
        _iCarousel<span class="variable">.dataSource</span> = <span class="keyword">self</span>;
        _iCarousel<span class="variable">.bounces</span> = <span class="literal">NO</span>;
        _iCarousel<span class="variable">.pagingEnabled</span> = <span class="literal">YES</span>;
        _iCarousel<span class="variable">.type</span> = iCarouselTypeCustom;
    }
    <span class="keyword">return</span> _iCarousel;
}
</code></pre><p>然后，我们设置iCarousel两个必须的代理方法<strong>viewForItemAtIndex</strong>和<strong>numberOfItemsInCarousel</strong>，看代码：</p>
<pre><code><span class="preprocessor">#pragma mark - iCarousel代理</span>
-(<span class="built_in">UIView</span> *)carousel:(iCarousel *)carousel viewForItemAtIndex:(<span class="built_in">NSInteger</span>)index reusingView:(<span class="built_in">UIView</span> *)view{
    <span class="keyword">if</span> (view == <span class="literal">nil</span>) {
        <span class="built_in">CGFloat</span> viewWidth = ScreenWidth - <span class="number">2</span>*PAGE_OFFSET;
        view = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, viewWidth, viewWidth)];
    }

    ((<span class="built_in">UIImageView</span> *)view)<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:[<span class="keyword">self</span><span class="variable">.dataList</span> objectAtIndex:index]];

    <span class="keyword">return</span> view;
}

-(<span class="built_in">NSInteger</span>)numberOfItemsInCarousel:(iCarousel *)carousel{
    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.dataList</span><span class="variable">.count</span>;
}
</code></pre><p>经过上面设置后，我们的iCarousel就加进来了，但是你会发现，加进来的iCarousel不能滑动了，这是什么鬼。。。。</p>
<p>这是为什么呢？这是因为我们有一个非常重要的方法没有实现，这个方法是:</p>
<pre><code><span class="pp">-<span class="params">(<span class="variable">CATransform3D</span>)</span>carousel:<span class="params">(i<span class="variable">Carousel</span> *)</span>carousel itemTransformForOffset:<span class="params">(<span class="variable">CGFloat</span>)</span>offset baseTransform:<span class="params">(<span class="variable">CATransform3D</span>)</span>transform</span>
</code></pre><p>这个方法就是整个iCarousel的核心所在，所有的动画效果都是这个方法来实现的</p>
<p>这里稍微讲解下iCarousel的原理：</p>
<ol>
<li>iCarousel不是基于UIScrollView实现的，而是直接继承UIView来实现</li>
<li>iCarousel通过UIPanGestureRecognizer来计算和维护scrollOffset这个变量</li>
<li>iCarousel本身并不会改变itemView的位置 而是靠修改itemView的layer.transform来实现位移和形变</li>
</ol>
<p>为了实现我们想要中间放大的效果，就必须重写这个方法，看下我们的代码：</p>
<pre><code>-(CATransform3D)carousel:(iCarousel *)carousel itemTransformForOffset:(CGFloat)offset baseTransform:(CATransform3D)transform{
    <span class="keyword">static</span> CGFloat max_sacle = <span class="number">1.0f</span>;
    <span class="keyword">static</span> CGFloat min_scale = <span class="number">0.6f</span>;
    <span class="keyword">if</span> (offset &lt;= <span class="number">1</span> &amp;&amp; offset &gt;= -<span class="number">1</span>) {
        <span class="keyword">float</span> tempScale = offset &lt; <span class="number">0</span> ? <span class="number">1</span>+offset : <span class="number">1</span>-offset;
        <span class="keyword">float</span> slope = (max_sacle - min_scale) / <span class="number">1</span>;

        CGFloat scale = min_scale + slope*tempScale;
        transform = CATransform3DScale(transform, scale, scale, <span class="number">1</span>);
    }<span class="keyword">else</span>{
        transform = CATransform3DScale(transform, min_scale, min_scale, <span class="number">1</span>);
    }

    <span class="keyword">return</span> CATransform3DTranslate(transform, offset * self.iCarousel.itemWidth * <span class="number">1.4</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);
}
</code></pre><p>核心的算法和我们Android版本的是一样的，只不过这里加了这个形变，一个是Scale形变，一个是移动Translate形变。经过上面的代码就实现我们想要的结果了。</p>
<p><strong>小结</strong></p>
<p>总体实现来说，这个要比Android版本的要简单多了，核心代码就是改变layer.transform属性值。</p>
<p>这也说明<a href="https://github.com/nicklockwood/iCarousel" target="_blank" rel="external">iCarousel</a>是多么优秀的一个开源库，说到这里，我个人是非常不喜欢重复造轮子的，能用最少的代码达到所需的要求是我一直以来的准则，而且很多经典的轮子库(比如iCarousel)也值得你去深入探索和学习，了解作者的想法和思路(站在巨人的肩膀)是一种非常不错的学习方法和开阔视野的途径。</p>
<p>最后附上源码<a href="https://github.com/hanhailong/tubatu-iCarousel" target="_blank" rel="external">github</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是<a href="http://hanhailong.com/2015/09/27/Android-%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89ViewPager%E6%9D%A5%E9%AB%98%E4%BB%BF%E5%9C%9F%E5%B7%B4%E5%85%94%E9%80%89%E6%8B%A9%E8%A3%85%E4%BF%AE%E9%A3%8E%E6%A0%BC%E6%95%88%E6%9E%9C/">Android-通过自定义ViewPager来高仿土巴兔选择装修风格效果</a>的姐妹篇，上篇通过自定义ViewPager来实现了选中的一项居中并放大的效果，这里通过<a href="https://github.com/nicklockwood/iCarousel">iCarousel</a>来实现这个效果，<a href="https://github.com/nicklockwood/iCarousel">iCarousel</a>是我最喜欢的一个IOS开源库之一，我几乎每个IOS项目都用到了它，真的是非常的赞。好了，废话不多说，马上进入主题，在开始之前，先看下我们高仿后的效果图：</p>
<p><img src="https://github.com/hanhailong/tubatu-iCarousel/raw/master/screenshot/tubatu-viewpager-fang-ios.gif?raw=true" alt="image"> </p>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://hanhailong.com/tags/IOS/"/>
    
  </entry>
  
</feed>
